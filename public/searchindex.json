{"categories":[{"title":"app","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/"},{"title":"lang","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/"},{"title":"math","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/"},{"title":"os","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/"},{"title":"other","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/other/"},{"title":"robot","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robot/"}],"posts":[{"content":"一、/proc文件系统 1.进程相关信息-PID：646 进程目录中的此文件不包含任何信息；\ncwd — 指向“当前进程运行目录的”一个符号链接；\nenviron — 当前进程的环境变量列表，彼此间用空字符（NULL）隔开；变量用大写字母表示，其值用小写字母表示；\nexe — 指向启动当前进程的可执行文件（完整路径）的符号链接，通过/proc/N/exe可以启动当前进程的一个拷贝；\nfd — 这是个目录，包含当前进程打开的每一个文件的文件描述符（file descriptor），这些文件描述符是指向实际文件的一个符号链接；\nlimits — 当前进程所使用的每一个受限资源的软限制、硬限制和管理单元；此文件仅可由实际启动当前进程的UID用户读取；（2.6.24以后的内核版本支持此功能）；\nmaps — 当前进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表；\nmem — 当前进程所占用的内存空间，由open、read和lseek等系统调用使用，不能被用户读取；\nroot — 指向当前进程运行根目录的符号链接；在Unix和Linux系统上，通常采用chroot命令使每个进程运行于独立的根目录；\nstat — 当前进程的状态信息，包含一系统格式化后的数据列，可读性差，通常由ps命令使用；\nstatm — 当前进程占用内存的状态信息，通常以“页面”（page）表示；\nstatus — 与stat所提供信息类似，但可读性较好，如下所示，每行表示一个属性信息；其详细介绍请参见 proc的man手册页；\ntask — 目录文件，包含由当前进程所运行的每一个线程的相关信息，每个线程的相关信息文件均保存在一个由线程号（tid）命名的目录中，这类似于其内容类似于每个进程目录中的内容；（内核2.6版本以后支持此功能）\n2./proc/devices 系统已经加载的所有块设备和字符设备的信息，包含主设备号和设备组（与主设备号对应的设备类型）名\n3./proc/diskstats 4./proc/dma 每个正在使用且注册的ISA DMA通道的信息列表\n5./proc/execdomains 内核当前支持的执行域（每种操作系统独特“个性”）信息列表；\n6./proc/fb 帧缓冲设备列表文件，包含帧缓冲设备的设备号和相关驱动信息；\n7./proc/filesystems 当前被内核支持的文件系统类型列表文件，被标示为nodev的文件系统表示不需要块设备的支持；\n通常mount一个设备时，如果没有指定文件系统类型将通过此文件来决定其所需文件系统的类型；\n8./proc/interrupts X86或X86_64体系架构系统上每个IRQ相关的中断号列表；\n多路处理器平台上每个CPU对于每个I/O设备均有自己的中断号；\n9. /proc/iomem 每个物理设备上的记忆体（RAM或者ROM）在系统内存中的映射信息；\n10./proc/ioports 当前正在使用且已经注册过的与物理设备进行通讯的输入-输出端口范围信息列表；如下面所示，第一列表示注册的I/O端口范围，其后表示相关的设备；\n11./proc/kallsyms 模块管理工具用来动态链接或绑定可装载模块的符号定义，由内核输出；（内核2.5.71以后的版本支持此功能）；通常这个文件中的信息量相当大；\n12./proc/kcore 系统使用的物理内存，以ELF核心文件（core file）格式存储，其文件大小为已使用的物理内存（RAM）加上4KB；\n这个文件用来检查内核数据结构的当前状态，因此，通常由GBD通常调试工具使用，但不能使用文件查看命令打开此文件；\n13./proc/kmsg 此文件用来保存由内核输出的信息，通常由**/sbin/klogd或/bin/dmsg**等程序使用，不要试图使用查看命令打开此文件；\n14./proc/loadavg 保存关于CPU和磁盘I/O的负载平均值，其前三列分别表示每1秒钟、每5秒钟及每15秒的负载平均值，类似于uptime命令输出的相关信息；第四列是由斜线隔开的两个数值，前者表示当前正由内核调度的实体（进程和线程）的数目，后者表示系统当前存活的内核调度实体的数目；第五列表示此文件被查看前最近一个由内核创建的进程的PID；\n15./proc/locks 保存当前由内核锁定的文件的相关信息，包含内核内部的调试数据；每个锁定占据一行，且具有一个惟一的编号；如下输出信息中每行的第二列表示当前锁定使用的锁定类别，POSIX表示目前较新类型的文件锁，由lockf系统调用产生，FLOCK是传统的UNIX文件锁，由flock系统调用产生；第三列也通常由两种类型，ADVISORY表示不允许其他用户锁定此文件，但允许读取，MANDATORY表示此文件锁定期间不允许其他用户任何形式的访问；\n16./proc/mdstat 保存RAID相关的多块磁盘的当前状态信息，在没有使用RAID机器上，其显示为如下状态\n17./proc/meminfo 系统中关于当前内存的利用状况等的信息，常由free命令使用；可以使用文件查看命令直接读取此文件，其内容显示为两列，前者为统计属性，后者为对应的值；\n18./proc/mounts 在内核2.4.29版本以前，此文件的内容为系统当前挂载的所有文件系统，在2.4.19以后的内核中引进了每个进程使用独立挂载名称空间的方式，此文件则随之变成了指向/proc/self/mounts（每个进程自身挂载名称空间中的所有挂载点列表）文件的符号链接；/proc/self是一个独特的目录，后文中会对此目录进行介绍；\n19./proc/modules 当前装入内核的所有模块名称列表，可以由lsmod命令使用，也可以直接查看；如下所示，\n其中第一列表示模块名，\n第二列表示此模块占用内存空间大小，\n第三列表示此模块有多少实例被装入，\n第四列表示此模块依赖于其它哪些模块，\n第五列表示此模块的装载状态（Live：已经装入；Loading：正在装入；Unloading：正在卸载），\n第六列表示此模块在内核内存（kernel memory）中的偏移量；\n20./proc/partitions 块设备每个分区的主设备号（major）和次设备号（minor）等信息，同时包括每个分区所包含的块（block）数目（如下面输出中第三列所示）；\n21./proc/bus/pci 内核初始化时发现的所有PCI设备及其配置信息列表，其配置信息多为某PCI设备相关IRQ信息，可读性不高，可以用“/sbin/lspci –vb”命令获得较易理解的相关信息；在2.6内核以后，此文件已为/proc/bus/pci目录及其下的文件代替；\n22./proc/slabinfo 在内核中频繁使用的对象（如inode、dentry等）都有自己的cache，即slab pool，而/proc/slabinfo文件列出了这些对象相关slap的信息；详情可以参见内核文档中slapinfo的手册页；\n23./proc/stat 实时追踪自系统上次启动以来的多种统计信息；如下所示，其中， “cpu”行后的八个值分别表示以1/100（jiffies）秒为单位的统计值（包括系统运行于用户模式、低优先级用户模式，运系统模式、空闲模式、I/O等待模式的时间等）； “intr”行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数； “ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。 “btime”给出了从系统启动到现在为止的时间，单位为秒； “processes (total_forks) 自系统启动以来所创建的任务的个数目； “procs_running”：当前运行队列的任务的数目； “procs_blocked”：当前被阻塞的任务的数目；\n24./proc/swaps 当前系统上的交换分区及其空间利用信息，如果有多个交换分区的话，则会每个交换分区的信息分别存储于/proc/swap目录中的单独文件中，而其优先级数字越低，被使用到的可能性越大；下面是作者系统中只有一个交换分区时的输出信息；\n25./proc/uptime 系统上次启动以来的运行时间，如下所示，其第一个数字表示系统运行时间，第二个数字表示系统空闲时间，单位是秒；\n26./proc/version 当前系统运行的内核版本号，在作者的RHEL5.3上还会显示系统安装的gcc版本，如下所示；\n27./proc/vmstat 当前系统虚拟内存的多种统计数据，信息量可能会比较大，这因系统而有所不同，可读性较好；下面为作者机器上输出信息的一个片段；（2.6以后的内核支持此文件）\n28./proc/zoneinfo 内存区域（zone）的详细信息列表，信息量较大，下面列出的是一个输出片段：\n29./proc/self pid/来获取指定进程的信息。/proc/pid\n如果某个进程想要获取当前进程的系统信息，就可以通过进程的pid来访问/proc/pid/目录,但是这个方法还需要获取进程pid。\n如果程序运行中，在fork、daemon等情况下，pid还可能发生变化。\n为了更方便的获取本进程的信息，Linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息时不同的，内容等价于/proc/本进程pid/。\n进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。\n二、cpu信息 cpu硬件信息\nlscpu\rArchitecture: armv7l\rByte Order: Little Endian\rCPU(s): 4\rOn-line CPU(s) list: 0-3\rThread(s) per core: 1\rCore(s) per socket: 4\rSocket(s): 1\rVendor ID: ARM\rModel: 3\rModel name: Cortex-A72\rStepping: r0p3\rCPU max MHz: 1500.0000\rCPU min MHz: 600.0000\rBogoMIPS: 162.00\rFlags: half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32\r详细的cpu单核信息\ncat /proc/cpuinfo\rprocessor : 0\rmodel name : ARMv7 Processor rev 3 (v7l)\rBogoMIPS : 108.00\rFeatures : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32\rCPU implementer : 0x41\rCPU architecture: 7\rCPU variant : 0x0\rCPU part : 0xd08\rCPU revision : 3\rprocessor : 1\rmodel name : ARMv7 Processor rev 3 (v7l)\rBogoMIPS : 108.00\rFeatures : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32\rCPU implementer : 0x41\rCPU architecture: 7\rCPU variant : 0x0\rCPU part : 0xd08\rCPU revision : 3\rprocessor : 2\rmodel name : ARMv7 Processor rev 3 (v7l)\rBogoMIPS : 108.00\rFeatures : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32\rCPU implementer : 0x41\rCPU architecture: 7\rCPU variant : 0x0\rCPU part : 0xd08\rCPU revision : 3\rprocessor : 3\rmodel name : ARMv7 Processor rev 3 (v7l)\rBogoMIPS : 108.00\rFeatures : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32\rCPU implementer : 0x41\rCPU architecture: 7\rCPU variant : 0x0\rCPU part : 0xd08\rCPU revision : 3\rHardware : BCM2711\rRevision : b03140\rSerial : 10000000f5e46c1d\rModel : Raspberry Pi Compute Module 4 Rev 1.0\r三、内存信息 查看内存大致信息\nfree -m\rtotal used free shared buff/cache available\rMem: 1.8Gi 55Mi 1.7Gi 8.0Mi 119Mi 1.7Gi\rSwap: 99Mi 0B 99Mi\rDESCRIPTION\rfree displays the total amount of free and used physical and swap memory in the system, as well as the buffers and caches used by the kernel. The information is gathered by parsing /proc/meminfo. The displayed columns are:\r详细的内存信息\ncat /proc/meminfo\r四、磁盘信息 查看硬盘和分区分布 lsblk\rNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT\rmmcblk0 179:0 0 14.6G 0 disk\r├─mmcblk0p1 179:1 0 256M 0 part /boot\r└─mmcblk0p2 179:2 0 14.3G 0 part /\rmmcblk0boot0 179:32 0 4M 1 disk\rmmcblk0boot1 179:64 0 4M 1 disk\r2.查看硬盘和分区的详细信息\nfdisk -l\r3.文件夹信息\nsudo du -sh *\r五、网卡信息 /proc/net/dev: 我们可以实时获取\u0026quot;网络适配器及统计信息\u0026quot;\n这里我们主要关心Receive和Transmit项的bytes项。同样网卡的流量，丢包率可以通过/proc/net/dev文件来读取。 ifstat获取网卡数据就是读取的/proc/net/dev系统来的。\n/proc/net/dev\rbytes: 接口发送或接收的数据的总字节数\rpackets: 接口发送或接收的数据包总数\rerrs: 由设备驱动程序检测到的发送或接收错误的总数\rdrop: 设备驱动程序丢弃的数据包总数\rfifo: FIFO缓冲区错误的数量\rframe: 分组帧错误的数量\rcolls: 接口上检测到的冲突数\rcompressed: 设备驱动程序发送或接收的压缩数据包数\rcarrier: 由设备驱动程序检测到的载波损耗的数量\rmulticast: 设备驱动程序发送或接收的多播帧数\r","id":0,"section":"categories","summary":"一、/proc文件系统 1.进程相关信息-PID：646 进程目录中的此文件不包含任何信息； cwd — 指向“当前进程运行目录的”一个符号链接； environ — 当前","tags":[" linux"," "],"title":"linux：/proc 硬件信息查询","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/linux/%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2/","year":"2023"},{"content":"","id":1,"section":"categories","summary":"","tags":[" "," "],"title":"Minicom：linux下一款好用的串口调试工具","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/minicom/","year":"2023"},{"content":"一、简介 Pipe Viewer 的简称，意思是通过管道显示数据处理进度的信息。特别适合某些场景比如拷贝文件，不显示进度，可以用PV显示\npv(选项)(参数)\r-p, --progress 显示进度条\t【默认使用】\r-t, --timer 显示已用时间 【默认使用】\r-e, --eta 显示预计到达时间 (完成)\t【默认使用】\r-I, --fineta 显示绝对估计到达时间\r(完成)\r-r, --rate 显示数据传输速率计数器\t【默认使用】\r-a, --average-rate 显示数据传输平均速率计数器\r-b, --bytes 显示传输的字节数\t【默认使用】\r-T, --buffer-percent 显示正在使用的传输缓冲区百分比\r-A, --last-written NUM 显示上次写入的字节数\r-F, --format FORMAT 将输出格式设置为FORMAT\r-n, --numeric 输出百分比\r-q, --quiet 不输出任何信息\r-W, --wait 在传输第一个字节之前不显示任何内容\r-D, --delay-start SEC 在SEC秒过去之前不显示任何内容\r-s, --size SIZE 将估算的数据大小设置为SIZE字节\r-l, --line-mode 计算行数而不是字节数 -0, --null 行以零结尾\r-i, --interval SEC 每SEC秒更新一次\r-w, --width WIDTH 假设终端的宽度为WIDTH个字符 -H, --height HEIGHT 假设终端高度为HEIGHT行\r-N, --name NAME 在可视信息前面加上名称\r-f, --force 将标准错误输出到终端\r-c, --cursor 使用光标定位转义序列\r-L, --rate-limit RATE 将传输限制为每秒RATE字节\r-B, --buffer-size BYTES 使用BYTES的缓冲区大小\r-C, --no-splice 从不使用splice()，始终使用读/写\r-E, --skip-errors 跳过输入中的读取错误\r-S, --stop-at-size 传输--size字节后停止\r-R, --remote PID 更新过程PID的设置\r-P, --pidfile FILE 将进程ID保存在FILE中 -d, --watchfd PID[:FD] 监视进程PID,打开的文件FD\r-h, --help 显示帮助\r-V, --version 显示版本信息\r二、使用方法 2.1 复制文件 如果没有指定选项，默认使用 -p, -t, -e, -r 和 -b 选项\rpv getiot.db \u0026gt; getiot.db.bak\r","id":2,"section":"categories","summary":"一、简介 Pipe Viewer 的简称，意思是通过管道显示数据处理进度的信息。特别适合某些场景比如拷贝文件，不显示进度，可以用PV显示 pv(选项)(参数) -p, --progress 显","tags":["linux "," "],"title":"pv：Pipe Viewer 通过管道显示数据处理进度的信息","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/pv/","year":"2023"},{"content":"一、基本使用简介 usage: nc [-46CDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl]\r[-m minttl] [-O length] [-P proxy_username] [-p source_port]\r[-q seconds] [-s source] [-T keyword] [-V rtable] [-W recvlimit] [-w timeout]\r[-X proxy_protocol] [-x proxy_address[:port]] [destination] [port]\rCommand Summary:\r-4 Use IPv4\r-6 Use IPv6\r-b Allow broadcast\r-C Send CRLF as line-ending\r-D Enable the debug socket option\r-d Detach from stdin\r-F Pass socket fd\r-h This help text\r-I length TCP receive buffer length\r-i interval Delay interval for lines sent, ports scanned\r-k Keep inbound sockets open for multiple connects（配合 -l 选项使用，可以重复接受客户端连接。）\r-l Listen mode, for inbound connects（开启“监听模式”，nc 作为【服务端】注：如不加该选项，nc 默认作为客户端）\r-M ttl Outgoing TTL / Hop Limit\r-m minttl Minimum incoming TTL / Hop Limit\r-N Shutdown the network socket after EOF on stdin\r-n Suppress name/port resolutions\r-O length TCP send buffer length\r-P proxyuser Username for proxy authentication\r-p port Specify local port for remote connects（指定“端口号”）\r-q secs quit after EOF on stdin and delay of secs（让 nc 延时（N 秒）再退出）\r-r Randomize remote ports\r-S Enable the TCP MD5 signature option\r-s source Local source address\r-T keyword TOS value\r-t Answer TELNET negotiation\r-U Use UNIX domain socket\r-u UDP mode（使用 UDP 协议 注：如不加该选项，默认是 TCP 协议）\r-V rtable Specify alternate routing table\r-v Verbose （显示详细信息）\r-W recvlimit Terminate after receiving a number of packets\r-w timeout Timeout for connects and final net reads（设置连接的超时间隔（N 秒））\r-X proto Proxy protocol: \u0026quot;4\u0026quot;, \u0026quot;5\u0026quot; (SOCKS) or \u0026quot;connect\u0026quot;（指定代理的类型）\r-x addr[:port] Specify proxy address and port（以 IP:port 的格式指定代理的位置。）\r-Z DCCP mode\r-z Zero-I/O mode [used for scanning]\rPort numbers can be individual or ranges: lo-hi [inclusive]\r-g \u0026lt;网关\u0026gt; # 设置路由器跃程通信网关，最多可设置8个。\r-G\u0026lt;指向器数目\u0026gt; # 设置来源路由指向器，其数值为4的倍数。\r-h 在线帮助。\r-i\u0026lt;延迟秒数\u0026gt; 设置时间间隔，以便传送信息及扫描通信端口。\r-l 使用监听模式，管控传入的资料。\r-n 直接使用IP地址，而不通过域名服务器。\r-o\u0026lt;输出文件\u0026gt; # 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。\r-p\u0026lt;通信端口\u0026gt; # 设置本地主机使用的通信端口。\r-r 乱数指定本地与远端主机的通信端口。\r-s\u0026lt;来源位址\u0026gt; # 设置本地主机送出数据包的IP地址。\r-u 使用UDP传输协议。\r-v 显示指令执行过程。\r-w\u0026lt;超时秒数\u0026gt; # 设置等待连线的时间。\r-z 使用0输入/输出模式，只在扫描通信端口时使用\r二、netcat的使用 渗透测试（端口扫描） nc -znv 127.0.0.1 1-1024 2\u0026gt;\u0026amp;1 | grep succeeded\r选项 -z\r意思是：开启“zero-I/O 模式”。该模式指的是：nc 只判断某个监听端口是否能连上，连上后【不】与对端进行数据通讯。\r选项 -n\r由于测试的是【IP 地址】，用该选项告诉 nc，【无须】进行域名（DNS）解析；\r反之，如果你要测试的主机是基于【域名】，就【不能】用“选项 -n”\r选项 -v\r-v 选项前面也聊过，这里要特地强调一下。\r对 nc 的其它用法，-v 选项是可加可不加滴；但对于“端口扫描”而言，一定要有这个选项——否则你【看不到】扫描结果\r2\u0026gt;\u0026amp;1 | grep succeeded\r过滤掉不成功的信息\r要判断某个主机的监听端口是否能连上 nc -nv 127.0.0.1 80 选项 -v\r如果你是 nc 的新手，建议总是带上这个选项——通过更详细的输出，能帮你搞明白状况。\r选项 -n\r由于测试的是【IP 地址】，用该选项告诉 nc，【无须】进行域名（DNS）解析；\r反之，如果你要测试的主机是基于【域名】，就【不能】用“选项 -n”\r选项 -w\r超时设置 在测试链接的时候，如果你没使用 -w 这个超时选项，默认情况下 nc 会等待很久，然后才告诉你连接失败。如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加“-w 选项”，设置一个比较小的超时值。在下面的例子中，超时值设为3秒。\rnc -nv -w 3 x.x.x.x xx\rUDP 通常情况下，要测试的端口都是 TCP 协议的端口；如果你碰到特殊情况，需要测试某个 UDP 的端口是否可达。nc 同样能胜任。只需要追加 -u 选项。\r3.监听服务器 nc -lv -port 7000\r4.传输文件 4.1 单个文件\n服务器\rnc -l -p 7000 \u0026gt; file2\r客户端\rnc 127.0.0.1 7000 \u0026lt; file1\r性能优势 用 nc 传输文件，相当于是：直接在【裸 TCP】层面传输。你可以通俗理解为：【没有】应用层。如果你传输的文件【超级大】或者文件数\r量【超级多】，用 nc 传输文件的性能优势会很明显（相比“FTP、SSH、共享目录…”而言）\r4.2 目录\n服务器\rnc -lv -p 7000 | tar xvf -\r客户端\rtar cvf - * | nc -nv 127.0.0.1 7000\r管道前面表示把当前目录的所有文件打包为 - 5. 网速吞吐量测试 服务器\rnc -nvv -l -p 7000 | pv\r客户端\rtime nc -n 127.0.0.1 7000 \u0026lt; /dev/zero\r-n是不要解析域名，避免解析域名造成时间误差\r其实上面两种方法都把建立连接的握手时间以及 TCP 窗口慢启动的时间给计算进去了，不是特别精确，最精确的方式是搭配 pv 命令（监控统计管道数据的速度）\r","id":3,"section":"categories","summary":"一、基本使用简介 usage: nc [-46CDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl] [-m minttl] [-O length] [-P proxy_username] [-p source_port] [-q seconds] [-s source] [-T keyword] [-V rtable] [-W recvlimit] [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]] [destination] [port] Command Summary: -4 Use IPv4 -6 Use IPv6 -b Allow broadcast -C Send CRLF as line-ending -D Enable the debug socket option -d Detach from stdin -F","tags":[" 网络"," "],"title":"netcat：一款网络测试的瑞士军刀","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/netcat/","year":"2023"},{"content":"vim常用指令 窗口命令 新建横向窗口\n:sp\r新建纵向窗口\n:vs\r切换窗口\nctrl+w w ctrl+w h j k l\rctrl+w t(左上) b(右下)\r窗口移动\nctrl+w H 最左端\rctrl+w L 最右端\rctrl+w J 最低端\rctrl+w K 最高端\rctrl+w r 顺时针\rctrl+w R 逆时针\rctrl+w x 左右上下对应位置的窗口 对调\r调整窗口高度\n:resize 20 | +20 | -20\r:vert resize 20 | +20 | -20\r关闭窗口\nctrl+w q(quit), c(close), o(other)\r目录浏览\n:He!(上分屏)\r:He(下分屏)\r:Ve!\r:Ve\rTab标签页 :Te (tab标签)\r:tabnew 增加一个标签\r:tabc 关闭当前的tab\r:tabo 关闭所有其他的tab\r:tabs 查看所有打开的tab :tabp 或gT 前一个\r:tabn 或gt 后一个 新建标签页\r:tabe 在新标签页中打开指定的文件。\r:tabnew 在新标签页中编辑新的文件。\r:tab split 在新标签页中，打开当前缓冲区中的文件。\r:tabf 允许你在当前目录搜索文件，并在新标签页中打开\rVim默认最多只能打开10个标签页。你可以用set tabpagemax=15改变这个限制。\r代码自动补全指令 当前项\nctrl+y 上一项\nctrl+p\r下一项\nctrl+n\r保持当前文字输入，并退出补全\nctrl+e\r终端命令 终端窗口\n:term bash\r:term (cmd)\r终端命令\n:!commond\reg:\r:!gcc -v\rneovim插件配置 前提: proxy网络代理 1.WSL1 nano ~/.bashrc\r###############PROXY####################\rexport WIN11_IP=127.0.0.1\rexport all_proxy=\u0026quot;socks5://${WIN11_IP}:7890\u0026quot;\r2.wsl2 nano ~/.bashrc\r###############PROXY####################\rexport WIN11_IP=$(cat /etc/resolv.conf |grep \u0026quot;nameserver\u0026quot; |cut -f 2 -d \u0026quot; \u0026quot;)\rexport all_proxy=\u0026quot;socks5://${WIN11_IP}:7890\u0026quot;\r3. VM nano ~/.bashrc\r###############PROXY####################\rexport WIN11_IP=windowsIP\rexport all_proxy=\u0026quot;socks5://${WIN11_IP}:7890\u0026quot;\r测试\ncurl www.google.com\r插件 1.packer.nvim ##下载插件\rgit clone --depth 1 https://github.com/wbthomason/packer.nvim\\\r~/.local/share/nvim/site/pack/packer/start/require(\u0026quot;plugins\u0026quot;).nvim\r修改~/.config/nvim/init.lua\nnvim ~/.config/nvim/init.lua\r添加\rrequire(\u0026quot;plugins\u0026quot;)\r修改~/.config/nvim/lua/plugins.lua\nnvim ~/.config/nvim/lua/plugins.lua\r添加如下内容\n-- This file can be loaded by calling `lua require('plugins')` from your init.vim\r-- Only required if you have packer configured as `opt`\rvim.cmd [[packadd packer.nvim]]\rreturn require('packer').startup(function(use)\r-- packer.nvim插件包管理\ruse 'wbthomason/packer.nvim'\rend)\rnvim打开任意文件，在command模式下输入(更新插件)\n:PackerSync\r2.air-line use {\r\u0026quot;vim-airline/vim-airline\u0026quot;,\rrequires = {\r\u0026quot;vim-airline/vim-airline-themes\u0026quot;,\r--综合图标支持such vim-airline lightline, vim-startify\r\u0026quot;ryanoasis/vim-devicons\u0026quot;\r}\r}\r3.主题 3.1 gruvbox gruvbox地址 -- gruvbox theme\ruse {\r\u0026quot;ellisonleao/gruvbox.nvim\u0026quot;,\rrequires = {\u0026quot;rktjmp/lush.nvim\u0026quot;}\r}\r4.nvim-tree use {\r'kyazdani42/nvim-tree.lua',\rrequires = 'kyazdani42/nvim-web-devicons'\r}\r5.bufferline -- bufferline\ruse {'akinsho/bufferline.nvim', requires = 'kyazdani42/nvim-web-devicons'}\r","id":4,"section":"categories","summary":"vim常用指令 窗口命令 新建横向窗口 :sp 新建纵向窗口 :vs 切换窗口 ctrl+w w ctrl+w h j k l ctrl+w t(左上) b(右下) 窗口移动 ctrl+w H 最左端 ctrl+w L 最右端 ctrl+w J 最低端 ctrl+w K 最高","tags":[" vim"],"title":"neovim：一款vim的编辑器","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/neovim/","year":"2022"},{"content":"ros2模板范式 cpp 1. ament_cmake set\n#生成compile_command.json\rset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\r#c编译器\rset(CMAKE_C_COMPILER \u0026quot;/usr/bin/clang\u0026quot;)\r#cpp编译器\rset(CMAKE_CXX_COMPILER \u0026quot;/usr/bin/clang++\u0026quot;)\rset(CMAKE_CXX_FLAGS \u0026quot;${CMAKE_CXX_FLAGS} -std=c++11 -Wall -Werror\u0026quot;)\r固定范式\nfind_package(ament_cmake REQUIRED)\rfind_package(rclcpp REQUIRED)\rfind_package(std_msgs REQUIRED)\raux_source_directory(src SRC_LIST)\radd_executable(${PROJECT_NAME} ${SRC_LIST} )\rament_target_dependencies(${PROJECT_NAME} rclcpp std_msgs)\r安装\n目录\rinstall( DIRECTORY XX DESTINATION XX)\r可执行文件\rinstall(TARGETS ${PROJECT_NAME} DESTINATION lib/${PROJECT_NAME})\rpython ","id":5,"section":"categories","summary":"ros2模板范式 cpp 1. ament_cmake set #生成compile_command.json set(CMAKE_EXPORT_COMPILE_COMMANDS ON) #c编译器 set(CMAKE_C_COMPILER \u0026quot;/usr/bin/clang\u0026quot;) #cpp编译器 set(CMAKE_CXX_COMPILER \u0026quot;/usr/bin/clang++\u0026quot;) set(CMAKE_CXX_FLAGS \u0026quot;${CMAKE_CXX_FLAGS} -std=c++11 -Wall -Werror\u0026quot;) 固定范式 find_package(ament_cmake REQUIRED) find_package(rclcpp REQUIRED) find_package(std_msgs REQUIRED) aux_source_directory(src SRC_LIST)","tags":[" "," "],"title":"2_ros2模板范式","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robot/ros2%E7%9A%84%E4%BD%BF%E7%94%A8/2_ros2%E6%A8%A1%E6%9D%BF%E8%8C%83%E5%BC%8F/","year":"2022"},{"content":"ros2命令 ros2 pkg 创建功能包 # cpp\rros2 pkg create --dependencies rclcpp std_msgs --build-type ament_cmake [pkg name]\r# python\rros2 pkg create --dependencies rclpy std_msgs --build-type ament_python [pkg name]\rcolcon\u0026ndash;编译 #下载依赖\rrosdep install -y --from-paths src --rosdistro $ROS_DISTRO\rcolcon build --symlink-install ------------------\r--symlink-install : build目录中库文件软连接到install目录\r--cmake-args： cmake编译\r--packages-select： 制定编译某个包\r--parallel-workers （NUMBER）：要并行处理的最大作业数， 默认值是逻辑 CPU 内核数\r","id":6,"section":"categories","summary":"ros2命令 ros2 pkg 创建功能包 # cpp ros2 pkg create --dependencies rclcpp std_msgs --build-type ament_cmake [pkg name] # python ros2 pkg create --dependencies rclpy std_msgs --build-type ament_python [pkg name] colcon\u0026ndash;编译 #下载依赖 rosdep install -y --from-paths src --rosdistro $ROS_DISTRO colcon build --symlink-install ------------------ --symlink-install :","tags":[" robot","ros2 "],"title":"1_ros2命令的使用","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robot/ros2%E7%9A%84%E4%BD%BF%E7%94%A8/1_ros2%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/","year":"2022"},{"content":"常用的package包安装 matplotlib matlab 图形包\nconda install matplotlib\rnumpy Numeric Python。 它是一个由多维数组对象和用于处理数组的例程集合组成的库。\nconda install numpy\rSciPy Scientific Python。SciPy 是一个开源的 Python 算法库和数学工具包。SciPy 包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。\nconda install scipy\rpandas Pandas 是一个开源的第三方 Python 库，从 Numpy 和 Matplotlib 的基础上构建而来，享有数据分析“三剑客之一”的盛名（NumPy、Matplotlib、Pandas）。Pandas 已经成为 Python 数据分析的必备高级工具，它的目标是成为强大、灵活、可以支持任何编程语言的数据分析工具。\nPandas 这个名字来源于面板数据（Panel Data）与数据分析（data analysis）这两个名词的组合。\nconda install pandas\rcontrol 控制原理库\nconda install -c conda-forge control\r","id":7,"section":"categories","summary":"常用的package包安装 matplotlib matlab 图形包 conda install matplotlib numpy Numeric Python。 它是一个由多维数组对象和用于处理数组的例程集合组成的库。 conda install numpy SciPy Scientific Python。","tags":[" python"],"title":"一些常用的package包安装","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/python/package/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84package%E5%8C%85%E5%AE%89%E8%A3%85/","year":"2022"},{"content":"安装anaconda 1.环境配置 D:\\[Anaconda]\\ D:\\Anaconda\\Scripts D:\\Anaconda\\Library\\bin D:\\Anaconda\\Library\\mingw-w64\\bin（可选）\r2. 换源 打开C:\\Users\\Geton.condarc\nchannels:\r- defaults\rshow_channel_urls: true\rdefault_channels:\r- http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\r- http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\r- http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\rcustom_channels:\rconda-forge: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\rmsys2: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\rbioconda: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\rmenpo: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\rpytorch: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\rsimpleitk: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\r3.创建新的虚拟环境 conda create -p path python=3.10\r","id":8,"section":"categories","summary":"安装anaconda 1.环境配置 D:\\[Anaconda]\\ D:\\Anaconda\\Scripts D:\\Anaconda\\Library\\bin D:\\Anaconda\\Library\\mingw-w64\\bin（可选） 2. 换源 打开C:\\Users\\","tags":[" python"],"title":"如何安装anaconda","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/python/anaconda/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85anaconda/","year":"2022"},{"content":"一、.vscode的配置 c_cpp_properties.json ctrl+shift+p ,运行C/Cpp: Edit configurations...\n{\r\u0026quot;configurations\u0026quot;: [\r{\r\u0026quot;name\u0026quot;: \u0026quot;linux\u0026quot;,\r\u0026quot;includePath\u0026quot;: [\r\u0026quot;/opt/ros/melodic/include\u0026quot;,\r\u0026quot;/usr/include\u0026quot;,\r\u0026quot;${workspaceFolder}/**\u0026quot;,\r\u0026quot;${workspaceFolder}/devel/include\u0026quot;\r],\r\u0026quot;intelliSenseMode\u0026quot;: \u0026quot;linux-gcc-x64\u0026quot;,\r\u0026quot;compilerPath\u0026quot;: \u0026quot;/usr/bin/gcc\u0026quot;,\r\u0026quot;cppStandard\u0026quot;: \u0026quot;c++17\u0026quot;,\r\u0026quot;cStandard\u0026quot;: \u0026quot;c17\u0026quot;\r}\r],\r\u0026quot;version\u0026quot;: 4\r}\rtasks.json ctrl+shift+p ,运行task\n{\r// See https://go.microsoft.com/fwlink/?LinkId=733558\r// for the documentation about the tasks.json format\r\u0026quot;version\u0026quot;: \u0026quot;2.0.0\u0026quot;,\r\u0026quot;tasks\u0026quot;: [\r/*1. mkdir build*/\r{\r\u0026quot;label\u0026quot;: \u0026quot;mkdir build\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;shell\u0026quot;,\r\u0026quot;command\u0026quot;: \u0026quot;mkdir\u0026quot;,\r\u0026quot;args\u0026quot;: [\r\u0026quot;-p\u0026quot;,\r\u0026quot;build\u0026quot;\r],\r\u0026quot;options\u0026quot;: {\u0026quot;cwd\u0026quot;: \u0026quot;${workspaceFolder}\u0026quot;},\r\u0026quot;group\u0026quot;: \u0026quot;build\u0026quot;,\r},\r/*2. cmake ..*/\r{\r\u0026quot;label\u0026quot;: \u0026quot;cmake ..\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;shell\u0026quot;,\r\u0026quot;command\u0026quot;: \u0026quot;cmake\u0026quot;,\r\u0026quot;args\u0026quot;: [\r\u0026quot;..\u0026quot;\r],\r\u0026quot;options\u0026quot;: {\r\u0026quot;cwd\u0026quot;: \u0026quot;${workspaceFolder}/build\u0026quot;,\r},\r\u0026quot;group\u0026quot;: \u0026quot;build\u0026quot;,\r\u0026quot;dependsOn\u0026quot;:[\r\u0026quot;mkdir build\u0026quot;,//表示在\u0026quot;创建build\u0026quot;任务结束后进行\r]\r},\r/*3. make */\r{\r\u0026quot;label\u0026quot;: \u0026quot;make\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;shell\u0026quot;,\r\u0026quot;command\u0026quot;: \u0026quot;make\u0026quot;,\r\u0026quot;args\u0026quot;: [\r\u0026quot;\u0026quot;\r],\r\u0026quot;group\u0026quot;: \u0026quot;build\u0026quot;,\r\u0026quot;dependsOn\u0026quot;:[\r\u0026quot;cmake ..\u0026quot;,//表示在\u0026quot;创建build\u0026quot;任务结束后进行\r],\r\u0026quot;presentation\u0026quot;: {//配置用于显示任务输出并读取其输入的面板\r\u0026quot;echo\u0026quot;: true,\r\u0026quot;reveal\u0026quot;: \u0026quot;never\u0026quot;,\r\u0026quot;focus\u0026quot;: false,\r\u0026quot;panel\u0026quot;: \u0026quot;shared\u0026quot;,\r\u0026quot;showReuseMessage\u0026quot;: true,\r\u0026quot;clear\u0026quot;: false\r},\r\u0026quot;options\u0026quot;: {\u0026quot;cwd\u0026quot;: \u0026quot;${workspaceFolder}/build\u0026quot;},\r}\r]\r}\r预定义变量名字\n${workspaceFolder} - 当前工作目录(根目录)\r${workspaceFolderBasename} - 当前文件的父目录\r${file} - 当前打开的文件名(完整路径)\r${relativeFile} - 当前根目录到当前打开文件的相对路径(包括文件名)\r${relativeFileDirname} - 当前根目录到当前打开文件的相对路径(不包括文件名)\r${fileBasename} - 当前打开的文件名(包括扩展名)\r${fileBasenameNoExtension} - 当前打开的文件名(不包括扩展名)\r${fileDirname} - 当前打开文件的目录\r${fileExtname} - 当前打开文件的扩展名\r${cwd} - 启动时task工作的目录\r${lineNumber} - 当前激活文件所选行\r${selectedText} - 当前激活文件中所选择的文本\r${execPath} - vscode执行文件所在的目录\r${defaultBuildTask} - 默认编译任务(build task)的名字\r二、离线使用remote ssh 参考链接\nVS Code Server的离线安装过程 - 知乎 (zhihu.com)\n准备工作 1 确定vscode的commit id\n点击帮助\u0026ndash;\u0026gt;关于\n2 观察并记录commit id 号\n版本: 1.67.0 (system setup) 提交: 57fd6d0195bb9b9d1b49f6da5db789060795de47 日期: 2022-05-04T12:06:02.889Z Electron: 17.4.1 Chromium: 98.0.4758.141 Node.js: 16.13.0 V8: 9.8.177.13-electron.0 OS: Windows_NT x64 10.0.19044\n3 下载远程连接机器的安装包\n用2中的内容替换${commit id}\r#arm64\rhttps://update.code.visualstudio.com/commit:${commit id}/server-linux-arm64/stable\r#x64\rhttps://update.code.visualstudio.com/commit:${commit id}/server-linux-x64/stable\r#armhf\rhttps://update.code.visualstudio.com/commit:${commit id}/server-linux-armhf/stable\r安装工作 1 进入要连接的机器上，创建文件夹\nmkdir -p $HOME/.vscode-server/bin\r2 将下载包拷贝进$HOME/.vscode-server/bin目录下\n3 解压\ncd $HOME/.vscode-server/bin\rtar -zxvf vscode-server-linux-armhf.tar.gz\rrm -rf vscode-server-linux-armhf.tar.gz\r4 重命名\nmv vscode-server-linux-armhf ${commit id}\r替换为具体的id\rmv vscode-server-linux-armhf 57fd6d0195bb9b9d1b49f6da5db789060795de47\r5 改权限\ncd $HOME/.vscode-server/bin\rchmod -R 775 ${commit id}\r即\rchmod -R 775 57fd6d0195bb9b9d1b49f6da5db789060795de47\r6 连接\n使用vscode远程连接\nother 如果需要插件，找到一个类似的机器，在上面联网安装，安装后的插件在$HOME/.vscode-server/extensions下，直接打包拷贝到离线机器人相同目录就可以了。\n用win上的拷贝也可以\n三、clangd\u0026ndash;智能提示 以ubuntu为例，需要先在ubuntu中安装\nsudo apt install llvm clangd lldb\r再在打开vscode，下载两款插件 clangd 和 codelldb\n其中CodeLLDB可能会下载不成功，可以从vsix安装\n四、vscode-icons\u0026ndash;图标显示 五、NeoVim\u0026ndash;编辑器 在wsl中下载neovim\nsudo apt install neovim\r修改neovim插件的配置\n","id":9,"section":"categories","summary":"一、.vscode的配置 c_cpp_properties.json ctrl+shift+p ,运行C/Cpp: Edit configurations... { \u0026quot;configurations\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;linux\u0026quot;, \u0026quot;includePath\u0026quot;: [ \u0026quot;/opt/ros/melodic/include\u0026quot;, \u0026quot;/usr/include\u0026quot;, \u0026quot;${workspaceFolder}/**\u0026quot;, \u0026quot;${workspaceFolder}/devel/include\u0026quot; ], \u0026quot;intelliSenseMode\u0026quot;: \u0026quot;linux-gcc-x64\u0026quot;, \u0026quot;compilerPath\u0026quot;: \u0026quot;/usr/bin/gcc\u0026quot;, \u0026quot;cppStandard\u0026quot;: \u0026quot;c++17\u0026quot;, \u0026quot;cStandard\u0026quot;: \u0026quot;c17\u0026quot; } ], \u0026quot;version\u0026quot;: 4 } tasks.json ctrl+shift+p ,运行task { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the","tags":[" vscode"],"title":"VScode：一款多插件多功能的编辑器","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/vscode/","year":"2022"},{"content":"GIT 一、git 流程图 二、gitflow 参考文档：\n图解git flow开发流程 - 知乎 (zhihu.com)\n三、git指令 1 分支操作 1查看 //查看本地所有分支 git branch //查看远程所有分支\rgit branch -r //查看本地和远程的所有分支\rgit branch -a 2新建\r//新建分支\rgit branch 本地分支名\r//新建一个本地分支并切换到该分支\rgit checkout -b 本地分支名\r3删除\r//删除本地分支\rgit branch -d \u0026lt;branchname\u0026gt; //删除远程分支\rgit push origin :XXX 4重命名\r//重命名本地分支\rgit branch -m \u0026lt;oldbranch\u0026gt; \u0026lt;newbranch\u0026gt; 5关联远程\r//本地分支与远程分支建立关联\rgit branch -u origin/分支名 git branch --set-upstream-to=origin/sit-basic-v1.0.1\r//撤销本地分支与远程分支的关系\rgit branch --unset-upstream\r//查看本地分支与远程分支的映射关系\rgit branch -vv\r6合并分支\r//切换到master分支\rgit checkout master\r//将develop分支合并到master分支\rgit merge develop\r2 fetch+merge操作 //拉取远程分支\rgit fetch origin\rgit fetch origin master\r//冲突查看\rgit log -p FETCH_HEAD\r//将拉取下来的最新内容合并到当前所在的分支中\rgit merge FETCH_HEAD git merge [远程主机名]/[branch] --allow-unrelated-histories\r3 push操作 git push \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt;\r4 remote操作 1.查看当前仓库\rgit remote -v\r2.新增远程仓库\rgit remote add [name] [url]\r3.删除远程仓库\rgit remote remove [name]\r4.修改远端仓库地址\rgit remote set-url [have_a_name] [url]\r5.修改远端仓库名字\rgit remote rename \u0026lt;old_name\u0026gt; \u0026lt;new_name\u0026gt;\r6.同步本地仓库与远程仓库的分支\r//场景：有些分支在远程其实早就被删除了，但是在你本地依然可以看见这些被删除的分支\rgit remote prune [远程仓库名]\r","id":10,"section":"categories","summary":"GIT 一、git 流程图 二、gitflow 参考文档： 图解git flow开发流程 - 知乎 (zhihu.com) 三、git指令 1 分支操作 1查看 //查看本地所有分支 git branch //查","tags":[" git"],"title":"git：日常用法","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/git/","year":"2022"},{"content":"一、docker安装 Docker 官方文档 | Docker Documentation\nwindow安装 需要安装wsl2\nlinux 2.1. ubuntu安装 1.系统需求\nUbuntu Jammy 22.04 (LTS) Ubuntu Impish 21.10 Ubuntu Focal 20.04 (LTS) Ubuntu Bionic 18.04 (LTS) Docker Engine is supported on x86_64 (or amd64), armhf, arm64, and s390x architectures.\n2.卸载旧版本\nsudo apt-get remove docker docker-engine docker.io containerd runc\r3.使用仓库安装(也可以使用二进制包安装)\nsudo apt-get update\rsudo apt-get install \\\rca-certificates \\\rcurl \\\rgnupg \\\rlsb-release\r4.添加 GPG key\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\r5.添加docker源\necho \\\r\u0026quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\\r$(lsb_release -cs) stable\u0026quot; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null\r安装 Docker Engine #安装最新docker\rsudo apt-get update\rsudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\r#安装指定版本\rapt-cache madison docker-ce\rudo apt-get install docker-ce=\u0026lt;VERSION_STRING\u0026gt; docker-ce-cli=\u0026lt;VERSION_STRING\u0026gt; containerd.io docker-compose-plugin\r7.测试\ndocker version\rsudo docker run hello-world\r8.卸载 Docker Engine🔗\n//1.Uninstall the Docker Engine, CLI, Containerd, and Docker Compose packages:\rsudo apt-get purge docker-ce docker-ce-cli containerd.io docker-compose-plugin\r//2.Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:\rsudo rm -rf /var/lib/docker\rsudo rm -rf /var/lib/containerd\r3.docker加速 轻量应用服务器 安装 Docker 并配置镜像加速源-最佳实践-文档中心-腾讯云-腾讯云 (tencent.com)\n二、docker常用命令 1.命令图 2.docker run流程 3.docker 命令 3.1 帮助命令 sudo docker version #显示docker版本信息\rsudo docker info #显示docker系统信息，包括镜像和容器的数量\rdocker 命令 --help\r3.2 镜像命令 查看所有镜像 sudo docker images -a\r搜索镜像 //搜索stars数量大于500的镜像\rsudo docker search [镜像名] --filter=STARS=500\r下载镜像 sudo docker pull [镜像名]\rsudo docker pull [镜像名]:[版本名]\r删除镜像 sudo docker rmi -f [镜像ID]\r3.3 容器命令 新建容器并启动 sudo docker run [可选参数] [镜像名]\r#参数说明\r--name='name' 容器的名字\r-d\t后台交互运行\r-it 使用交互方式运行，进入容器查看内容\r-P\t指定容器的端口 -P 8080:8080\r-p\t随机指定端口\r//启动并进入容器\rsudo docker run -it [镜像名] /bin/bash\r//退出容器\rexit #直接容器停止并退出\rctrl+p+q #容器不停止，退出\r列出容器 //列出所有正在运行中的容器\rsudo docker ps\r//列出所有正在运行中的容器+历史记录\rsudo docker ps -a\r//列出最近创建的前number个的容器\rsudo docker ps -a -n=number\r删除容器 //删除停止运行的容器\rsudo docker rm [容器id]\r//删除正在运行的容器\rsudo docker rm -f [容器id]\r//删除所有容器\rsudo docker rm -f $(docker ps -aq)\r启动和停止容器 //启动容器\rsudo docker start [容器ID]\r//重启容器\rsudo docker restart [容器ID]\r//停止当前正在运行的容器\rsudo docker stop [容器ID]\r//强制停止容器\rsudo docker kill [容器ID]\r3.4 常用的其他命令 日志信息 sudo docker logs [容器ID ]\r容器进程信息 sudo docker top [容器ID ]\r容器元数据 sudo docker inspect [容器ID] 进入正在运行的容器 //进入容器后开启一个新的终端\rsudo docker exec -it [容器ID] /bin/bash\r//进入容器执行的当前终端\rsudo docker attach [容器ID] copy[容器文件copy到linux系统] sudo docker cp [容器ID]:/home/chao/demo.txt /home/chao\r","id":11,"section":"categories","summary":"一、docker安装 Docker 官方文档 | Docker Documentation window安装 需要安装wsl2 linux 2.1. ubuntu安装 1.系统需求 Ubuntu Jammy 22.04 (LTS) Ubuntu Impish 21.10 Ubuntu Focal 20.04 (LTS) Ubuntu Bionic 18.04 (LTS) Docker Engine is supported on","tags":[" docker"],"title":"Docker：一个环境打包的容器","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/docker/","year":"2022"},{"content":"Mount挂载 mount网络挂载 1 win10上新建一个文件夹 修改属性，设置共享\n如果不确定win10的用户名和密码，就新建一个本地用户\n2 linux挂载命令 查看当前linux用户id\nid 挂载\nsudo mount -t cifs -o username=chao2,password=88888888zc! -o rw,uid=1000,gid=1000 //192.168.209.1/shrae_file /home/chao/Desktop/mountpoint\r3 other windows的cifs的端口是445\n端口映射\r树莓派(车体控制)\rsudo iptables -t nat -I PREROUTING -p tcp --dport 445 -j DNAT --to-destination 192.168.8.50:445\rsudo iptables -t nat -I POSTROUTING -p tcp -d 192.168.8.50/24 --dport 445 -j SNAT --to-source 192.168.8.101\rros(导航)\rsudo mount -t cifs -o username=chao2,password=88888888zc! -o rw,uid=1000,gid=1000 //192.168.20.3/shrae_file /home/ubuntu/mount\r","id":12,"section":"categories","summary":"Mount挂载 mount网络挂载 1 win10上新建一个文件夹 修改属性，设置共享 如果不确定win10的用户名和密码，就新建一个本地用户 2 lin","tags":["linux"," tool"],"title":"Mount：网络文件夹挂载","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/mount%E6%8C%82%E8%BD%BD/","year":"2022"},{"content":"netfilter 相关网址 官网：netfilter/iptables project homepage\niptables基础知识详解_LarryHai6的博客-CSDN博客_iptables\n使用iptables进行端口转发 - 云+社区 - 腾讯云 (tencent.com)\n原理图 iptables 1. 原理叙述 iptables具有Filter, NAT, Mangle, Raw四种内建表：\n1. Filter表\nFilter表示iptables的默认表，因此如果你没有自定义表，那么就默认使用filter表，它具有以下三种内建链：\nINPUT链 – 处理来自外部的数据。 OUTPUT链 – 处理向外发送的数据。 FORWARD链 – 将数据转发到本机的其他网卡设备上。 2. NAT表\nNAT表有三种内建链：\nPREROUTING链 – 处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标IP地址（destination ip address），通常用于DNAT(destination NAT)。 POSTROUTING链 – 处理即将离开本机的数据包。它会转换数据包中的源IP地址（source ip address），通常用于SNAT（source NAT）。 OUTPUT链 – 处理本机产生的数据包。 3. Mangle表\nMangle表用于指定如何处理数据包。它能改变TCP头中的QoS位。Mangle表具有5个内建链：\nPREROUTING OUTPUT FORWARD INPUT POSTROUTING 4. Raw表\nRaw表用于处理异常，它具有2个内建链：\nPREROUTING chain OUTPUT chain 2. 命令使用 显示表内容\nsudo iptables -t filter –L num – 指定链中的规则编号 target – 前面提到的target的特殊值 ACCEPT – 允许防火墙接收数据包 DROP – 防火墙丢弃包 QUEUE – 防火墙将数据包移交到用户空间 RETURN – 防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain)中。 prot – 协议：tcp, udp, icmp等 source – 数据包的源IP地址 destination – 数据包的目标IP地址 清空表\niptables -t NAT -F\r添加规则\niptables -t 表名 \u0026lt;-A/I/D/R\u0026gt; 规则链名 [规则号] \u0026lt;-i/o 网卡名\u0026gt; -p 协议名 \u0026lt;-s 源IP/源子网\u0026gt; --sport 源端口 \u0026lt;-d 目标IP/目标子网\u0026gt; --dport 目标端口 -j 动作\r3. 特定场景 端口映射 sudo nano /etc/sysctl.conf\rnet.ipv4.ip_forward=0 改为 net.ipv4.ip_forward=1\r生效\rsudo sysctl -p\r添加规则\niptables -t nat -A PREROUTING -p tcp --dport [端口号] -j DNAT --to-destination [目标IP]\riptables -t nat -A PREROUTING -p udp --dport [端口号] -j DNAT --to-destination [目标IP]\riptables -t nat -A POSTROUTING -p tcp -d [目标IP] --dport [端口号] -j SNAT --to-source [本地服务器IP]\riptables -t nat -A POSTROUTING -p udp -d [目标IP] --dport [端口号] -j SNAT --to-source [本地服务器IP]\r将本地(内网:192.168.20.3 外网:192.168.8.101)10022端口映射到192.168.20.2:22\rsudo iptables -t nat -I PREROUTING -p tcp --dport 10022 -j DNAT --to-destination 192.168.20.2:22\rsudo iptables -t nat -I PREROUTING -p udp --dport 10022 -j DNAT --to-destination 192.168.20.2:22\rsudo iptables -t nat -I POSTROUTING -p tcp -d 192.168.20.2/24 --dport 22 -j SNAT --to-source 192.168.20.3\rsudo iptables -t nat -I POSTROUTING -p udp -d 192.168.20.2/24 --dport 22 -j SNAT --to-source 192.168.20.3\r保存生效\nservice iptables save\rservice iptables restart\r永久保存\n首先安装iptables-persistent工具 sudo apt install iptables-persistent\r每当设置了新的iptables规则后，使用如下命令保存规则即可，规则会根据ipv4和ipv6分别保存在了/etc/iptables/rules.v4和/etc/iptables/rules.v6文件中。 sudo netfilter-persistent save\r由于 ipt­a­bles-per­sis­tent 在安装时已经把它作为一个服务设置为开机启动了，它在开机后会自动加载已经保存的规则，所以也就达到了永久保存的目的。其实原理和第一种方法是类似的，只是设置起来会更简单一些。\n","id":13,"section":"categories","summary":"netfilter 相关网址 官网：netfilter/iptables project homepage iptables基础知识详解_LarryHai6的博客-CSDN博客_iptable","tags":[" linux","net","tool"],"title":"Netfilter：iptable的使用","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/netfilter/","year":"2022"},{"content":"内网穿透 1. frp解决方案 1.1 下载 wget https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_linux_arm.tar.gz\rtar -zxvf frp_0.42.0_linux_arm.tar.gz\r1.2 server配置 ​\tnote：联塑项目：车体控制程序是服务端\n进入程序目录\ncd frp_0.42.0_linux_arm\r图中红线部分是server程序及其配置文件\n修改权限\nchmod 755 frpc frps\r配置文件\nnano frps.ini\r写入如下内容\n[common]\rbind_port = 7000\r1.3 client配置 note：联塑项目：ros是客户端\n进入程序目录\ncd frp_0.42.0_linux_arm\r修改权限\nchmod 755 frpc frps\r图中红线部分是client程序及其配置文件\n配置文件\nnano frpc.ini\r写入如下内容\n[common]\rserver_addr = 192.168.8.147\rserver_port = 7000\r[ssh]\rtype = tcp\rlocal_ip = 192.168.100.10\rlocal_port = 22\rremote_port = 10022\r1.4 测试 打开server端，即车体控制程序板子 ./frps\r打开client端，即ros程序板子 ./frpc\r打开本地电脑终端 ssh -oPort=10022 pi@192.168.8.147\r1.5 开机自启动 树莓派 sudo nano /etc/rc.local\r在\u0026quot;exit 0\u0026quot;前添加脚本\rsu pi -c \u0026quot;bash ~/start/Mystart.sh \u0026amp;\u0026quot;\r创建脚本\nmkdir $HOME/start \u0026amp;\u0026amp; cd $HOME/start \u0026amp;\u0026amp; touch Mystart.sh\rchmod 755 Mystart.sh\r脚本内容\n#!/bin/bash\rsu pi -c \u0026quot;exec ~/frp/frps \u0026gt;/dev/null \u0026amp;\u0026quot;\rubuntu cd /etc/init.d \u0026amp;\u0026amp; sudo nano Mystart.sh\r脚本内容\n#!/bin/bash\rsu ubuntu -c \u0026quot;exec ~/frp/frpc \u0026gt;/dev/null \u0026amp;\u0026quot;\r给与启动权限\nsudo chmod 775 Mystart.sh\rsudo update-rc.d Mystart.sh defaults 90\r删除启动权限\nsudo update-rc.d -f Mystart.sh remove\r","id":14,"section":"categories","summary":"内网穿透 1. frp解决方案 1.1 下载 wget https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_linux_arm.tar.gz tar -zxvf frp_0.42.0_linux_arm.tar.gz 1.2 server配置 ​ note：联塑项目：车体控制程序是服务端 进入程序目录 cd frp_0.42.0_linux_arm 图中红线部分是serve","tags":[" linux","tool"],"title":"内网穿透","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/linux/app/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","year":"2022"},{"content":"ros编程 1.topic 1.1 topic_pulisher程序实现四个步骤 1.2 topic_subscriber程序实现四个步骤 note：保证回调函数中处理不能太长\n1.3 话题消息的定义与使用 - \u0026mdash;\u0026ndash;\u0026gt;定义 #在功能包src/package/,创建msg文件夹\rmkdir msg\r#编写msg/*.msg\r#打开package.xml，添加动态生成程序的依赖\r\u0026lt;build_depend\u0026gt;message_generation\u0026lt;/build_depend\u0026gt;\r\u0026lt;exec_depend\u0026gt;message_runtime\u0026lt;/exec_depend\u0026gt;\r#CMakeLists.txt添加编译选项\rfind_package(..... message_generation)\radd_message_files(FILES person.msg)\rgenerate_messages(DEPENDENCIES std_msgs)#person.msg依赖那些库\rcatkin_package(CATKIN_DEPENDS ... message_runtime)\r\u0026mdash;\u0026mdash;-\u0026gt;使用：订阅自定义的消息 ROS订阅自定义消息_plokm789456的博客-CSDN博客\n1.package.xml custom_pack_name需要修改成发布消息的包名称。\n\u0026lt;depend\u0026gt;custom_pack_name\u0026lt;/depend\u0026gt;\r2.修改CMakeLists.txt,在find_package中添加声明，其中publish_pack_name为发布消息的包的名称,其中new_pack_name为需要订阅消息的包名。\nfind_package(catkin REQUIRED COMPONENTS\rroscpp\rrospy\rpublish_pack_name\r)\radd_dependencies(new_pack_name publish_pack_name_generate_messages_cpp)\r1.4 ros内置消息类型\u0026ndash;std_msgs\n详解常用的ROS内置消息类型\n","id":15,"section":"categories","summary":"ros编程 1.topic 1.1 topic_pulisher程序实现四个步骤 1.2 topic_subscriber程序实现四个步骤 note：保证回调函数中处理不能","tags":["robat"," ros"],"title":"5_ros编程","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robot/5_ros%E7%BC%96%E7%A8%8B/","year":"2022"},{"content":"WiringPi 安装 WiringPi\n官网介绍截取 WiringPi is a PIN based GPIO access library written in C for the BCM2835, BCM2836 and BCM2837 SoC devices used in all Raspberry Pi. versions. The source code is not publicly available but may be made available to those who wish commercial support.\nIt’s designed to be familiar to people who have used the Arduino “wiring” system1 and is intended for use by experienced C/C++ programmers. It is not a newbie learning tool.\nWiringPi is developed directly on a Raspberry Pi running 32-bit Raspbian.I do not support any other platform, cross compiling or operating systems.\nRaspberry Pi | Wiring | Download \u0026amp; Install | Wiring Pi\nnote:如果官网地址打不开，直接下载github中的下载包\ninstall wget https://github.com/WiringPi/WiringPi/archive/refs/tags/2.61-1.tar.gz\rtar zxvf 2.61-1.tar.gz cd WiringPi-2.61-1/\r./build\rOK\rtest gpio -v\rgpio readall\rwiringpi API 参考博客\n树莓派wiringPi库详解 - lulipro - 博客园 (cnblogs.com)\n树莓派WiringPi常用函数中文手册-Arduino中文社区 - Powered by Discuz!\n树莓派 wiringPi 库_~莘莘的博客-程序员宝宝_wiringpi - 程序员宝宝 (cxybb.com)\n//Core wiringPi functions\rextern struct wiringPiNodeStruct *wiringPiFindNode (int pin) ;\rextern struct wiringPiNodeStruct *wiringPiNewNode (int pinBase, int numPins) ;\rextern void wiringPiVersion\t(int *major, int *minor) ;\rextern int wiringPiSetup (void) ;\rextern int wiringPiSetupSys (void) ;\rextern int wiringPiSetupGpio (void) ;\rextern int wiringPiSetupPhys (void) ;\rextern void pinModeAlt (int pin, int mode) ;\rextern void pinMode (int pin, int mode) ;\rextern void pullUpDnControl (int pin, int pud) ;\rextern int digitalRead (int pin) ;\rextern void digitalWrite (int pin, int value) ;\rextern unsigned int digitalRead8 (int pin) ;\rextern void digitalWrite8 (int pin, int value) ;\rextern void pwmWrite (int pin, int value) ;\rextern int analogRead (int pin) ;\rextern void analogWrite (int pin, int value) ;\r","id":16,"section":"categories","summary":"WiringPi 安装 WiringPi 官网介绍截取 WiringPi is a PIN based GPIO access library written in C for the BCM2835, BCM2836 and BCM2837 SoC devices used in all Raspberry Pi. versions. The source code is not publicly available but may be made available to those who wish commercial support. It’s designed to be familiar to people who have used the Arduino “w","tags":[" raspberry"],"title":"Raspberry：Wiringpi的安装及使用","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/raspberry/wiringpi/","year":"2022"},{"content":"树莓派硬件资料 40pin SDA.0、SDA.1：I2C数据传输口 SCL.0、SCL.1：I2C的时钟信号 GPIO.x（x = 0,1,2,3,4,5,6,7;21,22,23,24,25,26,27,28,29）:通用的输入输出，自己定义即可 TXD\\RXD: 串口 MOSI：主输出 从输入(SPI) MISO：主输入 从输出(SPI) SCLK：SPI通信的时钟线(SPI) CE0、CE1：片选信号(SPI) ","id":17,"section":"categories","summary":"树莓派硬件资料 40pin SDA.0、SDA.1：I2C数据传输口 SCL.0、SCL.1：I2C的时钟信号 GPIO.x（x = 0,1,2,3,4,5,6","tags":["raspberry "],"title":"Raspberry：硬件资料","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%96%99/","year":"2022"},{"content":"Raspberry系统初始配置操作 note: Raspberry Pi OS从bullseye(2022-04-04 debaian 11)以后不在设置默认用户pi和密码raspberry，建议用官方下载器烧录系统，可以自定义初始化一个用户名和密码。\n下载器地址：Raspberry Pi OS – Raspberry Pi\nRaspberry Pi OS下载地址：Operating system images – Raspberry Pi\n1. 网络配置 1.1 以太网固定ip地址 sudo nano /etc/dhcpcd.conf\r取消相应的注释\ninterface wlan0\rstatic ip_address=192.168.1.102/24\rstatic ip6_address=fd51:42f8:caae:d92e::ff/64\rstatic routers=192.168.1.1\rstatic domain_name_servers=192.168.18.1 192.168.1.1 fd51:42f8:caae:d92e::1\rinterface eth0\rstatic ip_address=192.168.1.181/24\rstatic routers=192.168.1.1\rstatic domain_name_servers=192.168.1.1\r1.2 wifi连接 1.2.1 已经进入系统，联网情况下 //进入配置文件\rsudo nano /etc/wpa_supplicant/wpa_supplicant.conf\r//添加\rnetwork={\rssid=\u0026quot;无线名称\u0026quot;\rpsk=\u0026quot;无线密码\u0026quot;\r}\r1.2.1 没用进入到系统，boot中配置 boot盘中，新建文件，文件名为wpa_supplicant.conf,写入\ncountry=CN\rctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\rupdate_config=1\rnetwork={\rssid=\u0026quot;无线名称\u0026quot;\rpsk=\u0026quot;无线密码\u0026quot;\rkey_mgmt=WPA-PSK\rpriority=1\r}\r同上创建一个名字是ssh的文本文档，什么都不写，开启ssh服务\n2. 换源 参考资源—树莓派实验室\n确定树莓派系统版本\nlsb_release -a\rnote:\n树莓派有如下两个架构：\narm64 armhf 树莓派系统有如下几个版本\nwheezy jessie stretch（Debian 9） buster（Debian 10） bullseye（Debian 11） 可用以下网站替换下面源\n中国科学技术大学 Raspbian http://mirrors.ustc.edu.cn/raspbian/raspbian/\n阿里云 Raspbian http://mirrors.aliyun.com/raspbian/raspbian/\n清华大学 Raspbian http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/\n华中科技大学 Raspbian http://mirrors.hustunique.com/raspbian/raspbian/ Arch Linux ARM http://mirrors.hustunique.com/archlinuxarm/\n华南农业大学（华南用户） Raspbian http://mirrors.scau.edu.cn/raspbian/\n大连东软信息学院源（北方用户） Raspbian http://mirrors.neusoft.edu.cn/raspbian/raspbian/\n重庆大学源（中西部用户） Raspbian http://mirrors.cqu.edu.cn/Raspbian/raspbian/\n中山大学 已跳转至中国科学技术大学源 Raspbian http://mirror.sysu.edu.cn/raspbian/raspbian/\n新加坡国立大学 Raspbian http://mirror.nus.edu.sg/raspbian/raspbian\n牛津大学 Raspbian http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian/\n韩国KAIST大学 Raspbian http://ftp.kaist.ac.kr/raspbian/raspbian/\nsudo nano /etc/apt/sources.list wheezy\ndeb http://mirrors.sysu.edu.cn/raspbian/raspbian/ wheezy main contrib non-free\rdeb-src http://mirrors.sysu.edu.cn/raspbian/raspbian/ wheezy main contrib non-free\rjessie\ndeb http://mirrors.sysu.edu.cn/raspbian/raspbian/ jessie main contrib non-free\rdeb-src http://mirrors.sysu.edu.cn/raspbian/raspbian/ jessie main contrib non-free\rstretch\ndeb http://mirrors.sysu.edu.cn/raspbian/raspbian/ stretch main contrib non-free\rdeb-src http://mirrors.sysu.edu.cn/raspbian/raspbian/ stretch main contrib non-free\rbuster\ndeb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib\rdeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib\rbullseye\n#如果需要 armhf软件源\rdeb [arch=armhf] http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib rpi\rdeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib rpi\r# 如果需要 arm64 软件源，在 `/etc/apt/sources.list` 中加上\rdeb [arch=arm64] http://mirrors.tuna.tsinghua.edu.cn/raspbian/multiarch/ bullseye main\r","id":18,"section":"categories","summary":"Raspberry系统初始配置操作 note: Raspberry Pi OS从bullseye(2022-04-04 debaian 11)以后不在设置默认用户pi和密码raspberry","tags":["command","raspberry"],"title":"Raspberry：系统初始配置操作","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/raspberry/raspberry%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E6%93%8D%E4%BD%9C/","year":"2022"},{"content":"linux官方蓝牙协议bluez的使用 相关网址 官网源码 官网文档 python调用bluez bluepy - a Bluetooth LE interface for Python — bluepy 0.9.11 documentation (ianharvey.github.io) 安装bluez (Ubuntu 20.04编译安装BlueZ-5.6_修不好的BUG的博客-CSDN博客_bluez安装\n树莓派安装BlueZ协议栈（Raspberry pi Bluetooth LE）_PaulYoung_Blog的博客-CSDN博客_bluez安装\nxz -d bluez-5.64.tar.xz\rtar zvf bluez-5.64.tar ./configure --prefix=/usr/local --mandir=/usr/local/share/man --sysconfdir=/etc --localstatedir=/var\r","id":19,"section":"categories","summary":"linux官方蓝牙协议bluez的使用 相关网址 官网源码 官网文档 python调用bluez bluepy - a Bluetooth LE interface for Python — bluepy 0.9.11 documentation (ianharvey.github.io) 安装bluez (Ubuntu 20.04","tags":["c ","project"],"title":"Bluez","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/bluez/","year":"2022"},{"content":"TCP server epoll 头文件 #include \u0026lt;sys/epoll.h\u0026gt;\r结构体 typedef union epoll_data\r{\rvoid *ptr;\rint fd;\ruint32_t u32;\ruint64_t u64;\r} epoll_data_t;\rstruct epoll_event\r{\ruint32_t events;\t/* Epoll events 即enum EPOLL_EVENTS*/\repoll_data_t data;\t/* User data variable */\r} __EPOLL_PACKED;\r宏 enum EPOLL_EVENTS\r{\rEPOLLIN = 0x001,//表示对应的文件描述符可以读\r#define EPOLLIN EPOLLIN\rEPOLLPRI = 0x002,//表示对应的文件描述符有紧急的数据可读\r#define EPOLLPRI EPOLLPRI\rEPOLLOUT = 0x004,//表示对应的文件描述符可以写\r#define EPOLLOUT EPOLLOUT\rEPOLLRDNORM = 0x040,\r#define EPOLLRDNORM EPOLLRDNORM\rEPOLLRDBAND = 0x080,\r#define EPOLLRDBAND EPOLLRDBAND\rEPOLLWRNORM = 0x100,\r#define EPOLLWRNORM EPOLLWRNORM\rEPOLLWRBAND = 0x200,\r#define EPOLLWRBAND EPOLLWRBAND\rEPOLLMSG = 0x400,\r#define EPOLLMSG EPOLLMSG\rEPOLLERR = 0x008,//表示对应的文件描述符发生错误\r#define EPOLLERR EPOLLERR\rEPOLLHUP = 0x010,//表示对应的文件描述符被挂断\r#define EPOLLHUP EPOLLHUP\rEPOLLRDHUP = 0x2000,\r#define EPOLLRDHUP EPOLLRDHUP\rEPOLLEXCLUSIVE = 1u \u0026lt;\u0026lt; 28,\r#define EPOLLEXCLUSIVE EPOLLEXCLUSIVE\rEPOLLWAKEUP = 1u \u0026lt;\u0026lt; 29,\r#define EPOLLWAKEUP EPOLLWAKEUP\rEPOLLONESHOT = 1u \u0026lt;\u0026lt; 30,//只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。\r#define EPOLLONESHOT EPOLLONESHOT\rEPOLLET = 1u \u0026lt;\u0026lt; 31//将EPOLL设为边缘触发(Edge Triggered)模式\r#define EPOLLET EPOLLET\r};\r/* Valid opcodes ( \u0026quot;op\u0026quot; parameter ) to issue to epoll_ctl(). */\r#define EPOLL_CTL_ADD 1\t/* Add a file descriptor to the interface. */\r#define EPOLL_CTL_DEL 2\t/* Remove a file descriptor from the interface. */\r#define EPOLL_CTL_MOD 3\t/* Change file descriptor epoll_event structure. */\rAPI epoll_create()函数 功能：创建一个epoll实例。\n返回值：如果成功，返回一个epoll 的句柄fd（note：epoll占用一个fd，发生错误时，返回-1，\n注意：从Linux 2.6.8开始，size参数被忽略，但必须大于零；\n#include \u0026lt;sys/epoll.h\u0026gt;\rint epoll_create (int __size)\r这个文件描述符用于所有后续调用epoll的所有接口。 当不再需要文件描述符时，使用close关闭。 当所有指向这个epoll实例的文件描述符都关闭时，内核销毁实例并释放关联的重用资源\nepoll_create1()函数 功能：创建一个epoll实例。 如果flags为0，epoll_create1（）和删除了过时size参数的epoll_create（）相同。\n#include \u0026lt;sys/epoll.h\u0026gt;\rint epoll_create1 (int __flags)\repoll_ctl()函数 功能：该系统调用对文件描述符epfd引用的epoll实例执行控制操作。\n#include \u0026lt;sys/epoll.h\u0026gt;\rint epoll_ctl (int __epfd, int __op, int __fd,struct epoll_event *__event) op: EPOLL_CTL_ADD、EPOLL_CTL_DEL、EPOLL_CTL_MOD\nepoll_wait()函数 #include \u0026lt;sys/epoll.h\u0026gt;\rint epoll_wait (int __epfd, struct epoll_event *__events,int __maxevents, int __timeout)\repoll_pwait()函数 #include \u0026lt;sys/epoll.h\u0026gt; int epoll_pwait (int __epfd, struct epoll_event *__events,int __maxevents, int __timeout,\rconst __sigset_t *__ss);\r","id":20,"section":"categories","summary":"TCP server epoll 头文件 #include \u0026lt;sys/epoll.h\u0026gt; 结构体 typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events 即enum EPOLL_EVENTS*/ epoll_data_t data; /* User data variable */ } __EPOLL_PACKED; 宏 enum EPOLL_EVENTS { EPOLLIN = 0x001,//表示对应的文件描","tags":[" c","linux ","project","net"],"title":"Tcp_server","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/tcp_server/","year":"2022"},{"content":"LINUX串口编程\u0026ndash;raw 参考blog [ linux-串口应用编程_邻居家的小南瓜的博客-CSDN博客](https://blog.csdn.net/qq_37932504/article/details/121125906?ops_request_misc=\u0026amp;request_id=\u0026amp;biz_id=102\u0026amp;utm_term=linux 串口api\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-121125906.142^v9^pc_search_result_control_group,157^v4^new_style\u0026amp;spm=1018.2226.3001.4187)\nAPI总结 \u0026lt;termios.h\u0026gt; /* Return the output baud rate stored in *TERMIOS_P. */\rextern speed_t cfgetospeed (const struct termios *__termios_p) __THROW;\r/* Return the input baud rate stored in *TERMIOS_P. */\rextern speed_t cfgetispeed (const struct termios *__termios_p) __THROW;\r/* Set the output baud rate stored in *TERMIOS_P to SPEED. */\rextern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __THROW;\r/* Set the input baud rate stored in *TERMIOS_P to SPEED. */\rextern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __THROW;\r#ifdef\t__USE_MISC\r/* Set both the input and output baud rates in *TERMIOS_OP to SPEED. */\rextern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __THROW;\r#endif\r/* Put the state of FD into *TERMIOS_P. */\rextern int tcgetattr (int __fd, struct termios *__termios_p) __THROW;\r/* Set the state of FD to *TERMIOS_P.\rValues for OPTIONAL_ACTIONS (TCSA*) are in \u0026lt;bits/termios.h\u0026gt;. */\rextern int tcsetattr (int __fd, int __optional_actions,\rconst struct termios *__termios_p) __THROW;\r#ifdef\t__USE_MISC\r/* Set *TERMIOS_P to indicate raw mode. */\rextern void cfmakeraw (struct termios *__termios_p) __THROW;\r#endif\r/* Send zero bits on FD. */\rextern int tcsendbreak (int __fd, int __duration) __THROW;\r/* Wait for pending output to be written on FD.\rThis function is a cancellation point and therefore not marked with\r__THROW. */\rextern int tcdrain (int __fd);\r/* Flush pending data on FD.\rValues for QUEUE_SELECTOR (TC{I,O,IO}FLUSH) are in \u0026lt;bits/termios.h\u0026gt;. */\rextern int tcflush (int __fd, int __queue_selector) __THROW;\r/* Suspend or restart transmission on FD.\rValues for ACTION (TC[IO]{OFF,ON}) are in \u0026lt;bits/termios.h\u0026gt;. */\rextern int tcflow (int __fd, int __action) __THROW;\r#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\r/* Get process group ID for session leader for controlling terminal FD. */\rextern __pid_t tcgetsid (int __fd) __THROW;\r#endif\ropen()函数 功能：打开设备文件\n返回值：如果操作成功，它将返回一个文件描述符，如果操作失败，它将返回-1\nint open (const char *__path, int __oflag, ...)\rnote:flags = O_RDWR | O_NOCTTY | O_NDELAY | O_EXCL;（libmodbus代码截取）\nO_RDWR ： 可读可写\nO_NOCTTY ：该参数不会使打开的文件成为该进程的控制终端。如果没有指定这个标志，那么任何一个 输入都将会影响用户的进程。\nO_NDELAY ：这个程序不关心DCD信号线所处的状态,端口的另一端是否激活或者停止。如果用户不指定了这个标志，则进程将会一直处在睡眠状态，直到DCD信号线被激活。\nO_EXCL：原子操作，确保只有一个执行流使用这个设备文件\ntcgetattr()函数 功能：获取终端的属性\n返回值：返回值：调用成功时返回 0；失败将返回-1\n#include \u0026lt;termios.h\u0026gt;\rint tcgetattr(int fd, struct termios *termios_p);\rtcsetattr()函数 功能：修改终端的属性\n返回值：返回值：调用成功时返回 0；失败将返回-1\n#include \u0026lt;termios.h\u0026gt;\rint tcsetattr(int fd, int optional_actions,const struct termios *termios_p);\rnote：optional_actions\u0026ndash;更改何时生效\nTCSANOW 配置立即生效 TCSADRAIN 配置在所有写入 fd 的输出都传输完毕之后生效 TCSAFLUSH 所有已接收但未读取的输入都将在配置生效之前被丢弃 cfmakeraw()函数 功能：将终端配置为原始模式。\nvoid cfmakeraw(struct termios *termios_p);\r波特率设置 //获取输入输出波特率\rextern speed_t cfgetospeed (const struct termios *__termios_p) __THROW;\rextern speed_t cfgetispeed (const struct termios *__termios_p) __THROW;\r//修改输入输出波特率\rextern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __THROW;\rextern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __THROW;\r//同时修改输入输出波特率\rextern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __THROW;\rtcdrain()函数 功能：调用 tcdrain()函数后会使得应用程序阻塞， 直到串口输出缓冲区中的数据全部发送完毕为止\n返回值：调用成功时返回 0；失败将返回-1，\n#include \u0026lt;termios.h\u0026gt; int tcdrain(int fd);\rtcflush()函数 功能：调用该函数会清空输入/输出缓冲区中的数据\n返回值：返回值：调用成功时返回 0；失败将返回-1\n#include \u0026lt;termios.h\u0026gt;\rint tcflush(int fd, int queue_selector);\rnote:queue_selector\nTCIFLUSH 对接收到而未被读取的数据进行清空处理 TCOFLUSH 对尚未传输成功的输出数据进行清空处理 TCIOFLUSH 对尚未处理的输入/输出数据进行清空处理 tcflow()函数 功能：调用 tcflow()函数会暂停数据传输或接收工作。\n返回值：返回值：调用成功时返回 0；失败将返回-1。\n#include \u0026lt;termios.h\u0026gt;\rint tcflow(int fd, int action);\rnote: action\nTCOOFF 暂停数据输出（输出传输） TCOON 重新启动暂停的输出 TCIOFF 发送 STOP 字符，停止终端设备向系统发送数据 TCION 发送一个 START 字符，启动终端设备向系统发送数据； struct termios结构体 struct termios\r{\rtcflag_t c_iflag; /* input mode flags */\rtcflag_t c_oflag; /* output mode flags */\rtcflag_t c_cflag; /* control mode flags */\rtcflag_t c_lflag; /* local mode flags */\rcc_t c_line; /* line discipline */\rcc_t c_cc[NCCS]; /* control characters */\rspeed_t c_ispeed; /* input speed */\rspeed_t c_ospeed; /* output speed */\r};\r波特率、数据位、停止位使用案例 /*0. 保存原有的termios*/\rtcgetattr(this-\u0026gt;fd, \u0026amp;old_termios);\r/*1. 设置波特率 */\rnew_termios.c_cflag\u0026amp;=~CBAUD;//波特率掩码(000000010017 /* baud speed mask)\rif(cfsetispeed(\u0026amp;(new_termios),baud_adapt(baudrate))\u0026lt;0)\r{\rstd::cerr\u0026lt;\u0026lt;\u0026quot;[err]:function cfsetispeed()--set \u0026quot;\u0026lt;\u0026lt; baudrate\u0026lt;\u0026lt;\u0026quot; input baudrate failed!!!\\n\u0026quot;;\rthis-\u0026gt;uart_close();\rreturn -1;\r}\rif(cfsetospeed(\u0026amp;(new_termios),baud_adapt(baudrate))\u0026lt;0)\r{\rstd::cerr\u0026lt;\u0026lt;\u0026quot;[err]:function cfsetospeed()--set \u0026quot;\u0026lt;\u0026lt; baudrate\u0026lt;\u0026lt;\u0026quot; output baudrate failed!!!\\n\u0026quot;;\rthis-\u0026gt;uart_close();\rreturn -1;\r}\r/* 2.设置数据位 */\rnew_termios.c_cflag\u0026amp;=~CSIZE;//屏蔽其他标志\rswitch (databits)//设置数据位\r{\rcase 5:\rnew_termios.c_cflag|=CS5;\rbreak;\rcase 6:\rnew_termios.c_cflag|=CS6;\rbreak;\rcase 7:\rnew_termios.c_cflag|=CS7;\rbreak;\rcase 8:\rnew_termios.c_cflag|=CS8;\rbreak;\rdefault:\rthis-\u0026gt;uart_close();\rstd::cerr\u0026lt;\u0026lt;\u0026quot;[err]:set databits failed!!!\\n\u0026quot;;\rreturn -1;\rbreak;\r}\r/*3. 设置奇偶检验 */\rswitch (parity)\r{\rcase 'N'://无\rnew_termios.c_iflag \u0026amp;= ~(INPCK | ISTRIP);//关闭输入奇偶检验检查\rnew_termios.c_cflag \u0026amp;= ~PARENB;//关闭奇偶位\rbreak;\rcase 'E'://奇\rnew_termios.c_iflag |= (INPCK );//开启输入奇偶检验检查\rnew_termios.c_cflag |= PARENB;//开启奇偶位\rnew_termios.c_cflag \u0026amp;= ~PARODD;//关闭偶位\rbreak;\rcase 'O'://偶\rnew_termios.c_iflag |= (INPCK);//开启输入奇偶检验检查\rnew_termios.c_cflag|= PARENB;//开启奇偶位\rnew_termios.c_cflag |= PARODD;//开启偶位\rbreak;\rdefault:\rthis-\u0026gt;uart_close();\rstd::cerr\u0026lt;\u0026lt;\u0026quot;[err]:set parity failed!!!\\n\u0026quot;;\rreturn -1;\rbreak;\r}\r/*4. 设置停止位 */\rswitch (stopbits)\r{\rcase 1:\rnew_termios.c_cflag \u0026amp;= ~CSTOPB;\rbreak;\rcase 2:\rnew_termios.c_cflag |= CSTOPB;//每个字符使用2bit停止位，否者就使用一个\rbreak;\rdefault:\rthis-\u0026gt;uart_close();\rbreak;\r}\r/*5. 设置非规范模式(即raw模式)，也可以使用cfmakeraw()函数*/\rnew_termios.c_lflag \u0026amp;= ~(ICANON | ECHO | ECHOE | ISIG);\rnew_termios.c_oflag \u0026amp;=~ OPOST; /* Raw output */\rnew_termios.c_cc[VMIN]=0;\rnew_termios.c_cc[VTIME]=1;\r/*6.other*/\rnew_termios.c_oflag \u0026amp;= ~OPOST; /* Raw output */\rnew_termios.c_iflag \u0026amp;= ~(IXON | IXOFF | IXANY); /* Software flow control is disabled */\rnew_termios.c_iflag \u0026amp;= ~(IUCLC|ICRNL|INLCR|IGNCR);/* 1.关闭input大小写转换 2.禁止CR、LF相互转换 3.不忽略CR、LF*/\rnew_termios.c_oflag \u0026amp;= ~(OLCUC|OCRNL|ONLCR);/* 1.关闭output大小写转换 2.同上*/\r/*7.设置生效 */\rif(tcsetattr(this-\u0026gt;fd,TCSANOW,\u0026amp;(new_termios))\u0026lt;0)\r{\rstd::cerr\u0026lt;\u0026lt;\u0026quot;[err]:function tcsetattr()--set attr failed!!!\\n\u0026quot;;\rthis-\u0026gt;uart_close();\rreturn -1;\r}\r非规范模式：C_CC[]\u0026ndash;MIN TIME 代码及其测试 代码 [代码案例 click here](code/02c/uart at main · Getonechao/code (github.com))\n测试 %写\rclear;\rdevice=serialport(\u0026quot;COM5\u0026quot;,115200,\u0026quot;Parity\u0026quot;,\u0026quot;even\u0026quot;,\u0026quot;DataBits\u0026quot;,8,\u0026quot;StopBits\u0026quot;,1);\rflush(device);\rfor i=1:10\rwrite(device,[0:255],\u0026quot;uint8\u0026quot;);\rend\r%读\rclear;\rdevice=serialport(\u0026quot;COM5\u0026quot;,115200,\u0026quot;Parity\u0026quot;,\u0026quot;even\u0026quot;,\u0026quot;DataBits\u0026quot;,8,\u0026quot;StopBits\u0026quot;,1);\rflush(device);\rret=read(device,3,\u0026quot;uint8\u0026quot;)\r","id":21,"section":"categories","summary":"LINUX串口编程\u0026ndash;raw 参考blog [ linux-串口应用编程_邻居家的小南瓜的博客-CSDN博客](https://blog","tags":[" c","project ","linux"],"title":"Linux串口编程","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/linux%E4%B8%B2%E5%8F%A3%E7%BC%96%E7%A8%8B/","year":"2022"},{"content":"ubuntu系统初始化常用一些指令 换源 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\rsudo nano /etc/apt/sources.list\r清华源 # 清华源\r18.04\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\r20.04\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse multiverse\r阿里源 18.04\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\r20.04\rdeb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\r更新源 sudo apt-get update\r安装工具 sudo apt install g++ cmake openssh-server libtool autoconf git\rnote：如果vscode或者ssh在装新系统失败后，可能是.ssh/known_hosts文件中ip对应的指纹还是旧的。\ngit config --global user.email \u0026quot;1509670272@qq.com\u0026quot;\rgit config --global user.name \u0026quot;chao\u0026quot;\rSSH-公钥生成 ssh-keygen -t rsa -C \u0026quot;chao\u0026quot;\rcat ~/.ssh/id_rsa.pub 无密码ssh登入其他ubuntu系统\r$ cat ~/.ssh/id_rsa.pub(本地) \u0026gt;\u0026gt; ~/.ssh/authorized_keys(远程) 创建新用户 创建用户\ruseradd chao -p chao -m -G wheel（或sudo） -s /bin/bash -c \u0026quot;2021-6-3 create 'chao' username \u0026quot;\r修改密码\rpasswd chao\r","id":22,"section":"categories","summary":"ubuntu系统初始化常用一些指令 换源 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak sudo nano /etc/apt/sources.list 清华源 # 清华源 18.04 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src","tags":[" ubuntu","command"],"title":"ubuntu系统初始化常用一些指令","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/ubuntu/ubuntu%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E6%93%8D%E4%BD%9C/","year":"2022"},{"content":"libmodbus的使用 安装 wget https://github.com/stephane/libmodbus/archive/refs/tags/v3.1.7.zip\runzip v3.1.7.zip\rsudo apt install libtool\rsudo apt install autoconf\r./autoconf\r./configure --prefix=/usr/local/\rsudo make install\r源码解析 参考网址\n【嵌入式】Libmodbus源码分析(一)-类型和结构体_沧海一笑-dj的博客-CSDN博客_libmodbus源码 【嵌入式】Libmodbus源码分析(二)-常用接口函数分析_沧海一笑-dj的博客-CSDN博客_modbus接口函数 【嵌入式】Libmodbus源码分析(三)-modbus相关函数分析_沧海一笑-dj的博客-CSDN博客_libmodbus代码示例 【嵌入式】Libmodbus源码分析(四)-RTU相关函数分析_沧海一笑-dj的博客-CSDN博客 【嵌入式】Libmodbus源码分析(五)-TCP相关函数分析_沧海一笑-dj的博客-CSDN博客 【嵌入式】嵌入式天地博客汇总_沧海一笑-dj的博客-CSDN博客 [libmodbus官方手册中文翻译_跃动的风的博客-CSDN博客_libmodbus使用说明](https://blog.csdn.net/qq_23670601/article/details/82155378?ops_request_misc=\u0026amp;request_id=\u0026amp;biz_id=102\u0026amp;utm_term=libmodbus debug\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-82155378.142^v9^pc_search_result_control_group,157^v4^new_style\u0026amp;spm=1018.2226.3001.4187) note: 如果使用matlab modbus explorer,matlab中的寄存器地址从1开开始算起，实际应该libmodbus中的地址0\n","id":23,"section":"categories","summary":"libmodbus的使用 安装 wget https://github.com/stephane/libmodbus/archive/refs/tags/v3.1.7.zip unzip v3.1.7.zip sudo apt install libtool sudo apt install autoconf ./autoconf ./configure --prefix=/usr/local/ sudo make install 源码解析 参考网址 【嵌入式】Libmodbus源码分析(一)-类型和结构体_沧","tags":[" project","c"],"title":"Libmodbus","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/libmodbus/","year":"2022"},{"content":"一、Cmake模板 cmake_minimum_required(VERSION 3.1)\rproject(PROJECT_XXX VERSION 0.0.0.0 )\r#C/C++标准\rset(CMAKE_CXX_STANDARD 14)\rset(CMAKE_C_STANDARD 11)\r#设置编译器\rset (CMAKE_C_COMPILER \u0026quot;/usr/bin/gcc\u0026quot;)\rset (CMAKE_CXX_COMPILER \u0026quot;/usr/bin/g++\u0026quot;)\r#lib\u0026amp;\u0026amp;bin\rset(LIBRARY_OUTPUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/lib)\rset(EXECUTABLE_OUTPUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/bin)\r#release debug\rset(CMAKE_BUILD_TYPE Debug#[[Release | Debug| RelWithDebInfo |MinSizeRel]])\r#add_compile_options()#等同CMAKE_CXXFLAGS_RELESE,前者可以对所有的编译器设置，后者只能是C++编译器\rinclude_directories(\r目录\r)\raux_source_directory(目录 变量)\r#FIND_LIBRARY(#变量 libceres.so #目录)\radd_executable(${PROJECT_NAME} )\r#target_link_libraries(${PROJECT_NAME} #/usr/local/lib/libmodbus.so)\r","id":24,"section":"categories","summary":"一、Cmake模板 cmake_minimum_required(VERSION 3.1) project(PROJECT_XXX VERSION 0.0.0.0 ) #C/C++标准 set(CMAKE_CXX_STANDARD 14) set(CMAKE_C_STANDARD 11) #设置编译器 set (CMAKE_C_COMPILER \u0026quot;/usr/bin/gcc\u0026quot;) set (CMAKE_CXX_COMPILER \u0026quot;/usr/bin/g++\u0026quot;) #lib\u0026amp;\u0026amp;bin set(LIBRARY_OUTPUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/lib) set(EXECUTABLE_OUTPUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/bin) #release debug set(CMAKE_BUILD_TYPE Debug#[[Release | Debug| RelWithDebInfo |MinSizeRel]]) #add_compile_optio","tags":[" project","cmake"],"title":"cmake：c/c++的工程构建工具","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/cmake/","year":"2022"},{"content":"使用vspd配置VM的虚拟机的串口调试 下载vspd 链接：https://pan.baidu.com/s/15sQ3B3Ty4QGH8Rvl7yFz0g 提取码：kjdw\n创建虚拟串口 VM绑定相应的串口 note:\n将windows的串口com5绑定到linux的串口/dev/ttyS1上 如果Vm没有检测到虚拟串口，请关闭vm，重启vm 图片中的\u0026quot;串行端口n\u0026quot;，实际对应linux系统中/dev/ttyS(n-1) ","id":25,"section":"categories","summary":"使用vspd配置VM的虚拟机的串口调试 下载vspd 链接：https://pan.baidu.com/s/15sQ3B3Ty4QGH8Rvl7","tags":[" project"],"title":"vspd\u0026VM","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/vspd/","year":"2022"},{"content":"freemodus 源码 cwalter-at/freemodbus\narmink/FreeModbus_Slave-Master-RTT-STM32: Add master mode to FreeModbus. | 在 FreeModbus 中添加主机模式 (github.com)\nmodbus 0x01 读线圈寄存器 0x02 读离散输入寄存器 0x03 读保持寄存器 0x04 读输入寄存器 0x05 写单个线圈寄存器 0x06 写单个保持寄存器 0x0f 写多个线圈寄存器 0x10 写多个保持寄存器 线圈寄存器（0x01、0x05、0x0f） 寄存器的单位是1bit,类比为开关量，每一个bit都对应一个信号的开关状态，1byte有8bit\n离散输入寄存器（0x02） 离散输入寄存器就相当于线圈寄存器的只读模式\n保持寄存器（0x03、0x06、0x10） 寄存器的单位是2byte,即16bit\n输入寄存器（0x04） 和保持寄存器类似，但是也是只支持读而不能写\nmodbus地址规范 00001至09999是离散输出(线圈)\u0026mdash;\u0026ndash;Coil status 10001至19999是离散输入(触点)\u0026mdash;\u0026ndash;Input status 30001至39999是输入寄存器(通常是模拟量输入)\u0026mdash;\u0026mdash;Input register 40001至49999是保持寄存器 \u0026mdash;\u0026mdash;-Holding register\n0x代表线圈（DO）类地址，1x代表触点（DI）类地址、 3x代表输入寄存器（AI）类地址、4x代表输出寄存器（AO）类地址。在实际编程中，由于前缀的区分作用，所以只需说明后4位数，而且需转换为4位十六进制地址\nLinux的使用 官方规定的流程：\n* // Initialize protocol stack in RTU mode for a slave with address 10 = 0x0A\r* eMBInit( MB_RTU, 0x0A, 38400, MB_PAR_EVEN );\r* // Enable the Modbus Protocol Stack.\r* eMBEnable( );\r* for( ;; )\r* {\r* // Call the main polling loop of the Modbus protocol stack.\r* eMBPoll( );\r* ...\r* }\rRTU #include \u0026lt;iostream\u0026gt;\r#include \u0026quot;mb.h\u0026quot;\r#include \u0026quot;mbport.h\u0026quot;\r#define REG_INPUT_START 1000 /* 输入寄存器开始地址 */\r#define REG_INPUT_NREGS 4 /* usRegInputBuf数组大小 */\r#define REG_HOLDING_START 2000 /* 保持寄存器开始地址 */\r#define REG_HOLDING_NREGS 130 /* usRegHoldingBuf数组大小 */\rint main()\r{\r/*RTUm模式 从机地址 uart 波特率 奇偶无校验 */\reMBInit( MB_RTU, 0x05,0,115200, MB_PAR_NONE );\rif(eMBEnable( )== MB_ENOERR)\r{ for( ;; )\r{\r// Call the main polling loop of the Modbus protocol stack.\rif( eMBPoll( ) != MB_ENOERR )\rbreak;\r}\rstd::cerr\u0026lt;\u0026lt;\u0026quot;err: eMBPoll failed!\u0026quot;;\r}\relse\r{\rstd::cerr\u0026lt;\u0026lt;\u0026quot;err: eMBEnable failed!\u0026quot;;\r}\rreturn 0;\r}\r/* ----------------------- Static variables ---------------------------------*/\rstatic USHORT usRegInputStart = REG_INPUT_START;\rstatic USHORT usRegInputBuf[REG_INPUT_NREGS]={0x1,0x2,0x3,0x4}; //输入寄存器数组\rstatic USHORT usRegHoldingStart = REG_HOLDING_START;\rstatic USHORT usRegHoldingBuf[REG_HOLDING_NREGS];//保持寄存器数组\r/* 输入寄存器 */\reMBErrorCode eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress,USHORT usNRegs )\r{\reMBErrorCode eStatus = MB_ENOERR;\rint iRegIndex;\rstd::cout\u0026lt;\u0026lt;\u0026quot;enter\\n\u0026quot;;\r/**\r* 满足条件：\r* 1. 主机请求地址大于REG_INPUT_START\r* 2. 主机请求数据量不超过 usRegInputBuf数组大小\r*/\rif( ( usAddress \u0026gt;= REG_INPUT_START )\r\u0026amp;\u0026amp; ( usAddress + usNRegs \u0026lt;= REG_INPUT_START + REG_INPUT_NREGS ) )\r{\riRegIndex = ( int )( usAddress - usRegInputStart );\rwhile( usNRegs \u0026gt; 0 )\r{\r*pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] \u0026gt;\u0026gt; 8 );\r*pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] \u0026amp; 0xFF );\riRegIndex++;\rusNRegs--;\r}\r}\relse\r{\reStatus = MB_ENOREG;\r}\rreturn eStatus;\r}\r/* 保持寄存器 */\reMBErrorCode eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress,USHORT usNRegs, eMBRegisterMode eMode )\r{\r}\r/* 线圈寄存器 */\reMBErrorCode eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress,USHORT usNCoils, eMBRegisterMode eMode )\r{\r}\r/* 离散输入寄存器 */\reMBErrorCode eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress,USHORT usNDiscrete )\r{\r}\r","id":26,"section":"categories","summary":"freemodus 源码 cwalter-at/freemodbus armink/FreeModbus_Slave-Master-RTT-STM32: Add master mode to FreeModbus. | 在 FreeModbus 中添加主机模式 (github.com) modbus 0x01 读线圈寄存器 0x02 读离散输入寄存器 0x03 读保持寄存器 0x04 读输入寄存器 0x05 写单个线圈寄存器 0x06 写单个保持寄存器","tags":["project","c"],"title":"Freemodbus","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/freemodbus/","year":"2022"},{"content":"matlab\u0026ndash;符号表达式转LaTeX、C、mathml代码 网址\u0026ndash;Code Generation - MATLAB \u0026amp; Simulink - MathWorks 中国\nlatex syms f(t);\ry=f==5*exp(-0.8*t)*sin(pi*t);\rlatex(y)\rans= \u0026lsquo;f\\left(t\\right)=5,{\\mathrm{e}}^{-\\frac{4,t}{5}},\\sin\\left(\\pi ,t\\right)\u0026rsquo;\nMathml syms f(t);\ry=f==5*exp(-0.8*t)*sin(pi*t);\rmathml(y)\rf\r(\rt\r)\r\u0026equals;\r5\r\u0026InvisibleTimes;\r\u0026ee;\r-\r4\r\u0026InvisibleTimes;\rt\r5\r\u0026InvisibleTimes;\rsin\r(\r\u0026pi;\r\u0026InvisibleTimes;\rt\r)\rC 1. 得到一个函数表达式\rsyms f(t);\rf=5*exp(-0.8*t)*sin(pi*t);\rccode(f)\r2. 矩阵\rI3 = sym(eye(3));\rI3code = ccode(I3)\r结果\nans =' t0 = exp(t*(-4.0/5.0))*sin(t*3.141592653589793)*5.0;'\rI3code =\r' I3[0][0] = 1.0;\rI3[1][1] = 1.0;\rI3[2][2] = 1.0;'\r","id":27,"section":"categories","summary":"matlab\u0026ndash;符号表达式转LaTeX、C、mathml代码 网址\u0026ndash;Code Generation - MATLAB \u0026amp; Simulink - MathWorks 中国 latex syms f(t); y=f==5*exp(-0.8*t)*sin(pi*t); latex(y) ans= \u0026lsquo;f\\left(t\\right)=5,{\\mathrm{e}}^{-\\frac{4,t}{5}},\\sin\\left(\\pi ,t\\right)\u0026rsquo; Mathml syms f(t); y=f==5*exp(-0.8*t)*sin(pi*t); mathml(y)","tags":[" matlab"],"title":"matlab--符号表达式转LaTeX、C、mathml代码","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/matlab/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/","year":"2022"},{"content":"Matlab中一些画图方式 符号表达式-画图 fimplicit 隐函数 fimplicit3 Plot 3-D implicit equation or function fmesh Plot 3-D mesh fplot 一般式、参数方程 fplot3 Plot 3-D parametric curve fsurf Plot 3-D surface ezpolar 极坐标 fcontour 3维，等高线 例子\nfigure(1);\rsyms f(t);\rf=5*exp(-0.8*t)*sin(pi*t);\rfplot(f,[0,5]);\r符号表达式-动画 fanimator Create stop-motion animation object(创造动画对象) playAnimation Play animation objects in a MATLAB figure window(播放) rewindAnimation Rewind previously played animation objects（回放） writeAnimation Save animation as video file(保存) animationToFrame Return structure of frames from animation objects（用一个数组存储每一帧） 例子\nsyms y(x) t;\rfigure(1);\ry=sin(x);\rfanimator(@fplot,x,y,[0 t],\u0026quot;FrameRate\u0026quot;,2)%帧率为2\raxis equal %xy轴相等\rplayAnimation(figure(4),'AnimationRange',[0 15]);%t的取值范围定为[0 15]\rwriteAnimation('wheel.gif')%保存为GIF\r","id":28,"section":"categories","summary":"Matlab中一些画图方式 符号表达式-画图 fimplicit 隐函数 fimplicit3 Plot 3-D implicit equation or function fmesh Plot 3-D mesh fplot 一般式、参数方程 fplot3 Plot 3-D parametric curve fsurf Plot 3-D surface ezpolar 极坐标 fcontour 3维，等高线 例子 figure(1); syms f(t);","tags":[" matlab"],"title":"matlab-画图","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/matlab/%E7%94%BB%E5%9B%BE/","year":"2022"},{"content":"周期信号的傅里叶级数表示 知识回顾 欧拉公式 复分析的欧拉公式特例\n假设$z=r(cos(\\theta )+ isin(\\theta))$\n复数的乘除公式 $$Z_{1}Z_{2}=(r_{1}r_{2})(cos(ArgZ_{1}+Arg Z_{2})+isin(ArgZ_{1}+ArgZ_{2}))$$\n$$\\frac{Z_{1}}{Z_{2}}=(\\frac{r_{1}}{r_{2}} )(cos(ArgZ_{1}-Arg Z_{2})+isin(ArgZ_{1}-ArgZ_{2}))$$\n复数的乘幂公式 ","id":29,"section":"categories","summary":"周期信号的傅里叶级数表示 知识回顾 欧拉公式 复分析的欧拉公式特例 假设$z=r(cos(\\theta )+ isin(\\theta))$ 复数的乘除公式 $$Z_{1}Z_{2}=(r_{1}r_{2})(cos(ArgZ_{1}+Arg Z_{2})+isin(ArgZ_{1}+ArgZ_{2}))$$ $$\\frac{Z_{1}}{Z_{2}}=(\\frac{r_{1}}{r_{2}} )(cos(ArgZ_{1}-Arg Z_{2})+isin(ArgZ_{1}-ArgZ_{2}))$$ 复数的乘幂公式","tags":[],"title":"《信号与系统》读书笔记2","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/signalsandsystems/bookmark2/","year":"2022"},{"content":"LTS 卷积的概念 连续系统:\n$$(f * g)(n)=\\int_{-\\infty}^{\\infty} f(\\tau) g(n-\\tau) d \\tau$$\n离散系统:\n$$(f * g)(n)=\\sum_{\\tau=-\\infty}^{\\infty} f(\\tau) g(n-\\tau)$$\n卷积这个名词的理解：**所谓两个函数的卷积，本质上就是先将一个函数翻转，然后进行滑动叠加。**在连续情况下，叠加指的是对两个函数的乘积求积分。在离散情况下就是加权求和，为简单起见就统一称为叠加。\n离散时间线性时不变(LTS)系统：卷积和 $x[n]=\\sum_{k=-\\infty}^{+\\infty}x[k]\\delta [n-k]$\u0026mdash;\u0026mdash;$x[k]$是线性组合式中的权因子 $y[n]=\\sum_{k=-\\infty}^{+\\infty}x[k]h_{k} [n]$，令$h_{k}[n]$(即$h_{0}[n-k]$)为线性系统对移动单位脉冲$\\delta[n-k]$的响应 LTS系统的单位脉冲响应可以完全刻画系统的特征。 ","id":30,"section":"categories","summary":"LTS 卷积的概念 连续系统: $$(f * g)(n)=\\int_{-\\infty}^{\\infty} f(\\tau) g(n-\\tau) d \\tau$$ 离散系统: $$(f * g)(n)=\\sum_{\\tau=-\\infty}^{\\infty} f(\\tau) g(n-\\tau)$$ 卷积这个名词的理解：**所谓两个函数的卷积，本质上就是先将一个函数翻转，然后进行滑动","tags":[],"title":"《信号与系统》读书笔记1--LTS","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/signalsandsystems/bookmark1/","year":"2022"},{"content":"command 1. 常用命令 1.1 新建文档 math类\rhugo new categories/math/\r--\u0026gt; hugo new categories/math/signalsAndSystems/\rapp类\rhugo new categories/app/\ros类\rhugo new categories/os/\rrobat类\rhugo new categories/robat/\rlang类\rhugo new categories/lang/\rother类\rhugo new categories/other/\r1.2 上传命令 CMD hugo -D \u0026amp;\u0026amp; git add .\u0026amp;\u0026amp;git commit -m \u0026quot;\u0026quot;\rgit push \u0026amp;\u0026amp; tcb hosting deploy ./public -e blog-0g8860131649bb29\rpowershell hugo -D | git add .|git commit -m \u0026quot;\u0026quot;\rgit push | tcb hosting deploy ./public -e blog-0g8860131649bb29\r1.3 markdown技巧 打开调试，获取bilibili的aid console.log(playerInfo.aid)\rnote：去除'\\'\r{\\{\u0026lt; bilibili aid \u0026gt;}\\}\r跳转 []({\\{\u0026lt; ref \u0026quot;blog/neat.md\u0026quot; \u0026gt;}\\})\r2. 腾讯云部署 静态网站托管 部署 Hugo - 最佳实践 - 文档中心 - 腾讯云 (tencent.com)\n3.hugo hugo-theme-pure/README-ZH.md at master · xiaoheiAh/hugo-theme-pure (github.com)\nnote: 注意submoudel\n","id":31,"section":"categories","summary":"command 1. 常用命令 1.1 新建文档 math类 hugo new categories/math/ --\u0026gt; hugo new categories/math/signalsAndSystems/ app类 hugo new categories/app/ os类 hugo new categories/os/ robat类 hugo new categories/robat/ lang类 hugo new categories/lang/ other类 hugo new categories/other/ 1.2 上传命令 CMD hugo -D","tags":["blog","command"],"title":"一些部署博客blog的常用指令","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/other/blog/command/","year":"2022"},{"content":"希腊字母 ","id":32,"section":"categories","summary":"希腊字母","tags":[" math"],"title":"希腊字母","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/other/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D/","year":"2022"},{"content":"win10安装clash 1.下载 clash for win软件是一个开源项目，被开源在github上，它是具有windows,mac,linux(x86和arm)多版本的gui软件。\n点击跳转：开源地址\n由于github的网站位于国外，可能打不开，下载地址如下：\n点击下载:clash下载地址\n2.安装 解压软件包\n软件包是安装的，可以直接运行\n3.汉化 由于软件是国外开发的，所以gui界面文字是英语，我们需要将它汉化。\n汉化教程在github上开源的 点击跳转：开源地址 点击下载：汉化包下载地址 - 解压汉化包，得到一个app.asar文件，用汉化包中的app.asar替换resources/app.asar 启动clash\r4.节点导入 导入yaml配置文件\n4.1 在线转换 v2ray转换到clash,将vmess协议转换为yaml配置文件在线小工具 点击跳转\n由于是纯前端的转换工具，所以加载可能有点慢，耐心等待一下 转换完成后，下载yaml文件，然后见上图，导入yaml文件 4.2 自己配置yaml文件模板 ​\tClash支持SS、V2ray和trojan协议\n深入理解Clash配置文件 - VPS攻略 (vpsgongyi.com)\n开启系统代理\n检测网络是否通\n大功告成！！！\n","id":33,"section":"categories","summary":"win10安装clash 1.下载 clash for win软件是一个开源项目，被开源在github上，它是具有windows,mac,linux(x86和a","tags":["net"],"title":"clash：一款代理科学上网的软件","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/clash/","year":"2022"},{"content":"概率论与数理统计 古典概型 试验中所有可能出现的基本事件只有有限个 试验中每个基本事件出现的可能性相等。 具有以上两个特点的概率模型是大量存在的，这种概率模型称为古典概率模型，简称古典概型，也叫等可能概型\n几何概型： 无限性：试验中所有可能出现的基本事件（结果）有无限多个. 等可能性：每个基本事件出现的可能性相等. 如果每个事件发生的概率只与构成该事件区域的长度(面积或体积或度数)成比例，则称这样的概率模型为几何概率模型，简称为几何概型。古典概型与几何概型的主要区别在于：几何概型是另一类等可能概型，它与古典概型的区别在于试验的结果是无限个。\n全概率公式 意义：全概率公式为概率论中的重要公式，它将对一复杂事件A的概率求解问题转化为了在不同情况下发生的简单事件的概率的求和问题。\n内容：如果事件B1、B2、B3…Bi构成一个完备事件组，即它们两两互不相容，其和为全集；并且P（Bi)大于0，则对任一事件A有\nP(A)=P(A|B1)P(B1) + P(A|B2)P(B2) + ... + P(A|Bi)P(Bi)\r\u0026emsp;\u0026emsp;概率论的一个重要内容是研究怎样从一些较简单事件概率的计算来推算较复杂事件的概率，全概率公式和Bayes公式正好起到了这样的作用。\r贝叶斯公式 $$ P(A|B)=\\frac{P(B|A)P(A)}{P(B)} $$ 贝叶斯公式用来描述两个条件概率之间的关系。即通常，事件A在事件B(发生)的条件下的概率，与事件B在事件A的条件下的概率是不一样的；然而，这两者是有确定的关系,贝叶斯法则就是这种关系的陈述。\n在贝叶斯法则中，每个名词都有约定俗成的名称：\nP(A)是A的先验概率或边缘概率。之所以称为\u0026quot;先验\u0026quot;是因为它不考虑任何B方面的因素。 P(A|B)是已知B发生后A的条件概率，也由于得自B的取值而被称作A的后验概率。 P(B|A)是已知A发生后B的条件概率，也由于得自A的取值而被称作B的后验概率。 P(B)是B的先验概率或边缘概率，也作标准化常量（normalized constant）。 按这些术语，Bayes法则可表述为：\n后验概率 = (似然度 * 先验概率)/标准化常量\n也就是说，后验概率与先验概率和似然度的乘积成正比。\n另外，比例Pr(B|A)/Pr(B)也有时被称作标准似然度（standardised likelihood），Bayes法则可表述为： 后验概率 = 标准似然度 * 先验概率。 [1]\n1.可测空间\n2.常用的一维分布\n链接\n","id":34,"section":"categories","summary":"概率论与数理统计 古典概型 试验中所有可能出现的基本事件只有有限个 试验中每个基本事件出现的可能性相等。 具有以上两个特点的概率模型是大量存在的，这","tags":["概率论"],"title":"概率论学习之旅1","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/probability/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%851/","year":"2022"},{"content":"ROS的使用 一、安装ros 脚本安装 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; sudo bash fishros\r原文章链接：鱼香ros\nrosdep 安装 note: 注意安装ros过程中，可以不安装rosdep，它不是ros系统必须安装的，它的功能类似于ubuntu中的apt\n，当我们安装ros的一些功能包的时候，也可以用apt安装，可以不用rosdep\n参考视频：小鱼在古月居开课视频\u0026ndash;聊聊ROS安装过程中的那些坑\n二、ros的常用命令 创建ros工作空间 mkdir -p ~/catkin_ws/src\rcd ~/catkin_ws\rcatkin_make\rsource devel/setup.bash\recho $ROS_PACKAGE_PATH\recho \u0026quot;source /home/chao/Desktop/code/02c/ros1/src/devel/setup.bash\u0026quot; \u0026gt;\u0026gt; ~/.bashrc 创建ros程序包 cd ~/catkin_ws/src\rcatkin_create_pkg beginner_tutorials std_msgs rospy roscpp\rros参数命令 rosparam set [param_name] 设置参数\rrosparam get [param_name] 获取参数\rrosparam load params.yaml 从文件中加载参数\rrosparam dump params.yaml 向文件中转储参数\rrosparam delete [param_name] 删除参数\rrosparam list 列出参数名\r三、ros的使用教程 1. 发布者与订阅者 2.服务器 3.tf函数的使用 安装 sudo apt install ros-melodic-turtle-tf\r可视化观测tf tree #pdf\rrosrun tf view_frames\r#stdout\rrosrun tf tf_echo node1 nodde2\r常用的tf坐标系 laser_link：激光雷达\rbase_link：车体\rodom:里程计坐标系\rmap：单个机器人全局坐标系\rearth：多个机器人协作\rros坐标转换的类 rosmsg info geometry_msgs/TransformStamped\rgeometry_msgs头文件内容 Accel.h AccelStamped.h AccelWithCovariance.h AccelWithCovarianceStamped.h Inertia.h\rInertiaStamped.h\rPoint32.h\rPoint.h\rPointStamped.h\rPolygon.h\rPolygonStamped.h\rPose2D.h\rPoseArray.h\rPose.h\rPoseStamped.h\rPoseWithCovariance.h\rPoseWithCovarianceStamped.h\rQuaternion.h QuaternionStamped.h Transform.h TransformStamped.h Twist.h TwistStamped.h TwistWithCovariance.h\rTwistWithCovarianceStamped.h Vector3.h\rVector3Stamped.h\rWrench.h\rWrenchStamped.h\r1. geometry_msgs::TransformStamped 坐标系之间的关联信息\nstd_msgs/Header header\ruint32 seq\rtime stamp\rstring frame_id\rstring child_frame_id\rgeometry_msgs/Transform transform\rgeometry_msgs/Vector3 translation\rfloat64 x\rfloat64 y\rfloat64 z\rgeometry_msgs/Quaternion rotation\rfloat64 x\rfloat64 y\rfloat64 z\rfloat64 w\r2.geometry_msgs/PointStamped 坐标点信息\nstd_msgs/Header header\ruint32 seq\rtime stamp\rstring frame_id\rgeometry_msgs/Point point\rfloat64 x\rfloat64 y\rfloat64 z\r四、launch文件的使用 \u0026lt;?xml version=\u0026quot;1.0\u0026quot;?\u0026gt;\r\u0026lt;launch\u0026gt;\r\u0026lt;include file=\u0026quot;$(find pepperl_fuchs_r2000)/launch/r2000.launch\u0026quot;/\u0026gt;\r\u0026lt;!--pkg:功能包名称(文件夹) type：节点的可执行文件名称。name：运行节点名（优先级高于ros::init()中的参数） --\u0026gt;\r\u0026lt;node pkg=\u0026quot;\u0026quot; type=\u0026quot;\u0026quot; name=\u0026quot;\u0026quot; output=\u0026quot;screen\u0026quot;\u0026gt;\u0026lt;/node\u0026gt;\r\u0026lt;/launch\u0026gt;\r五、VScode的配置 头文件智能提示 进入c/c++插件 配置头文件路径\nros中文乱码问题 setlocale(LC_ALL,\u0026quot;\u0026quot;);\rc_cpp_properties.json {\r\u0026quot;configurations\u0026quot;: [\r{\r\u0026quot;name\u0026quot;: \u0026quot;linux\u0026quot;,\r\u0026quot;includePath\u0026quot;: [\r\u0026quot;/opt/ros/melodic/include\u0026quot;,\r\u0026quot;/usr/include\u0026quot;,\r\u0026quot;${workspaceFolder}/**\u0026quot;,\r\u0026quot;${workspaceFolder}/devel/include\u0026quot;\r],\r\u0026quot;intelliSenseMode\u0026quot;: \u0026quot;linux-gcc-x64\u0026quot;,\r\u0026quot;compilerPath\u0026quot;: \u0026quot;/usr/bin/gcc\u0026quot;,\r\u0026quot;cppStandard\u0026quot;: \u0026quot;c++17\u0026quot;,\r\u0026quot;cStandard\u0026quot;: \u0026quot;c17\u0026quot;\r}\r],\r\u0026quot;version\u0026quot;: 4\r}\r","id":35,"section":"categories","summary":"ROS的使用 一、安装ros 脚本安装 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; sudo bash fishros 原文章链接：鱼香ros rosdep 安装 note: 注意安装ros过程中，可以不安装rosdep，它不是ros系","tags":["ros"],"title":"ROS的使用","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robot/ros%E7%9A%84%E4%BD%BF%E7%94%A8/","year":"2022"},{"content":"网络配置 ubuntu18.04配置IP 使用ip addr 只限于以太网配置(临时)\rip addr add 192.168.8.30/24 dev eth0\r/etc/netplan/*配置文件 服务器中是50-cloud-init.yaml,桌面版01-network-manager-all.yaml\n信息格式如下：\nnetwork:\rethernets:\reth0:\rdhcp4: no\raddresses: [192.168.30.201/24]\roptional: true\reth1:\rdhcp4: no\raddresses: [192.168.30.202/24]\roptional: true\rversion: 2\rwifis:\rwlan0:\raccess-points:\rchao:\rpassword: '88888888'\rdhcp4: true\roptional: true\r","id":36,"section":"categories","summary":"网络配置 ubuntu18.04配置IP 使用ip addr 只限于以太网配置(临时) ip addr add 192.168.8.30/24 dev eth0 /etc/netplan/*配置文件 服务器中是50-cl","tags":["linux","net"],"title":"eth wifi 网络配置","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/linux/etc/eth_wifi%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","year":"2022"},{"content":"slam资料汇集 ros学习网站收集 Ros官网 wiki.ros.org 中国大学MOOC\u0026mdash;《机器人操作系统入门》课程讲义 中国大学MOOC\u0026mdash;《智能机器人系统》 创客智造 zhangrelay的专栏 古月居 易科机器人实验室 ROBOTIS 知乎\u0026ndash;SLAM开发最强最全资源汇总 2D激光slam发展历史 书籍 机器人导论\n现代机器人学\n概率机器人\n机器人学中的状态估计\n视觉slam十四讲\n机器人感知：因子图在slam中的应用\n卡尔曼滤波及其实时应用\n","id":37,"section":"categories","summary":"slam资料汇集 ros学习网站收集 Ros官网 wiki.ros.org 中国大学MOOC\u0026mdash;《机器人操作系统入门》课程讲义 中国大学MOOC\u0026mdash;《智","tags":["slam"],"title":"slam的相关资料：一","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robot/slam%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/","year":"2022"},{"content":"如何在wsl1中使用网络代理？ 代理工具 polipo proxychain\n前提条件 v2ray中开启允许局域网连接\n记住以下ip:port\n开始代理 polipo 参考博客：为 windows wsl 配置 socks5 代理 (github.com)\n步骤总结：\n下载\rsudo apt install polipo\r打开配置文件\rsudo nano /etc/polipo/config\r写入\rsocksParentProxy = \u0026quot;localhost:10808\u0026quot;\rsocksProxyType = socks5\rproxyPort = 8123\r环境设置\rnano ~/.bashrc\r写入\rexport https_proxy=http://127.0.0.1:8123\rexport http_proxy=http://127.0.0.1:8123 export all_proxy=socks5://127.0.0.1:8123\r启动\rsudo service polipo stop sudo service polipo start 测试\rcurl www.google.com\rproxychain 参考博客：linux下的全局代理工具proxychain | MonkeyWie\u0026rsquo;s Blog\n","id":38,"section":"categories","summary":"如何在wsl1中使用网络代理？ 代理工具 polipo proxychain 前提条件 v2ray中开启允许局域网连接 记住以下ip:port 开始代理 polipo 参考博客：为 windows wsl 配置 socks5 代理 (github.com)","tags":[" wsl1"],"title":"wsl1：使用网络代理？","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/test-post/","year":"2022"},{"content":"继承与面向对象设计 条款32：确定你的public继承塑模出“is-a”（是一种）关系 结论 “public继承关系”意味is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，每一个derived classes对象也是一个base class对象\n存在于classes之间的三种关系： is-a （是一个）A是B has-a（有一个，条款38）A有B is-implemented-in-term-of(根据某物实现出，条款39) 条款33：避免遮掩继承而来的名称 结论 derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。 为了让被遮掩的名称再见天日，可以使用using声明式或转交函数。 条款34：区分接口继承和实现继承 结论 接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口。\npure vitrual（纯虚函数）只具体指定接口继承。\nimpure vitrual(非纯函数)具体指定指定接口继承和缺省实现继承（可以覆写）。\nnon-virtual（成员函数）具体指定接口继承以及强制性实现继承。\n条款35：考虑virtual函数以外的其他选择 结论 virtual函数的替代方案包括NVI手法及Strategy（策略）设计模式的多种形式。NVI手法自身是一种特殊形式的Template Method设计模式。 将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。 trl::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物 条款36：绝不重新定义继承而来的non-virtual函数 原因 违反\u0026quot;is-a\u0026quot;的继承体系\n条款37： 绝不重新定义继承而来的缺省参数值 结论 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数\u0026mdash;你唯一应该覆写的东西\u0026mdash;-却是动态绑定。\n原因 你只能继承两种函数：virtual 和 non-virtual函数。然而重新定义一个继承而来的non-virtual函数永远是错误（条款36）\nvirtual函数系动态绑定，而缺省参数值却是静态绑定。\n条款38：通过复合塑模出“has-a”或“根据某物实现出” 结论 复合关系的意义和public继承关系完全不同 在应用域，在复合意味has-a（有一个）。在实现域，复合意味is-implemented-in-terms-of(根据某物实现出)。 内容 继承关系 复合关系\n在程序员之间，复合这个词有很多同义词，譬如分层、内含、聚合、内嵌。\n应用域 相当于塑造的世界中的某些事物，例如人、汽车\n实现域 实现细节上的人工制品，例如缓冲区、互斥器、查找树\n条款39：明智而审慎地使用private继承 结论 private继承关系意味着is-implemented-in-terms-of(根据某物实现出)。它通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。 和复合不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。 原因 C++将public继承视为is-a关系\n​\t将private继承视为is-implemented-in-terms-of(根据某物实现出)\n注意：private继承纯粹只是一种实现技术（private base class的每样东西在你的class内都是private） 如非必要（必要条件，见P188），在复合与private继承中，尽量选择复合。\n条款40：明智而审慎地使用多重继承 结论 多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。 virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes不会带任何数据，将是最具实用价值的情况。 多重继承的确有正当用途。其中一个情景涉及“public继承某个interface class”和“private继承某个协助实现的class”两相组合。 ","id":39,"section":"categories","summary":"继承与面向对象设计 条款32：确定你的public继承塑模出“is-a”（是一种）关系 结论 “public继承关系”意味is-a。适用于base","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记5","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/5/","year":"2021"},{"content":"实现 大多情况下，适当提出你的class（和class templates）定义以及functions(和 function templates)声明，是花费最多心力的两件事。\n实现大多直截了当，但实现仍然有一些东西要小心。\n条款26：尽可能延后变量定义式的出现时间 结论 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序的效率。\n原因 只要你定义了一个变量而其类型带有一个构造函数或析构函数，\n那么当程序的控制流到达这个变量定义式时，你便得承受构造成本；\n当这个变量离开其作用域时，你便要承受析构成本。\n即使这个变量最终并未被使用，仍需消耗这些成本。\nstd::string encrytPassword(const std::string\u0026amp;　password)\r{\rusing namespace std;\rstring encrypted;\rif(password.length()\u0026lt;MinimumPasswordLength){\rthrow logic_error(\u0026quot;Password is too short\u0026quot;);\r}\r...\t//必要动作，将一个加密后的密码置入变量encrypted内\rreturn encrypted;\r}\r如果密码长度不够，丢出异常，那么string encrypted被构造了，也被析构了，但没有被使用。\nP116重要，关于循环体内的定义 条款27：尽量少做转型动作 结论 如果可以，尽量避免转型，特别是注重效率的代码中避免dynamic_casts。如果有个设计需要转型设计，试着发展无需转型的替代设计 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要转型放进它们自己的代码内。 宁可使用C++style（新式）转型，不要使用旧式转型。 条款28：避免返回handles指向对象内部成分（即它的成员变量） 结论 避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条约可增加封装性，帮助cosnt成员函数的行为更像const，并将发生内存对象被销毁的可能性降到最低。\n原因 假设你的程序涉及矩形，每一个矩形由其左上角和右下角表示。\nclass Point{\t//这个class用来表述“点”\rpublic：\rpoint（int x,int y）;\r...\rvoid setX（int newVal）;\rvoid setY(int newval);\r...\r}\rstruct RectData{\t//这些点数据用来表现一个矩形\rPoint ulhc;\t//ulhc=\u0026quot;右下角\u0026quot;\rPoint lrhc;//lrhc=\u0026quot;右上角\u0026quot;\r};\rclass Rectangle{\r....\rprivate:\rstd::trl::shared_ptr\u0026lt;RectData\u0026gt; pData;\r};\rby reference 方式传递用户自定义类型往往比by value方式更高效\nclass Rectangle{\rpublic：\r....\rPoint\u0026amp; upperLeft() const { return pData-\u0026gt;ulhc;}\rPoint\u0026amp; upperRight() const { return pData-\u0026gt;lrhc;}\r}\rconst成员函数：若将成员成员函数声明为const，则该函数不允许修改类的数据成员，但若数据成员是指针，则还是可以修改指针指向的内容\nupperLeft和upperRight被声明为const成员函数，是为了提供客户一个得知Rectangle相关坐标点的方法，而不是让客户修改Rectangle（客户是可以通过by reference修改内部数据）。\n解决方法 它们的返回类型加上const\nclass Rectangle\r{\rpublic：\r...\rconst Point\u0026amp; upperLeft() const{ return pData-\u0026gt;ulhc;}\rconst Point\u0026amp; lowerRight() const {return pData-\u0026gt;lrhc;}\r...\r}\r条款29：为“异常安全”而努力是值得的 结论 异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型 “强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。 \u0026ldquo;COPY-AND-SWAP\u0026quot;技术 按照C++ primer的理解，赋值运算符（A=B）应该实现两个方面的工作：\n1.析构函数（删除A原有的内容）\n2.拷贝构造函数（将B的值赋值给A）\nClassA\u0026amp; ClassA::operator= (\u0026hellip;.): 首先把\u0026rdquo;=\u0026ldquo;右边的值复制到\u0026rdquo;=\u0026ldquo;左边, 然后析构\u0026rdquo;=\u0026ldquo;左边的值;\n为了保证可以自赋值(self-assignment), 需要使用****临时变量****存储, 再删除对象;\nclass A {\rprivate:\rint *b;\rint a;\rpublic:\rA():a(0),b(nullptr){};\rA(const A\u0026amp;rhs):a(rhs.a),b(rhs.b==nullptr?nullptr:new int(*rhs.b)){};\r~A(){\rdelete b;\rb = nullptr;\r};\r};\rA\u0026amp; operator=(const A\u0026amp; rhs) {\rif(this!=\u0026amp;rhs) { // 防止自赋值\rdelete b;\rthis-\u0026gt;b = new int(*rhs.b);// 可能失败\rthis-\u0026gt;a = rhs.a;\r}\rreturn *this; // 返回this对象的引用\r}\r可以看到我们的代码几乎是对拷贝构造函数和析构函数的完全复制，此外，上述代码虽然完成了自赋值的验证，但并未保障异常安全。一旦new失败，原this对象的b已经被删除，因此会引发异常。\n异常不安全主要在于，b对应的对象可能在异常到来之前被删除。因此我们首先保存该对象的副本，从而保证了异常安全特性，无论new是否成功，this对象中的b指针都会指向已知对象 A\u0026amp; operator=(const A\u0026amp; rhs) {\rauto orign = this-\u0026gt;b;\t//使b指针所指向的内存有orgin指针指向\rthis-\u0026gt;b = new int(*rhs.b);\rdelete orign;\rthis-\u0026gt;a = rhs.a;\rreturn *this;\r}\rcopy and swap 为了使用copy-swap，我们需要三件事：\n一个有效的拷贝构造函数 一个有效的析构函数 一个自定义的交换函数，不能用std::swap,因为该函数实现中调用了拷贝构造和复制函数，且交换函数不抛异常 该技术的核心就是不再使用引用作为赋值运算符参数，形参将直接是对象，这样的写法将会使编译器自动调用拷贝构造函数，由于拷贝构造函数的调用，异常安全将在进入函数体之前被避免（若拷贝失败则什么都不会发生）。经过swap后的对象在离开函数体后会自动销毁，因此也就自动调用了析构函数，具体写法如下： ———————————————— 版权声明：本文为CSDN博主「feifeiiong」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/feifeiiong/article/details/77866579\nvoid swap(A\u0026amp; rhs) {\rusing std::swap;\rswap(this-\u0026gt;a,rhs.a);\rswap(this-\u0026gt;b,rhs.b);\r}\rA\u0026amp; operator=(A rhs) {\rswap(rhs);\rreturn *this;\r}\r网络资源：\nhttps://blog.csdn.net/hiwubihe/article/details/116667884?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162631218716780264010481%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D\u0026amp;request_id=162631218716780264010481\u0026amp;biz_id=0\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-10-116667884.first_rank_v2_pc_rank_v29\u0026amp;utm_term=copy+and+swap\u0026amp;spm=1018.2226.3001.4187 条款30：透彻了解inlining的里里外外 结论 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更为容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。 不要只因为function templates出现在头文件，就将它们声明为inline。 原因 一开始先不要将任何函数声明为inline，或者至少将inline施行范围局限在那些“一定成为inline（条款46）”或“十分平淡无奇”的函数身上，可以使程序达到优化。\n（28法则）平均而言一个程序往往将80%的执行时间花费在20%的代码上头，作为软件开发者，我们的目标是找出这可以有效增进程序整体效率的20%的代码\ninline缺点：\n以代码膨胀为代价 空间换时间\ninline对于编译器而言，只是建议。\n建议：\n开栈的开销 \u0026gt; 执行的开销 建议设为inline 开栈的开销 \u0026lt; 执行的开销 不建议 为什么使用inline关键字？ 1.1为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）。 在预编译的时候，编译器将程序中出现的内联函数的调用表达式的地方直接插入用内联函数的代码。\n条款31：将文件间的编译依存关系降到最低 结论 支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和interface classes 程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及templates都适合。 方法 pimpl idiom技术\nhttps://blog.csdn.net/qq_33775402/article/details/76274678?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162632039416780261938712%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D\u0026amp;request_id=162632039416780261938712\u0026amp;biz_id=0\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-4-76274678.first_rank_v2_pc_rank_v29\u0026amp;utm_term=%E9%99%8D%E4%BD%8E%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB\u0026amp;spm=1018.2226.3001.4187\n","id":40,"section":"categories","summary":"实现 大多情况下，适当提出你的class（和class templates）定义以及functions(和 function templates)声明，是花费最多","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记4","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/4/","year":"2021"},{"content":"资源管理 资源：一旦用了它，将来必须还给系统。\n譬如：动态分配内存、文件描述器、互斥锁、图形界面中的字型和笔刷、数据库连接、网络sockets。\n条款13：以对象管理资源 创建一个对象管理资源，资源管理类\n结论 ​\t1.为防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。\n​\t2.两个常被使用的RAII classes分别trl::share_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为直观。\n条款14：在资源管理中，小心copying行为 copying行为也应该参考\n浅拷贝\u0026amp;\u0026amp;深拷贝\n结论 1.复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。\n2.普遍而常见的RAII class copying行为是：禁止copying、施行引用计数法。\n原因 资源管理类对象被复制，是一件不合理的行为，因为例如“互斥锁”、“动态内存分配”、等是具有唯一性的，两个对象的指针同时指向同一块内存，那么对象销毁时，内存释放，就必然一个指针称为悬空指针。\n解决方法 因此：有两种做法：\n禁止复制\u0026mdash;\u0026mdash;\u0026ndash;详细地见，条款6，将copying操作声明为private。\n对底层资源祭出“引用计数法”。\n有时候我们希望保存资源，直到它最后一个使用者（某对象）被销毁。\nclass Lock{\rpublic：\rexplict Lock（Mutex* pm）:mutexPtr(pm,unlock)//以某个Mutex初始化share_ptr,并以unlock函数为删除器\r{\rlock（mutePtr.get()）;//条款15\r}\rprivate：\rstd::trl::shared_ptr\u0026lt;Mutex\u0026gt; mutexPtr;//使用share_ptr\r}\rshared_ptr(智能指针)的妙用。\n本例的Lock Class不再声明析构函数，因为没用必要。\nmutex的析构函数会在互斥器的引用次数为0时自动调用trl：share_ptr的删除器（本例为unlock）。\n条款15：在资源管理类中提供对原始资源的访问 结论： APIs往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理之资源”的方法。 对原始资源的访问可能经由显式转换或隐式转换。一般而言，显式转换比较安全，但隐式转换对客户比较方便。 做法 trl::share_ptr和auto_ptr都提供一个get成员函数，用来执行显式转换，也就是它会返回智能指针内部的原始指针（的复件）\n条款16：成对使用new和delete时要采取相同形式 结论 如果你在new表达式中使用[],必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[],一定不要在相应的delete表达式中使用[]\n条款17：以独立语句将newed对象置入智能指针 结论 以独立语句将newed对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。\n原因 假设我们有个函数用来揭示处理程序的优先权，另一个函数用来在某动态分配所得的widget上进行某些带有优先权的处理：\nint priority();\rvoid processWidget(std::trl::shared_ptr\u0026lt;Widget\u0026gt; pw, int priority);\r调用processWidget\nprocessWidget(new Widget, priority());\r不能通过编译，因为trl::share_ptr构造函数需要一个原始指针，但该构造函数是个explicit构造函数，无法进行隐式转换，需要将“new Widget”的原始指针转换为processWidget所要求的Trl：share_ptr。\n但\n这样，就可以通过编译。\nprocessWidget(std::trl::share_ptr\u0026lt;Widget\u0026gt;(new Widget), priority());\r强制转换\n缺陷是：可能泄漏资源\n假设执行顺序：\n执行“new Widget” 调用priority 调用trl::shared_ptr构造函数 对priority的调用可以排在第一、第二、第三执行，不一定，不可知。\n如果在第二位执行，如果对priority的调用导致异常呢？那么“new Widget”返回的指针将会遗失，因第三步执行不了，而第三步则是我们期盼用来防卫资源泄漏的武器，RAII。\n解决方法 使用分离语句\n（1）创建widget\n（2）将它置入一个智能指针，然后再把那个智能指针传给processWidget\nstd::trl::shared_ptr\u0026lt;Widget\u0026gt; pw(new Widget);//在单独语句内以智能指针存储newed所得的对象。\rprocessWidget(pw,priority());//不会造成内存泄漏\r","id":41,"section":"categories","summary":"资源管理 资源：一旦用了它，将来必须还给系统。 譬如：动态分配内存、文件描述器、互斥锁、图形界面中的字型和笔刷、数据库连接、网络sockets。","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记2","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/2/","year":"2021"},{"content":"接口的设计与声明 接口设计的准则： 让接口容易被正确使用，不容易被误用。\n什么是接口？\n​\t内部实现细节封装起来，外部用户用过预留的接口可以使用接口的功能而不需要知晓内部具体细节。\n​\tC++中，通过类实现面向对象的编程，而在基类中只给出纯虚函数的声明，然后在派生类中实现纯虚函数的具体定义的方式实现接口，不同派生类实现接口的方式也不尽相同，从而实现多态。\n条款18：\t让接口容易被正确使用，不容易被误用。 ### 结论\r好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。 “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。 “阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。 trl::shared_ptr支持定制删除器。这可防范DLL问题，可被用来自动解除互斥锁（条款14）。 原因 首先必须考虑客户可能做出什么错误。\nclass Date{\rpublic：\rDate（int month，int day，int year）;\r.....\r}\r如果年月日的顺序错误呢？\n例如\nDate d（30,3,1995）错误\n亦或者按错\nDate d（2,30,1995）\n解决方法 导入简单的外覆类型来区别天数、月份、年份，然后于Date构造函数中使用这些类型：\nstruct Day\r{\rexplicit Day(int d):val(d){}\rint val;\r};\rstruct Month\r{\rexplicit Month(int m):val(m){}\rint val;\r};\rstruct Year\r{\rexplicit Year(int y):val(y){}\rint val;\r};\rclass Date{\rPublic:\rDate（const Month\u0026amp; m,const Day\u0026amp; d,const Year\u0026amp; y）;//包装了一下\r...\r}\rDate d（30,3,1995）;\t//错误！\rDate d（Day（30），Month（3），Year（1995））；//错误\rDate d(Month(3),Day(30),Year(1995))//OK,类型正确\r条款19：设计class犹如type 结论 class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款覆盖的所有讨论主题。\n如何设计高效的class呢？ 新type的对象应该如何被创建和销毁？\n对象的初始化和对象的赋值该有什么样的差别？\n新type的对象如果被passed by value(以值传递)，意味着什么？\n条款20：宁以pass-by-reference-to-const替换pass-by-value 结论 尽量以Pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题。 以上规则并不适用内置类型、STL的迭代器和函数对象。对它们而言，pass-by-value往往比较合适。 条款21：必须返回对象时，别妄想返回其reference 条款22：将成员变量声明为private 从封装角度来看：其实只有两种访问权限：private（提供封装）和其他（不提供封装，即public、protected）\n条款23：宁以non-member、non-friend替换member函数 结论 宁以non-member、non-friend替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性\n原因 一个例子\n想象有一个class用来表示网页浏览器。class可能提供的许多函数中，有一些用来清除下载元素高速缓存区、清除访问过的URLs的历史记录、以及移除系统中的所有cookies：\nclass WebBrowser{\rpublic：\r...\rvoid clearCache(); //清除高速缓存\rvoid clearHistory();//清除历史记录\rvoid removeCookies();//清除cookies\r...\r}\r许多用户想一个函数执行所有动作，因此webBrowser也提供这样一个函数：\n方法一：\rclass WebBrowser\r{\rpublic:\r...\rvoid clearEverything();//调用clearCache（），clearHistory（）和removeCookies（）\r}\r方法一的行为可以由non-member函数调用适用的member函数而提供出来（方法二）：\r方法二：\rvoid clearBrowser（WebBrowser\u0026amp; wb）\r{\rwb.clearCache(); //清除高速缓存\rwb.clearHistory();//清除历史记录\rwb.removeCookies();//清除cookies\r}\r方法一与方法二，哪一个更好一些呢？\n从封装性考虑，为保护数据的封装性（private），应该选择方法二。\n封装的目的：愈多的东西被封装，我们改变那些东西的能力也就越大。愈多函数可访问它，数据的封装性就愈低。\n能够访问private成员变量的函数只有class的member函数+friend函数而已。\n因为成员函数（member）可以访问无限制的访问private的数据，而non-member、non-friend函数并不能增加“能访问class内之private成分”的数据。\n铭记：如果要你在一个member函数（它不只是可以访问class内的private数据，也可以取用private函数、enums、typedefs等等）和一个non-member，non-friend函数（它无法访问上述的任何东西）之间做抉择，而且两者提供相同机能，那么，导致较大封装性的是non-member non-friend函数，因此选择后者。 注意：non-member函数也可以是另一个class的member\n条款24：若所有参数皆需类型转换，请为此采用non-member函数 结论 如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member\n","id":42,"section":"categories","summary":"接口的设计与声明 接口设计的准则： 让接口容易被正确使用，不容易被误用。 什么是接口？ ​ 内部实现细节封装起来，外部用户用过预留的接口可以使用接口的","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记3","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/3/","year":"2021"},{"content":"条款05： C++默认编写并调用那些函数 默认创建\nclass Base\r{\rpublic：\rdefualt构造函数\rcopy构造函数\rcopy assignment操作符\r析构函数\r}\r条款06：若不想使用编译器自动生成的函数，就该明确拒绝（即不可被调用） 作法：\n​\t将默认创建的函数声明为私有的（——private——），为防止member函数和friend函数的内部调用，将成员函数声明为private而且故意不实现它们\nclass HomeForSale\r{\rpublic:\rprivate:\rHomeForSale(const HomeForSale\u0026amp;);\t//只有声明，不实现它们\rHomeForSale\u0026amp; operator=(const HomeForSale\u0026amp;);\r}\r更为常用的作法： 设计一个基类（base class） ，在这个基类内实现阻止copying等默认函数动作，然后继承它。\n条款07：为多态基类声明virtual析构函数 用法: 1.如果class不含virtual函数，通常表示它并不意图被用做一个base class。\n​\t即：class的设计目的如果不是作为base class使用，或者不是为了具备多态性，就不应该virtual析构函数。\n2.当class不企图被当做base class，令其析构函数为virtual往往是个馊主意\n3.多态性质的base classes应该声明一个virtual析构函数，如果class带有任何virtual函数，他就应该拥有一个virtual析构函数\n目的： 1.C++中基类采用virtual虚析构函数是为了防止内存泄漏。\n2.假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数\n可参考blog https://blog.csdn.net/sinat_20265495/article/details/51775724?ops_request_misc=\u0026amp;request_id=\u0026amp;biz_id=102\u0026amp;utm_term=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%20virtual\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-.pc_search_result_before_js\u0026amp;spm=1018.2226.3001.4187 https://blog.csdn.net/yhc166188/article/details/81587442?ops_request_misc=%7B%22request%5Fid%22%3A%22162622287916780261951132%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D 条款08：被让异常逃离析构函数 ###　结论\n１．析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。\n２．如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。\n原因 为什么析构函数不应吐出异常？\nvector的使用\nclass widget{\rpublic:\r~widget(){}\t//假设吐出一个异常\r}\rvoid dosomething()\r{\rstd::vector\u0026lt;Widget\u0026gt; v;\r}\t//v在这里被自动销毁\r假设v内含十个Widgets,而在析构第一个元素期间，有一个异常被抛出，其他九个widgets还是应该被销毁。\n这会导致多个异常同时存在，程序会结束执行或导致不明确行为。（结论1）\n若析构函数需要吐出异常，怎么办?\n一个例子： 数据库的连接，创建一个用来管理DBConnection资源的class，并在其析构函数中调用close（）。但close（）函数可能关闭失败，从而输出异常。\nclass DBConn\r{\rpublic:\r~DBConn()//确保数据库连接总是会被关闭\r{\rdb.close();//可能会关闭失败，输出异常\r}\rprivate:\rDBConnection db;\r}\r如果close（）失败，那么异常会离开~DBConn（）析构函数，成为麻烦。应该阻止异常从析构函数中传播出去。\n解决办法： 1.如果close抛出异常就结束程序。通常通过调用abort完成：\n即：\nDBConn::~DBConn()\r{\rtry{db.close();}\rcatch(...){\r制作运转记录，记录对close（）的调用失败（即日志库）;\rstd::abort();\r}\r}\r2.吞下因调用close而发生的异常（即对发生的异常，catch中不做处理）：\nDBConn::~DBConn()\r{\rtry{db.close();}\rcatch(...){\r制作运转记录，记录对close（）的调用失败（即日志库）;\r}\r}\r具体做法 重新设计DBConn接口,给客户一个关闭close函数的机会\nclass DBConn{\rpublic：\r...\rvoid close（）//供客户使用的新函数\r{\rdb.close();\rclosed=true;\r}\r~DBConn()\r{\rif(!closed)\r{\rtry{\rdb.close();\t//关闭连接（如果客户不主动关闭）\r}\rcatch(...){\t//如果关闭动作失败\r制作运转记录，记录对close的调用失败；//记录下来并结束程序 或 吞下异常\r} }\r}\rprivate：\rDBConnectin db;\rbool closed; }\r条款09：绝不在构造和析构函数过程中调用virtual函数 ###　结论\n在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class\n原因 一个例子：\n模拟股市交易如买进、卖出的订单等，每当创建一个交易对象，在审计日志中也需要创建一笔适当的记录。\n基类\rclass Transaction{\t//所有交易的base class\rpublic:\rTransaction();\rvirtual void logTransaction() const = 0;//做出一份因类型不同而不同的日志记录\r};\rTransaction::Transaction()\r{\r.....\rlogTransaction();\t//问题点\r}\r子类\rclass BuyTansaction:public Transaction{\rpublic:\rvirtual void logTransaction() const; //log此记录\r....\r} class SellTansaction:public Transaction{\rpublic:\rvirtual void logTransaction() const; //log此记录\r....\r} BuyTrasaction b;\r当BuyTrasaction b后，首先Transaction构造函数一定会被先调用，然后BuyTransaction构造函数被调用。\nTransaction::Transaction()中的logTransaction()函数执行的base class中的logTransaction。\n解决方法 在class Transaction内将logTransaction函数改为non-virtual，然后要求derived class构造函数传递必要信息给Transaction构造函数，而后那个构造函数便可安全地调用non-virtual logTransaction。\n即，通过构造函数的参数传递\n虚函数是从base class向下调用。 dervice class将必要的构造信息向上传递至base class构造函数。 注意形参\rclass Transaction\r{\rpublic：\rexplicit Transaction(const std::string\u0026amp; logInfo);\rvoid logTransaction(const std::string\u0026amp; logInfo) const;//如今是一个non-virtual函数\r....\r};\rTransaction::Transacton(const std::string\u0026amp; logInfo)\r{\r...\rlogTransaction(logInfo)\r}\rclass BuyTransaction:public Transaction{\rpublic:\rBuyTransaction( parameters ): Transaction（createLogString（parameter））//将log信息传给base class构造函数\r{\r...\r}\r...\rprivate:\rstatic std::string createLogString( parameter );//注意这个函数返回string类型， 函数是static类型的，可以作为构造函数的参数使用\r}\r函数使用static类型，使之不可能意外指向“初期未成熟之BuyTransaction对象内部尚未初始化的成员变量”。\n","id":43,"section":"categories","summary":"条款05： C++默认编写并调用那些函数 默认创建 class Base { public： defualt构造函数 copy构造函数 copy assignment操作符 析构函数","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记1","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/1/","year":"2021"}],"tags":[{"title":"blog","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/blog/"},{"title":"book","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/book/"},{"title":"c ","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/c/"},{"title":"cmake","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/cmake/"},{"title":"command","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/command/"},{"title":"cpp","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/cpp/"},{"title":" docker","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/docker/"},{"title":" git","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/git/"},{"title":"linux","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/linux/"},{"title":" math","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/math/"},{"title":" matlab","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/matlab/"},{"title":"net","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/net/"},{"title":" project","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/project/"},{"title":" python","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/python/"},{"title":"raspberry","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/raspberry/"},{"title":"robat","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/robat/"},{"title":" robot","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/robot/"},{"title":" ros","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/ros/"},{"title":"ros2 ","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/ros2/"},{"title":"slam","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/slam/"},{"title":" tool","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/tool/"},{"title":" ubuntu","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/ubuntu/"},{"title":" vim","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/vim/"},{"title":" vscode","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/vscode/"},{"title":" wsl1","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/wsl1/"},{"title":"概率论","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"title":" 网络","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/%E7%BD%91%E7%BB%9C/"}]}