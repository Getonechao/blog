{"categories":[{"title":"app","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/"},{"title":"lang","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/"},{"title":"math","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/"},{"title":"os","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/"},{"title":"other","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/other/"},{"title":"robat","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robat/"},{"title":"robot","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robot/"}],"posts":[{"content":"一、c/c++中调用LUA 1.开启控制台 // 打开lua\rLUA=luaL_newstate();\r// 导入LUA标准库\rluaL_openlibs(LUA);\r// 打开脚本文件\rif(luaL_dofile(LUA, \u0026quot;LidarConfig.lua\u0026quot;)!=LUA_OK)\r{\rstd::cerr\u0026lt;\u0026lt;\u0026quot;sorry lua file load and run failed\u0026quot;\u0026lt;\u0026lt;std::endl;\rexit(-1);\r}\r2.入栈操作 void lua_pushnil (lua_State *L);\rvoid lua_pushboolean (lua_State *L, int bool);\rvoid lua_pushnumber (lua_State *L, lua_Number n);\rvoid lua_pushinteger (lua_State *L, lua_Integer n);\rvoid lua_pushunsigned (lua_State *L, lua_Unsigned n);\rvoid lua_pushlstring (lua_State *L, const char *s, size_t len);\rvoid lua_pushstring (lua_State *L, const char *s);\r2.查询栈里面的元素 int lua_is* (lua_State * L, int index);\rLUA_API int (lua_isnumber) (lua_State *L, int idx);\rLUA_API int (lua_isstring) (lua_State *L, int idx);\rLUA_API int (lua_iscfunction) (lua_State *L, int idx);\rLUA_API int (lua_isinteger) (lua_State *L, int idx);\rLUA_API int (lua_isuserdata) (lua_State *L, int idx);\rLUA_API int (lua_type) (lua_State *L, int idx);\rLUA_API const char *(lua_typename) (lua_State *L, int tp);\r3.取值操作 LUA_API lua_Number (lua_tonumberx) (lua_State *L, int idx, int *isnum);\rLUA_API lua_Integer (lua_tointegerx) (lua_State *L, int idx, int *isnum);\rLUA_API int (lua_toboolean) (lua_State *L, int idx);\rLUA_API const char *(lua_tolstring) (lua_State *L, int idx, size_t *len);\rLUA_API lua_Unsigned (lua_rawlen) (lua_State *L, int idx);\rLUA_API lua_CFunction (lua_tocfunction) (lua_State *L, int idx);\rLUA_API void\t*(lua_touserdata) (lua_State *L, int idx);\rLUA_API lua_State *(lua_tothread) (lua_State *L, int idx);\rLUA_API const void *(lua_topointer) (lua_State *L, int idx);\r4.LUA脚本入栈操作 LUA_API int (lua_getglobal) (lua_State *L, const char *name);\rLUA_API int (lua_gettable) (lua_State *L, int idx);\rLUA_API int (lua_getfield) (lua_State *L, int idx, const char *k);\rLUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n);\rps\rme = { name = \u0026quot;zilongshanren\u0026quot;, age = 27}\rlua_getglobal(L,table);\rlua_getfield(L, -1, \u0026quot;age\u0026quot;);//-1是table的索引\r等同于\rlua_getglobal(L,table);\r//压入另一个key:age\rlua_pushstring(L, \u0026quot;age\u0026quot;);\r//取出-2位置的table,把table[age]的值压入栈\rlua_gettable(L, -2)\r","id":0,"section":"categories","summary":"一、c/c++中调用LUA 1.开启控制台 // 打开lua LUA=luaL_newstate(); // 导入LUA标准库 luaL_openlibs(LUA); // 打开脚本文件 if(luaL_dofile(LUA, \u0026quot;LidarConfig.lua\u0026quot;)!=LUA_OK) { std::cerr\u0026lt;\u0026lt;\u0026quot;sorry lua file load and run failed\u0026quot;\u0026lt;\u0026lt;std::endl; exit(-1); } 2.入栈操作 void lua_pushnil (lua_State *L); void lua_pushboolean (lua_State *L,","tags":[" "," "],"title":"LUA：C/C++的脚本语言","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/lua/","year":"2023"},{"content":"一、OS模块 1.目录操作 os.chdir(path)\ros.getcwd()\r打开一个文件，并且设置需要的打开选项\nos.open(file, flags)\r取得指定文件夹下的文件列表\nos.listdir(path)\r创建一个名为 path 的目录，应用以数字表示的权限模式 mode\nos.mkdir(path, mode=0o777, *, dir_fd=None)\ros.remove(path, *, dir_fd=None)\ros.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)\r递归目录创建函数。与 mkdir()类似，但会自动创建到达最后一级目录所需要的中间目录。\nos.makedirs(name, mode=0o777, exist_ok=False)\ros.removedirs(name)\ros.renames(old, new)\r创建一个名为 path 的 FIFO（命名管道，一种先进先出队列），具有以数字表示的权限状态 mode。\nos.mkfifo(path, mode=0o666, *, dir_fd=None)\r创建一个名为 path 的文件系统节点（文件，设备专用文件或命名管道）\nos.mknod(path, mode=0o600, device=0, *, dir_fd=None)\r提取主设备号，提取自原始设备号（通常是 stat 中的 st_dev 或 st_rdev 字段）\nos.major(device, /) os.minor(device, /) 提取次设备号，提取自原始设备号（通常是 stat 中的 st_dev 或 st_rdev 字段）。\ros.makedev(major, minor, /) 将主设备号和次设备号组合成原始设备号。\ros.pathconf_names 字典，表示映射关系，为 pathconf() 和 fpathconf() 可接受名称与操作系统为这些名称定义的整数值之间的映射。\ros.pathconf(path, name) 返回所给名称的文件有关的系统配置信息。name 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX.1，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 pathconf_names 字典中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 name。\r# 获取文件最大连接数\rno = os.fpathconf(fd, 'PC_LINK_MAX')\rprint \u0026quot;Maximum number of links to the file. :%d\u0026quot; % no\r# 获取文件名最大长度\rno = os.fpathconf(fd, 'PC_NAME_MAX')\rprint \u0026quot;Maximum length of a filename :%d\u0026quot; % no\r返回一个字符串，为符号链接指向的实际路径。其结果可以是绝对或相对路径。如果是相对路径，则可用 os.path.join(os.path.dirname(path), result) 转换为绝对路径。\nos.readlink(path, *, dir_fd=None)\r2.文件操作 这些函数创建新的 file objects\nos.fdopen(fd, *args, **kwargs)\r3.进程参数 4. 文件描述符操作 打开文件 path，根据 flags 设置各种标志位，并根据 mode 设置其权限状态\nos.open(path, flags, mode=0o777, , dir_fd=None)\ros.O_RDONLY\ros.O_WRONLY\ros.O_RDWR\ros.O_APPEND\ros.O_CREAT\ros.O_EXCL\ros.O_TRUNC\r上述常量在 Unix 和 Windows 上均可用。\ros.O_DSYNC\ros.O_RSYNC\ros.O_SYNC\ros.O_NDELAY\ros.O_NONBLOCK\ros.O_NOCTTY\ros.O_CLOEXEC\r这个常数仅在 Unix 系统中可用。\r打开一对新的伪终端，返回一对文件描述符 （主，从），分别为 pty 和 tty。\nos.openpty()\r创建一个管道，返回一对分别用于读取和写入的文件描述符 (r, w)\nos.pipe()\r读写\nos.read(fd, n, /)\ros.readv(fd, buffers, /)\ros.write(fd, str, /)\ros.writev(fd, buffers, /)\ros.sendfile(out_fd, in_fd, offset, count)\ros.sendfile(out_fd, in_fd, offset, count, headers=(), trailers=(), flags=0)\r关闭文件描述符 fd。\nos.close(fd)\r**************\ros.closerange(fd_low, fd_high, /) 关闭从 fd_low （包括）到 fd_high （排除）间的文件描述符，并忽略错误。\r**************\ros.copy_file_range(src, dst, count, offset_src=None, offset_dst=None) 从文件描述符 src 复制 count 字节，从偏移量 offset_src 开始读取，到文件描述符 dst，从偏移量 offset_dst 开始写入\r备注：该功能适用于低级 I/O 操作，必须用于 os.open() 或 pipe() 返回的文件描述符。若要关闭由内建函数 open()、popen() 或 fdopen() 返回的 \u0026quot;文件对象\u0026quot;，则应使用其相应的 close() 方法。\r获取文件描述符 fd 的状态\nos.fstat(fd)\r如果文件描述符 fd 打开且已连接至 tty 设备（或类 tty 设备），返回 True，否则返回 False\nos.isatty(fd, /)\r5. Linux 扩展属性 6.进程管理 os.abort()\ros.add_dll_directory(path)将路径添加到 DLL 搜索路径。\r*************************\ros.execl(path, arg0, arg1, ...)\ros.execle(path, arg0, arg1, ..., env)\ros.execlp(file, arg0, arg1, ...)\ros.execlpe(file, arg0, arg1, ..., env)\ros.execv(path, args)\ros.execve(path, args, env)\ros.execvp(file, args)\ros.execvpe(file, args, env)\r这些函数都将执行一个新程序，以替换当前进程。它们没有返回值。在 Unix 上，新程序会加载到当前进程中，且进程号与调用者相同。过程中的错误会被报告为 OSError 异常\r**************************\ros._exit(n)\r7.调度器接口 控制操作系统如何为进程分配 CPU 时间\n***********调度策略常量**************\ros.SCHED_OTHER 默认调度策略\ros.SCHED_BATCH 用于 CPU 密集型进程的调度策略，它会尽量为计算机中的其余任务保留交互性\ros.SCHED_IDLE 用于极低优先级的后台任务的调度策略\ros.SCHED_SPORADIC 用于偶发型服务程序的调度策略\ros.SCHED_FIFO 先进先出的调度策略\ros.SCHED_RR 循环式的调度策略\ros.SCHED_RESET_ON_FORK 此旗标可与任何其他调度策略进行 OR 运算。 当带有此旗标的进程设置分叉时，其子进程的调度策略和优先级会被重置为默认值。\r**********************************\rclass os.sched_param(sched_priority) os.sched_get_priority_min(policy) 获取 policy 的最低优先级数值。 policy 是以上调度策略常量之一\ros.sched_get_priority_max(policy) 获取 policy 的最高优先级数值。 policy 是以上调度策略常量之一\reg:\rimport os\rparam = os.sched_param(os.sched_get_priority_max(os.SCHED_FIFO))\ros.sched_setscheduler(0, os.SCHED_FIFO, param)\ros.sched_setscheduler(pid, policy, param) 根据进程的 PID pid 设置其调度策略。pid 为 0 指的是调用本方法的进程；policy 是以上调度策略常量之一；param 是一个 sched_param 实例。\ros.sched_getscheduler(pid) 返回 PID 为 pid 的进程的调度策略。pid 为 0 指的是调用本方法的进程。返回的结果是以上调度策略常量之一。 os.sched_setparam(pid, param) 设置 PID 为 pid 的进程的某个调度参数。pid 为 0 指的是调用本方法的进程。param 是一个 sched_param 实例\ros.sched_getparam(pid) 返回 PID 为 pid 的进程的调度参数为一个 sched_param 实例。pid 为 0 指的是调用本方法的进程。\ros.sched_rr_get_interval(pid) 返回 PID 为 pid 的进程在时间片轮转调度下的时间片长度（单位为秒）。pid 为 0 指的是调用本方法的进程。\ros.sched_yield() 自愿放弃 CPU。\ros.sched_setaffinity(pid, mask) 将 PID 为 pid 的进程（为零则为当前进程）限制到一组 CPU 上。mask 是整数的可迭代对象，表示应将进程限制在其中的一组 CPU。\ros.sched_getaffinity(pid) 返回 PID 为 pid 的进程（为零则为当前进程）被限制到的那一组 CPU\r8.其他系统信息 os.cpu_count() cpu核数\ros.getloadavg() 返回系统运行队列中最近 1、5 和 15 分钟内的平均进程数。\r***********************************************************\ros.confstr_names 字典，表示映射关系，为 confstr() 可接受名称与操作系统为这些名称定义的整数值之间的映射\ros.confstr(name) ***********************************************************\ros.sysconf_names 字典，表示映射关系，为 os.sysconf() 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。\ros.sysconf(name) ***********************************************************\ros.curdir .\ros.pardir ..\ros.sep /\ros.extsep . \u0026quot;分隔基本文件名与扩展名的字符 eg test.txt\u0026quot;\ros.pathsep : 操作系统通常用于分隔搜索路径（如 PATH）中不同部分的字符，如 POSIX 上是 ':'，Windows 上是 ';'\ros.devnull 空设备的文件路径。如 POSIX 上为 '/dev/null'，Windows 上为 'nul'\r9.随机数 10.一些变量 1. os.environ\r一个表示字符串环境的mapping对象，访问方式：os.environ['HOME']\r2. 11.OS.path路径操作 os.path.abspath(path)\t返回绝对路径\ros.path.basename(path)\t返回文件名\ros.path.dirname(path)\t返回文件路径\rs.path.exists(path)\t路径存在则返回True,路径损坏返回False\ros.path.getatime(path)\t返回最近访问时间（浮点型秒数）\ros.path.getmtime(path)\t返回最近文件修改时间\ros.path.getctime(path)\t返回文件 path 创建时间\ros.path.isabs(path)\t判断是否为绝对路径\ros.path.isfile(path)\t判断路径是否为文件\ros.path.isdir(path)\t判断路径是否为目录\ros.path.join(path1[, path2[, ...]])\t把目录和文件名合成一个路径\ros.path.normcase(path)\t转换path的大小写和斜杠\ros.path.realpath(path)\t返回path的真实路径\ros.path.samefile(path1, path2)\t判断目录或文件是否相同\ros.path.sameopenfile(fp1, fp2)\t判断fp1和fp2是否指向同一文件\ros.path.split(path)\t把路径分割成 dirname 和 basename，返回一个元组\ros.path.splitext(path)\t分割路径中的文件名与拓展名\ros.path.walk(path, visit, arg)\t遍历path，进入每个目录都调用visit函数，visit函数必须有3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数\ros.path.sep\t获取当前系统路径分隔符\r二、SYS模块 ","id":1,"section":"categories","summary":"一、OS模块 1.目录操作 os.chdir(path) os.getcwd() 打开一个文件，并且设置需要的打开选项 os.open(file, flags) 取得指定文件夹下的文件列表 os.listdir(path) 创建一个名为 path 的目录，应用以数字表示的权限模","tags":[" "," "],"title":"python3:一些库的总结经验","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/python/lib/","year":"2023"},{"content":"README - 《阮一峰 Bash 脚本教程》 - 书栈网 · BookStack\n一、启动环境 当前bash环境\rsource main.sh\r子bash环境\r./main.sh\r二、变量 2.1 将局部变量声明为全局变量 export a=1\r2.2 位置变量 $0 $1 $2 $3 --- $10：($0 文件名本身)\r$#：参数个数\r$@：表示获取执行脚本传入的所有参数\r$*：表示执行脚本传入参数的列表（不包括$0）\r$?：表示脚本执行的状态，0表示正常，其他表示错误\r$$：表示进程的id；Shell本身的PID（ProcessID，即脚本运行的当前 进程ID号）\r$!：Shell最后运行的后台Process的PID(后台运行的最后一个进程的 进程ID号)\r2.3 if条件判别式 形式\nif [条件判别式]；then\r当条件判别式成立时\rfi\r\u0026amp;\u0026amp; 等同 AND\r|| 等同 OR\rif [条件判别式] AND [条件判别式];then\relif [条件判别式];then\relse\rfi\r2.4 case\u0026hellip;..esac判断 case $aNum in\r1) echo 'You select 1'\r;;\r2) echo 'You select 2'\r;;\r3) echo 'You select 3'\r;;\r4) echo 'You select 4'\r;;\r*) echo 'You do not select a number between 1 to 4'\r;;\resac\r2.5 function功能 function fname(){\r程序段\r}\rfunction也是拥有内置变量的，它的内置变量与shell脚本很类似，函数名称代表示$0，而后续接的变量也是以$1、$2\u0026hellip;来替换。\n因为shell脚本的执行方式是由上往下，由左而右，因此在shell脚本当中的function的设置一定要在程序的最前面。\n2.6 循环（loop） 模式一：满足什么条件开始循环\nwhile [条件判别式]\rdo\r程序段落\rdone\r模式二：\nuntil [条件判别式]\rdo\rdone\r2.7 for\u0026hellip;do\u0026hellip;\u0026hellip;done(固定循环) 模式一\nfor var in con1 con2 con3 ...\rdo\r程序段\rdone ################################\r注：除了$(seq 1 100)之外，seq是连续(sequence)的缩写之意，你也可以直接通过bash的内置机制来处理，可以使用{1.. 100}来替换$(seq 1 100)。也可以echo{a..g}\reg:\rfor var in $(seq 1 100)\rdo\rdone\r模式二\nfor((初始值;限制值;赋值运算))\rdo\r程序段\rdone\r###############################\reg:\rfor((i=1;i\u0026lt;=7;i=i+1))\rdo\recho $i\tdone\r","id":2,"section":"categories","summary":"README - 《阮一峰 Bash 脚本教程》 - 书栈网 · BookStack 一、启动环境 当前bash环境 source main.sh 子bash环境 ./main.sh 二、变量 2.1 将局部变量声明为全局变量 export a=1 2.2 位置变量 $0 $1 $2 $3","tags":[" Linux"," "],"title":"Linux：Shell脚本编程","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/linux/shell/","year":"2023"},{"content":"一、定时任务 二、bat脚本 1. 基础命令 echo\nrem\npause\ncall\n1.调用另一个批处理程序，并且不终止父批处理程序（如果不用call而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令）。\n2.调用标签\nstart\n启动单独的命令提示符窗口以运行指定的程序或命令\nstart [\u0026lt;Title\u0026gt;] [/d \u0026lt;Path\u0026gt;] [/i] [{/min | /max}] [{/separate | /shared}] [{/low | /normal | /high | /realtime | /abovenormal | belownormal}] [/affinity \u0026lt;HexAffinity\u0026gt;] [/wait] [/elevate] [/b] [\u0026lt;Command\u0026gt; [\u0026lt;Parameter\u0026gt;... ] | \u0026lt;Program\u0026gt; [\u0026lt;Parameter\u0026gt;... ]]\rcall与start的区别\ncall调用不仅可以把参数或变量传给被调用的批处理，而且被调用的批处理也可以设置参数或变量以便回传，而start只能把参数或变量传给被调用的批处理，却不能回传参数或变量，这一点实际上是第二点的延伸 goto\ncall命令的应用示例2中，我们看到了call命令对跳转标签的调用，注意调用时必须在标签名前加冒号，而goto是直接跟标签名\nset\n2.批处理符号简介 回显屏蔽 @\n重定向1 \u0026gt;与\u0026raquo;\n重定向2 \u0026lt;\n管道符号 |\n转义符 ^\n逻辑命令符包括：\u0026amp;、\u0026amp;\u0026amp;、||\n批处理参数%[1-9]\n%[1-9]表示参数，参数是指在运行批处理文件时在文件名后加的以空格（或者Tab）分隔的字符串。变量可以从%0到%9，%0表示批处理命令本身，其它参数字符串用%1到%9顺序表示。\n3.逻辑判断 3.1 if语句 形式\nIF [NOT] ERRORLEVEL number command\rIF [NOT] string1==string2 command\rIF [NOT] EXIST filename command\r比较字符串\u0026amp;\u0026amp;比较数字 if [not] 信息比较表达式 (\r命令行1\r) else (\r命令行2\r)\r案例\r@echo off\rif abc==ABC (\recho abc euqal ABC\r) else (\recho abc not euqal ABC\r)\rpause\u0026gt;nul\r检测文件(夹)是否存在 if [not] exist filepath (\r命令行1\r) else (\r命令行2\r)\r其中“exist”是关键字表示“存在”，“filepath”表示要判断的文件路径，如果检查到指定的文件存在则执行对应的命令块，“not”表示相反操作\r@echo off\rif exist C:\\a.txt (\recho file is find!\rdel C:\\a.txt\r) else (\recho file is not found!\r)\rpause\u0026gt;nul\r检测变量是否被定义\nif defined 变量名 (\r命令行1\r) else (\r命令行2\r)\r判断返回值(ERRORLEVEL)\n表达式\rif [not] ERRORLEVEL \u0026lt;number\u0026gt; \u0026lt;command\u0026gt; [else \u0026lt;expression\u0026gt;]\r前一个指令的返回值判断， 大于等于则为true。\r错误级别“errorlevel”是MS-DOS的内置环境变量，在上面已经介绍过，主要用于保存上一条命令语句是否执行成功，成功则返回0，失败或错误则返回相对应的错误级别码。然而“errorlevel”是内置环境变量，所以可以使用下面的方式判断：\r案列：\rif %errorlevel%==0 (\recho success!\r) else (\recho failed!\r)\r然而“if”语句提供了一种特殊的错误级别判断方式，如下：\rif [not] errorlevel number (\r命令行1\r) else (\r命令行2\r)\rerrorle\n@ECHO OFF\rXCOPY C:\\AUTOEXEC.BAT D:\\\rIF ERRORLEVEL 0 ECHO 成功拷贝文件\rIF ERRORLEVEL 1 ECHO 未找到拷贝文件\rIF ERRORLEVEL 2 ECHO 用户通过ctrl-c中止拷贝操作\rIF ERRORLEVEL 3 ECHO 预置错误阻止文件拷贝操作\rIF ERRORLEVEL 4 ECHO 拷贝过程中写盘错误 无论拷贝是否成功，后面的：\r未找到拷贝文件\r用户通过ctrl-c中止拷贝操作\r预置错误阻止文件拷贝操作\r拷贝过程中写盘错误\r都将显示出来。 3.2 for语法 for %%a in (A B C) do echo %%a\r案例：\rfor %%c in (*.bat *.txt) do type %%c\r3.3 choice语句 choice 使用此命令可以让用户输入一个字符（用于选择），从而根据用户的选择返回不同的errorlevel，然后于if errorlevel配合，根据用户的选择运行不同的命令。\n注意：choice命令为DOS或者Windows系统提供的外部命令，不同版本的choice命令语法会稍有不同，请用choice /?查看用法。\nchoice的命令语法（该语法为Windows 2003中choice命令的语法，其它版本的choice的命令语法与此大同小异）:\nCHOICE [/C choices] [/N] [/CS] [/T timeout /D choice] [/M text]\r描述:该工具允许用户从选择列表选择一个项目并返回所选项目的索引。\r参数列表:\r/C choices 指定要创建的选项列表。默认列表是 \u0026quot;YN\u0026quot;。\r/N 在提示符中隐藏选项列表。提示前面的消息得到显示，\r选项依旧处于启用状态。\r/CS 允许选择分大小写的选项。在默认情况下，这个工具\r是不分大小写的。\r/T timeout 做出默认选择之前，暂停的秒数。可接受的值是从 0\r到 9999。如果指定了 0，就不会有暂停，默认选项\r会得到选择。\r/D choice 在 nnnn 秒之后指定默认选项。字符必须在用 /C 选\r项指定的一组选择中; 同时，必须用 /T 指定 nnnn。\r/M text 指定提示之前要显示的消息。如果没有指定，工具只\r显示提示。\r/? 显示帮助消息。\r注意:\rERRORLEVEL 环境变量被设置为从选择集选择的键索引。列出的第一个选\r择返回 1，第二个选择返回 2，等等。如果用户按的键不是有效的选择，\r该工具会发出警告响声。如果该工具检测到错误状态，它会返回 255 的\rERRORLEVEL 值。如果用户按 Ctrl+Break 或 Ctrl+C 键，该工具会返回 0\r的 ERRORLEVEL 值。在一个批程序中使用 ERRORLEVEL 参数时，将参数降\r序排列。\r示例:\rCHOICE /?\rCHOICE /C YNC /M \u0026quot;确认请按 Y，否请按 N，或者取消请按 C。\u0026quot;\rCHOICE /T 10 /C ync /CS /D y\rCHOICE /C ab /M \u0026quot;选项 1 请选择 a，选项 2 请选择 b。\u0026quot;\rCHOICE /C ab /N /M \u0026quot;选项 1 请选择 a，选项 2 请选择 b。\u0026quot;\r案例：\r@echo off\rchoice /C dme /M \u0026quot;defrag,mem,end\u0026quot;\rif errorlevel 1 goto defrag\rif errorlevel 2 goto mem\rif errorlevel 3 goto end\r:defrag\rc:\\dos\\defrag\rgoto end\r:mem\rmem\rgoto end\r:end\recho good bye\r按下d，%errorlevel%=1\r按下m，%errorlevel%=2\r按下e，%errorlevel%=3\r3.4 setlocal与endlocal命令 setlocal和endlocal命令执行结果：让中间的程序对于系统变量的改变只在程序内起作用，不会影响整个系统级别。\n@echo off\rsetlocal\rpath=d:\\\recho 局部环境变量path值\rset path\rendlocal\recho 系统环境变量path的值\rset path\r在第二行setlocal之后，第三行对于变量path进行了赋值，第四行就是显示一下该值。在第六行endlocal后，重新显示一下系统变量path（第七行），会发现仍然是程序运行之前的path值，没有被程序改变。\n三、bat成品案例 1.通过批处理文件（.bat）一键修改电脑ip地址 @echo off\recho.\recho 修改ip地址，1为自动获取ip地址，2为修改家里ip地址,3 为公司IP\recho.set sel=\rset/p sel=请选择修改方式：\rif \u0026quot;%sel%\u0026quot;==\u0026quot;1\u0026quot; goto auto\rif \u0026quot;%sel%\u0026quot;==\u0026quot;2\u0026quot; goto home\rif \u0026quot;%sel%\u0026quot;==\u0026quot;3\u0026quot; goto company\recho 您没有选择修改方式。\rgoto end\r:auto\rnetsh interface ip set address name=\u0026quot;本地连接\u0026quot; source=dhcp\rnetsh interface ip delete dns \u0026quot;本地连接\u0026quot; all\ripconfig /flushdns\ripconfig /all\rgoto end\r:home\recho 正在更改IP地址，请稍等......\rnetsh interface ip set address name=\u0026quot;本地连接\u0026quot; source=static addr=192.168.1.80 mask=255.255.255.0 gateway=192.168.1.1 gwmetric=1\rnetsh interface ip set dns name=\u0026quot;本地连接\u0026quot; source=static addr=202.102.192.68\rnetsh interface ip add dns name=\u0026quot;本地连接\u0026quot; addr=202.102.199.68 index=2 ipconfig /flushdns\ripconfig /all\recho 更改IP地址完成！\rgoto end\r:company\recho 正在更改IP地址，请稍等......\rnetsh interface ip set address name=\u0026quot;本地连接\u0026quot; source=static addr=10.85.10.80 mask=255.255.255.0 gateway=10.85.10.253 gwmetric=1\rnetsh interface ip set dns name=\u0026quot;本地连接\u0026quot; source=static addr=218.104.78.2\rnetsh interface ip add dns name=\u0026quot;本地连接\u0026quot; addr=10.85.7.100 index=2 ipconfig /flushdns\ripconfig /all\rgoto end\r:end\rpause\r","id":3,"section":"categories","summary":"一、定时任务 二、bat脚本 1. 基础命令 echo rem pause call 1.调用另一个批处理程序，并且不终止父批处理程序（如果不用call而直接调用别的批处理文件，那么","tags":["win "," "],"title":"windows:一些好用的操作","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/win/","year":"2023"},{"content":"文章来源：(100条消息) 使用 LxRunOffline 实现 WSL 自定义安装、备份_farer_yyh的博客-CSDN博客\n如果你没有使用过 WSL ，首先以管理员身份运行 Pow­er­Shell (WIN+X , A)，输入下面的命令开启 “适用于 Linux 的 Win­dows 子系统” 功能，并重启计算机。\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux\r下载 WSL 官方离线包，你会得到一个后缀为.appx的文件，改后缀名为.zip，解压后文件夹中会有名为 install.tar.gz 的文件。\n输入以下命令进行安装：\nlxrunoffline i -n \u0026lt;WSL名称\u0026gt; -d \u0026lt;安装路径\u0026gt; -f \u0026lt;安装包路径\u0026gt;.tar.gz\r常用命令\n//已经安装的WSL\rLxRunOffline.exe list //还原WSL\rLxRunOffline.exe install -n \u0026lt;wsl_name\u0026gt; -d \u0026lt;res_path\u0026gt; -f \u0026lt;back_path\u0026gt;\r//卸载WSL\rLxRunOffline.exe uninstall -n \u0026lt;wsl_name\u0026gt;\r//备份WSL\rLxRunOffline.exe export -n \u0026lt;wsl_name\u0026gt; -f \u0026lt;back_path\u0026gt;\r//启动一个WSL\rLxRunOffline.exe run -n \u0026lt;wslname\u0026gt;\r创建一个新用户\nuseradd chao -p chao -m -G wheel（或sudo） -s /bin/bash -c \u0026quot;2021-6-3 create 'chao' username \u0026quot; passwd chao\rlxrunoffline su -n \u0026lt;WSL名称\u0026gt; -v 1000(UID)\rWSL2中使用USB ","id":4,"section":"categories","summary":"文章来源：(100条消息) 使用 LxRunOffline 实现 WSL 自定义安装、备份_farer_yyh的博客-CSDN博客 如果你没有使用过 WSL ，首先以管理员身份运行 Pow","tags":[" "," "],"title":"Lxrunoffline：一款自定义安装wsl的工具","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/lxrunoffline/","year":"2023"},{"content":"一、/proc文件系统 1.进程相关信息-PID：646 进程目录中的此文件不包含任何信息；\ncwd — 指向“当前进程运行目录的”一个符号链接；\nenviron — 当前进程的环境变量列表，彼此间用空字符（NULL）隔开；变量用大写字母表示，其值用小写字母表示；\nexe — 指向启动当前进程的可执行文件（完整路径）的符号链接，通过/proc/N/exe可以启动当前进程的一个拷贝；\nfd — 这是个目录，包含当前进程打开的每一个文件的文件描述符（file descriptor），这些文件描述符是指向实际文件的一个符号链接；\nlimits — 当前进程所使用的每一个受限资源的软限制、硬限制和管理单元；此文件仅可由实际启动当前进程的UID用户读取；（2.6.24以后的内核版本支持此功能）；\nmaps — 当前进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表；\nmem — 当前进程所占用的内存空间，由open、read和lseek等系统调用使用，不能被用户读取；\nroot — 指向当前进程运行根目录的符号链接；在Unix和Linux系统上，通常采用chroot命令使每个进程运行于独立的根目录；\nstat — 当前进程的状态信息，包含一系统格式化后的数据列，可读性差，通常由ps命令使用；\nstatm — 当前进程占用内存的状态信息，通常以“页面”（page）表示；\nstatus — 与stat所提供信息类似，但可读性较好，如下所示，每行表示一个属性信息；其详细介绍请参见 proc的man手册页；\ntask — 目录文件，包含由当前进程所运行的每一个线程的相关信息，每个线程的相关信息文件均保存在一个由线程号（tid）命名的目录中，这类似于其内容类似于每个进程目录中的内容；（内核2.6版本以后支持此功能）\n2./proc/devices 系统已经加载的所有块设备和字符设备的信息，包含主设备号和设备组（与主设备号对应的设备类型）名\n3./proc/diskstats 4./proc/dma 每个正在使用且注册的ISA DMA通道的信息列表\n5./proc/execdomains 内核当前支持的执行域（每种操作系统独特“个性”）信息列表；\n6./proc/fb 帧缓冲设备列表文件，包含帧缓冲设备的设备号和相关驱动信息；\n7./proc/filesystems 当前被内核支持的文件系统类型列表文件，被标示为nodev的文件系统表示不需要块设备的支持；\n通常mount一个设备时，如果没有指定文件系统类型将通过此文件来决定其所需文件系统的类型；\n8./proc/interrupts X86或X86_64体系架构系统上每个IRQ相关的中断号列表；\n多路处理器平台上每个CPU对于每个I/O设备均有自己的中断号；\n9. /proc/iomem 每个物理设备上的记忆体（RAM或者ROM）在系统内存中的映射信息；\n10./proc/ioports 当前正在使用且已经注册过的与物理设备进行通讯的输入-输出端口范围信息列表；如下面所示，第一列表示注册的I/O端口范围，其后表示相关的设备；\n11./proc/kallsyms 模块管理工具用来动态链接或绑定可装载模块的符号定义，由内核输出；（内核2.5.71以后的版本支持此功能）；通常这个文件中的信息量相当大；\n12./proc/kcore 系统使用的物理内存，以ELF核心文件（core file）格式存储，其文件大小为已使用的物理内存（RAM）加上4KB；\n这个文件用来检查内核数据结构的当前状态，因此，通常由GBD通常调试工具使用，但不能使用文件查看命令打开此文件；\n13./proc/kmsg 此文件用来保存由内核输出的信息，通常由**/sbin/klogd或/bin/dmsg**等程序使用，不要试图使用查看命令打开此文件；\n14./proc/loadavg 保存关于CPU和磁盘I/O的负载平均值，其前三列分别表示每1秒钟、每5秒钟及每15秒的负载平均值，类似于uptime命令输出的相关信息；第四列是由斜线隔开的两个数值，前者表示当前正由内核调度的实体（进程和线程）的数目，后者表示系统当前存活的内核调度实体的数目；第五列表示此文件被查看前最近一个由内核创建的进程的PID；\n15./proc/locks 保存当前由内核锁定的文件的相关信息，包含内核内部的调试数据；每个锁定占据一行，且具有一个惟一的编号；如下输出信息中每行的第二列表示当前锁定使用的锁定类别，POSIX表示目前较新类型的文件锁，由lockf系统调用产生，FLOCK是传统的UNIX文件锁，由flock系统调用产生；第三列也通常由两种类型，ADVISORY表示不允许其他用户锁定此文件，但允许读取，MANDATORY表示此文件锁定期间不允许其他用户任何形式的访问；\n16./proc/mdstat 保存RAID相关的多块磁盘的当前状态信息，在没有使用RAID机器上，其显示为如下状态\n17./proc/meminfo 系统中关于当前内存的利用状况等的信息，常由free命令使用；可以使用文件查看命令直接读取此文件，其内容显示为两列，前者为统计属性，后者为对应的值；\n18./proc/mounts 在内核2.4.29版本以前，此文件的内容为系统当前挂载的所有文件系统，在2.4.19以后的内核中引进了每个进程使用独立挂载名称空间的方式，此文件则随之变成了指向/proc/self/mounts（每个进程自身挂载名称空间中的所有挂载点列表）文件的符号链接；/proc/self是一个独特的目录，后文中会对此目录进行介绍；\n19./proc/modules 当前装入内核的所有模块名称列表，可以由lsmod命令使用，也可以直接查看；如下所示，\n其中第一列表示模块名，\n第二列表示此模块占用内存空间大小，\n第三列表示此模块有多少实例被装入，\n第四列表示此模块依赖于其它哪些模块，\n第五列表示此模块的装载状态（Live：已经装入；Loading：正在装入；Unloading：正在卸载），\n第六列表示此模块在内核内存（kernel memory）中的偏移量；\n20./proc/partitions 块设备每个分区的主设备号（major）和次设备号（minor）等信息，同时包括每个分区所包含的块（block）数目（如下面输出中第三列所示）；\n21./proc/bus/pci 内核初始化时发现的所有PCI设备及其配置信息列表，其配置信息多为某PCI设备相关IRQ信息，可读性不高，可以用“/sbin/lspci –vb”命令获得较易理解的相关信息；在2.6内核以后，此文件已为/proc/bus/pci目录及其下的文件代替；\n22./proc/slabinfo 在内核中频繁使用的对象（如inode、dentry等）都有自己的cache，即slab pool，而/proc/slabinfo文件列出了这些对象相关slap的信息；详情可以参见内核文档中slapinfo的手册页；\n23./proc/stat 实时追踪自系统上次启动以来的多种统计信息；如下所示，其中， “cpu”行后的八个值分别表示以1/100（jiffies）秒为单位的统计值（包括系统运行于用户模式、低优先级用户模式，运系统模式、空闲模式、I/O等待模式的时间等）； “intr”行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数； “ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。 “btime”给出了从系统启动到现在为止的时间，单位为秒； “processes (total_forks) 自系统启动以来所创建的任务的个数目； “procs_running”：当前运行队列的任务的数目； “procs_blocked”：当前被阻塞的任务的数目；\n24./proc/swaps 当前系统上的交换分区及其空间利用信息，如果有多个交换分区的话，则会每个交换分区的信息分别存储于/proc/swap目录中的单独文件中，而其优先级数字越低，被使用到的可能性越大；下面是作者系统中只有一个交换分区时的输出信息；\n25./proc/uptime 系统上次启动以来的运行时间，如下所示，其第一个数字表示系统运行时间，第二个数字表示系统空闲时间，单位是秒；\n26./proc/version 当前系统运行的内核版本号，在作者的RHEL5.3上还会显示系统安装的gcc版本，如下所示；\n27./proc/vmstat 当前系统虚拟内存的多种统计数据，信息量可能会比较大，这因系统而有所不同，可读性较好；下面为作者机器上输出信息的一个片段；（2.6以后的内核支持此文件）\n28./proc/zoneinfo 内存区域（zone）的详细信息列表，信息量较大，下面列出的是一个输出片段：\n29./proc/self pid/来获取指定进程的信息。/proc/pid\n如果某个进程想要获取当前进程的系统信息，就可以通过进程的pid来访问/proc/pid/目录,但是这个方法还需要获取进程pid。\n如果程序运行中，在fork、daemon等情况下，pid还可能发生变化。\n为了更方便的获取本进程的信息，Linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息时不同的，内容等价于/proc/本进程pid/。\n进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。\n二、cpu信息 cpu硬件信息\nlscpu\rArchitecture: armv7l\rByte Order: Little Endian\rCPU(s): 4\rOn-line CPU(s) list: 0-3\rThread(s) per core: 1\rCore(s) per socket: 4\rSocket(s): 1\rVendor ID: ARM\rModel: 3\rModel name: Cortex-A72\rStepping: r0p3\rCPU max MHz: 1500.0000\rCPU min MHz: 600.0000\rBogoMIPS: 162.00\rFlags: half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32\r详细的cpu单核信息\ncat /proc/cpuinfo\rprocessor : 0\rmodel name : ARMv7 Processor rev 3 (v7l)\rBogoMIPS : 108.00\rFeatures : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32\rCPU implementer : 0x41\rCPU architecture: 7\rCPU variant : 0x0\rCPU part : 0xd08\rCPU revision : 3\rprocessor : 1\rmodel name : ARMv7 Processor rev 3 (v7l)\rBogoMIPS : 108.00\rFeatures : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32\rCPU implementer : 0x41\rCPU architecture: 7\rCPU variant : 0x0\rCPU part : 0xd08\rCPU revision : 3\rprocessor : 2\rmodel name : ARMv7 Processor rev 3 (v7l)\rBogoMIPS : 108.00\rFeatures : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32\rCPU implementer : 0x41\rCPU architecture: 7\rCPU variant : 0x0\rCPU part : 0xd08\rCPU revision : 3\rprocessor : 3\rmodel name : ARMv7 Processor rev 3 (v7l)\rBogoMIPS : 108.00\rFeatures : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32\rCPU implementer : 0x41\rCPU architecture: 7\rCPU variant : 0x0\rCPU part : 0xd08\rCPU revision : 3\rHardware : BCM2711\rRevision : b03140\rSerial : 10000000f5e46c1d\rModel : Raspberry Pi Compute Module 4 Rev 1.0\r三、内存信息 查看内存大致信息\nfree -m\rtotal used free shared buff/cache available\rMem: 1.8Gi 55Mi 1.7Gi 8.0Mi 119Mi 1.7Gi\rSwap: 99Mi 0B 99Mi\rDESCRIPTION\rfree displays the total amount of free and used physical and swap memory in the system, as well as the buffers and caches used by the kernel. The information is gathered by parsing /proc/meminfo. The displayed columns are:\r详细的内存信息\ncat /proc/meminfo\r四、磁盘信息 查看硬盘和分区分布 lsblk\rNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT\rmmcblk0 179:0 0 14.6G 0 disk\r├─mmcblk0p1 179:1 0 256M 0 part /boot\r└─mmcblk0p2 179:2 0 14.3G 0 part /\rmmcblk0boot0 179:32 0 4M 1 disk\rmmcblk0boot1 179:64 0 4M 1 disk\r2.查看硬盘和分区的详细信息\nfdisk -l\r3.文件夹信息\nsudo du -sh *\r五、网卡信息 /proc/net/dev: 我们可以实时获取\u0026quot;网络适配器及统计信息\u0026quot;\n这里我们主要关心Receive和Transmit项的bytes项。同样网卡的流量，丢包率可以通过/proc/net/dev文件来读取。 ifstat获取网卡数据就是读取的/proc/net/dev系统来的。\n/proc/net/dev\rbytes: 接口发送或接收的数据的总字节数\rpackets: 接口发送或接收的数据包总数\rerrs: 由设备驱动程序检测到的发送或接收错误的总数\rdrop: 设备驱动程序丢弃的数据包总数\rfifo: FIFO缓冲区错误的数量\rframe: 分组帧错误的数量\rcolls: 接口上检测到的冲突数\rcompressed: 设备驱动程序发送或接收的压缩数据包数\rcarrier: 由设备驱动程序检测到的载波损耗的数量\rmulticast: 设备驱动程序发送或接收的多播帧数\r","id":5,"section":"categories","summary":"一、/proc文件系统 1.进程相关信息-PID：646 进程目录中的此文件不包含任何信息； cwd — 指向“当前进程运行目录的”一个符号链接； environ — 当前","tags":[" linux"," "],"title":"linux：/proc 硬件信息查询","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/linux/%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2/","year":"2023"},{"content":"","id":6,"section":"categories","summary":"","tags":[" "," "],"title":"Minicom：linux下一款好用的串口调试工具","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/minicom/","year":"2023"},{"content":"一、简介 Pipe Viewer 的简称，意思是通过管道显示数据处理进度的信息。特别适合某些场景比如拷贝文件，不显示进度，可以用PV显示\npv(选项)(参数)\r-p, --progress 显示进度条\t【默认使用】\r-t, --timer 显示已用时间 【默认使用】\r-e, --eta 显示预计到达时间 (完成)\t【默认使用】\r-I, --fineta 显示绝对估计到达时间\r(完成)\r-r, --rate 显示数据传输速率计数器\t【默认使用】\r-a, --average-rate 显示数据传输平均速率计数器\r-b, --bytes 显示传输的字节数\t【默认使用】\r-T, --buffer-percent 显示正在使用的传输缓冲区百分比\r-A, --last-written NUM 显示上次写入的字节数\r-F, --format FORMAT 将输出格式设置为FORMAT\r-n, --numeric 输出百分比\r-q, --quiet 不输出任何信息\r-W, --wait 在传输第一个字节之前不显示任何内容\r-D, --delay-start SEC 在SEC秒过去之前不显示任何内容\r-s, --size SIZE 将估算的数据大小设置为SIZE字节\r-l, --line-mode 计算行数而不是字节数 -0, --null 行以零结尾\r-i, --interval SEC 每SEC秒更新一次\r-w, --width WIDTH 假设终端的宽度为WIDTH个字符 -H, --height HEIGHT 假设终端高度为HEIGHT行\r-N, --name NAME 在可视信息前面加上名称\r-f, --force 将标准错误输出到终端\r-c, --cursor 使用光标定位转义序列\r-L, --rate-limit RATE 将传输限制为每秒RATE字节\r-B, --buffer-size BYTES 使用BYTES的缓冲区大小\r-C, --no-splice 从不使用splice()，始终使用读/写\r-E, --skip-errors 跳过输入中的读取错误\r-S, --stop-at-size 传输--size字节后停止\r-R, --remote PID 更新过程PID的设置\r-P, --pidfile FILE 将进程ID保存在FILE中 -d, --watchfd PID[:FD] 监视进程PID,打开的文件FD\r-h, --help 显示帮助\r-V, --version 显示版本信息\r二、使用方法 2.1 复制文件 如果没有指定选项，默认使用 -p, -t, -e, -r 和 -b 选项\rpv getiot.db \u0026gt; getiot.db.bak\r","id":7,"section":"categories","summary":"一、简介 Pipe Viewer 的简称，意思是通过管道显示数据处理进度的信息。特别适合某些场景比如拷贝文件，不显示进度，可以用PV显示 pv(选项)(参数) -p, --progress 显","tags":["linux "," "],"title":"pv：Pipe Viewer 通过管道显示数据处理进度的信息","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/pv/","year":"2023"},{"content":"一、基本使用简介 usage: nc [-46CDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl]\r[-m minttl] [-O length] [-P proxy_username] [-p source_port]\r[-q seconds] [-s source] [-T keyword] [-V rtable] [-W recvlimit] [-w timeout]\r[-X proxy_protocol] [-x proxy_address[:port]] [destination] [port]\rCommand Summary:\r-4 Use IPv4\r-6 Use IPv6\r-b Allow broadcast\r-C Send CRLF as line-ending\r-D Enable the debug socket option\r-d Detach from stdin\r-F Pass socket fd\r-h This help text\r-I length TCP receive buffer length\r-i interval Delay interval for lines sent, ports scanned\r-k Keep inbound sockets open for multiple connects（配合 -l 选项使用，可以重复接受客户端连接。）\r-l Listen mode, for inbound connects（开启“监听模式”，nc 作为【服务端】注：如不加该选项，nc 默认作为客户端）\r-M ttl Outgoing TTL / Hop Limit\r-m minttl Minimum incoming TTL / Hop Limit\r-N Shutdown the network socket after EOF on stdin\r-n Suppress name/port resolutions\r-O length TCP send buffer length\r-P proxyuser Username for proxy authentication\r-p port Specify local port for remote connects（指定“端口号”）\r-q secs quit after EOF on stdin and delay of secs（让 nc 延时（N 秒）再退出）\r-r Randomize remote ports\r-S Enable the TCP MD5 signature option\r-s source Local source address\r-T keyword TOS value\r-t Answer TELNET negotiation\r-U Use UNIX domain socket\r-u UDP mode（使用 UDP 协议 注：如不加该选项，默认是 TCP 协议）\r-V rtable Specify alternate routing table\r-v Verbose （显示详细信息）\r-W recvlimit Terminate after receiving a number of packets\r-w timeout Timeout for connects and final net reads（设置连接的超时间隔（N 秒））\r-X proto Proxy protocol: \u0026quot;4\u0026quot;, \u0026quot;5\u0026quot; (SOCKS) or \u0026quot;connect\u0026quot;（指定代理的类型）\r-x addr[:port] Specify proxy address and port（以 IP:port 的格式指定代理的位置。）\r-Z DCCP mode\r-z Zero-I/O mode [used for scanning]\rPort numbers can be individual or ranges: lo-hi [inclusive]\r-g \u0026lt;网关\u0026gt; # 设置路由器跃程通信网关，最多可设置8个。\r-G\u0026lt;指向器数目\u0026gt; # 设置来源路由指向器，其数值为4的倍数。\r-h 在线帮助。\r-i\u0026lt;延迟秒数\u0026gt; 设置时间间隔，以便传送信息及扫描通信端口。\r-l 使用监听模式，管控传入的资料。\r-n 直接使用IP地址，而不通过域名服务器。\r-o\u0026lt;输出文件\u0026gt; # 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。\r-p\u0026lt;通信端口\u0026gt; # 设置本地主机使用的通信端口。\r-r 乱数指定本地与远端主机的通信端口。\r-s\u0026lt;来源位址\u0026gt; # 设置本地主机送出数据包的IP地址。\r-u 使用UDP传输协议。\r-v 显示指令执行过程。\r-w\u0026lt;超时秒数\u0026gt; # 设置等待连线的时间。\r-z 使用0输入/输出模式，只在扫描通信端口时使用\r二、netcat的使用 渗透测试（端口扫描） nc -znv 127.0.0.1 1-1024 2\u0026gt;\u0026amp;1 | grep succeeded\r选项 -z\r意思是：开启“zero-I/O 模式”。该模式指的是：nc 只判断某个监听端口是否能连上，连上后【不】与对端进行数据通讯。\r选项 -n\r由于测试的是【IP 地址】，用该选项告诉 nc，【无须】进行域名（DNS）解析；\r反之，如果你要测试的主机是基于【域名】，就【不能】用“选项 -n”\r选项 -v\r-v 选项前面也聊过，这里要特地强调一下。\r对 nc 的其它用法，-v 选项是可加可不加滴；但对于“端口扫描”而言，一定要有这个选项——否则你【看不到】扫描结果\r2\u0026gt;\u0026amp;1 | grep succeeded\r过滤掉不成功的信息\r要判断某个主机的监听端口是否能连上 nc -nv 127.0.0.1 80 选项 -v\r如果你是 nc 的新手，建议总是带上这个选项——通过更详细的输出，能帮你搞明白状况。\r选项 -n\r由于测试的是【IP 地址】，用该选项告诉 nc，【无须】进行域名（DNS）解析；\r反之，如果你要测试的主机是基于【域名】，就【不能】用“选项 -n”\r选项 -w\r超时设置 在测试链接的时候，如果你没使用 -w 这个超时选项，默认情况下 nc 会等待很久，然后才告诉你连接失败。如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加“-w 选项”，设置一个比较小的超时值。在下面的例子中，超时值设为3秒。\rnc -nv -w 3 x.x.x.x xx\rUDP 通常情况下，要测试的端口都是 TCP 协议的端口；如果你碰到特殊情况，需要测试某个 UDP 的端口是否可达。nc 同样能胜任。只需要追加 -u 选项。\r3.监听服务器 nc -lv -port 7000\r4.传输文件 4.1 单个文件\n服务器\rnc -l -p 7000 \u0026gt; file2\r客户端\rnc 127.0.0.1 7000 \u0026lt; file1\r性能优势 用 nc 传输文件，相当于是：直接在【裸 TCP】层面传输。你可以通俗理解为：【没有】应用层。如果你传输的文件【超级大】或者文件数\r量【超级多】，用 nc 传输文件的性能优势会很明显（相比“FTP、SSH、共享目录…”而言）\r4.2 目录\n服务器\rnc -lv -p 7000 | tar xvf -\r客户端\rtar cvf - * | nc -nv 127.0.0.1 7000\r管道前面表示把当前目录的所有文件打包为 - 5. 网速吞吐量测试 服务器\rnc -nvv -l -p 7000 | pv\r客户端\rtime nc -n 127.0.0.1 7000 \u0026lt; /dev/zero\r-n是不要解析域名，避免解析域名造成时间误差\r其实上面两种方法都把建立连接的握手时间以及 TCP 窗口慢启动的时间给计算进去了，不是特别精确，最精确的方式是搭配 pv 命令（监控统计管道数据的速度）\r","id":8,"section":"categories","summary":"一、基本使用简介 usage: nc [-46CDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl] [-m minttl] [-O length] [-P proxy_username] [-p source_port] [-q seconds] [-s source] [-T keyword] [-V rtable] [-W recvlimit] [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]] [destination] [port] Command Summary: -4 Use IPv4 -6 Use IPv6 -b Allow broadcast -C Send CRLF as line-ending -D Enable the debug socket option -d Detach from stdin -F","tags":[" 网络"," "],"title":"netcat：一款网络测试的瑞士军刀","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/netcat/","year":"2023"},{"content":"vim常用指令 窗口命令 新建横向窗口\n:sp\r新建纵向窗口\n:vs\r切换窗口\nctrl+w w ctrl+w h j k l\rctrl+w t(左上) b(右下)\r窗口移动\nctrl+w H 最左端\rctrl+w L 最右端\rctrl+w J 最低端\rctrl+w K 最高端\rctrl+w r 顺时针\rctrl+w R 逆时针\rctrl+w x 左右上下对应位置的窗口 对调\r调整窗口高度\n:resize 20 | +20 | -20\r:vert resize 20 | +20 | -20\r关闭窗口\nctrl+w q(quit), c(close), o(other)\r目录浏览\n:He!(上分屏)\r:He(下分屏)\r:Ve!\r:Ve\rTab标签页 :Te (tab标签)\r:tabnew 增加一个标签\r:tabc 关闭当前的tab\r:tabo 关闭所有其他的tab\r:tabs 查看所有打开的tab :tabp 或gT 前一个\r:tabn 或gt 后一个 新建标签页\r:tabe 在新标签页中打开指定的文件。\r:tabnew 在新标签页中编辑新的文件。\r:tab split 在新标签页中，打开当前缓冲区中的文件。\r:tabf 允许你在当前目录搜索文件，并在新标签页中打开\rVim默认最多只能打开10个标签页。你可以用set tabpagemax=15改变这个限制。\r代码自动补全指令 当前项\nctrl+y 上一项\nctrl+p\r下一项\nctrl+n\r保持当前文字输入，并退出补全\nctrl+e\r终端命令 终端窗口\n:term bash\r:term (cmd)\r终端命令\n:!commond\reg:\r:!gcc -v\rneovim插件配置 前提: proxy网络代理 1.WSL1 nano ~/.bashrc\r###############PROXY####################\rexport WIN11_IP=127.0.0.1\rexport all_proxy=\u0026quot;socks5://${WIN11_IP}:7890\u0026quot;\r2.wsl2 nano ~/.bashrc\r###############PROXY####################\rexport WIN11_IP=$(cat /etc/resolv.conf |grep \u0026quot;nameserver\u0026quot; |cut -f 2 -d \u0026quot; \u0026quot;)\rexport all_proxy=\u0026quot;socks5://${WIN11_IP}:7890\u0026quot;\r3. VM nano ~/.bashrc\r###############PROXY####################\rexport WIN11_IP=windowsIP\rexport all_proxy=\u0026quot;socks5://${WIN11_IP}:7890\u0026quot;\r测试\ncurl www.google.com\r插件 1.packer.nvim ##下载插件\rgit clone --depth 1 https://github.com/wbthomason/packer.nvim\\\r~/.local/share/nvim/site/pack/packer/start/require(\u0026quot;plugins\u0026quot;).nvim\r修改~/.config/nvim/init.lua\nnvim ~/.config/nvim/init.lua\r添加\rrequire(\u0026quot;plugins\u0026quot;)\r修改~/.config/nvim/lua/plugins.lua\nnvim ~/.config/nvim/lua/plugins.lua\r添加如下内容\n-- This file can be loaded by calling `lua require('plugins')` from your init.vim\r-- Only required if you have packer configured as `opt`\rvim.cmd [[packadd packer.nvim]]\rreturn require('packer').startup(function(use)\r-- packer.nvim插件包管理\ruse 'wbthomason/packer.nvim'\rend)\rnvim打开任意文件，在command模式下输入(更新插件)\n:PackerSync\r2.air-line use {\r\u0026quot;vim-airline/vim-airline\u0026quot;,\rrequires = {\r\u0026quot;vim-airline/vim-airline-themes\u0026quot;,\r--综合图标支持such vim-airline lightline, vim-startify\r\u0026quot;ryanoasis/vim-devicons\u0026quot;\r}\r}\r3.主题 3.1 gruvbox gruvbox地址 -- gruvbox theme\ruse {\r\u0026quot;ellisonleao/gruvbox.nvim\u0026quot;,\rrequires = {\u0026quot;rktjmp/lush.nvim\u0026quot;}\r}\r4.nvim-tree use {\r'kyazdani42/nvim-tree.lua',\rrequires = 'kyazdani42/nvim-web-devicons'\r}\r5.bufferline -- bufferline\ruse {'akinsho/bufferline.nvim', requires = 'kyazdani42/nvim-web-devicons'}\r","id":9,"section":"categories","summary":"vim常用指令 窗口命令 新建横向窗口 :sp 新建纵向窗口 :vs 切换窗口 ctrl+w w ctrl+w h j k l ctrl+w t(左上) b(右下) 窗口移动 ctrl+w H 最左端 ctrl+w L 最右端 ctrl+w J 最低端 ctrl+w K 最高","tags":[" vim"],"title":"neovim：一款vim的编辑器","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/neovim/","year":"2022"},{"content":"ros2命令 ros2 pkg 创建功能包 # cpp\rros2 pkg create --dependencies rclcpp std_msgs --build-type ament_cmake [pkg name]\r# python\rros2 pkg create --dependencies rclpy std_msgs --build-type ament_python [pkg name]\rcolcon\u0026ndash;编译 #下载依赖\rrosdep install -y --from-paths src --rosdistro $ROS_DISTRO\rcolcon build --symlink-install ------------------\r--symlink-install : build目录中库文件软连接到install目录\r--cmake-args： cmake编译\r--packages-select： 制定编译某个包\r--parallel-workers （NUMBER）：要并行处理的最大作业数， 默认值是逻辑 CPU 内核数\rros2模板范式 cpp 1. ament_cmake set\n#生成compile_command.json\rset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\r#c编译器\rset(CMAKE_C_COMPILER \u0026quot;/usr/bin/clang\u0026quot;)\r#cpp编译器\rset(CMAKE_CXX_COMPILER \u0026quot;/usr/bin/clang++\u0026quot;)\rset(CMAKE_CXX_FLAGS \u0026quot;${CMAKE_CXX_FLAGS} -std=c++11 -Wall -Werror\u0026quot;)\r固定范式\nfind_package(ament_cmake REQUIRED)\rfind_package(rclcpp REQUIRED)\rfind_package(std_msgs REQUIRED)\raux_source_directory(src SRC_LIST)\radd_executable(${PROJECT_NAME} ${SRC_LIST} )\rament_target_dependencies(${PROJECT_NAME} rclcpp std_msgs)\r安装\n目录\rinstall( DIRECTORY XX DESTINATION XX)\r可执行文件\rinstall(TARGETS ${PROJECT_NAME} DESTINATION lib/${PROJECT_NAME})\rpython ","id":10,"section":"categories","summary":"ros2命令 ros2 pkg 创建功能包 # cpp ros2 pkg create --dependencies rclcpp std_msgs --build-type ament_cmake [pkg name] # python ros2 pkg create --dependencies rclpy std_msgs --build-type ament_python [pkg name] colcon\u0026ndash;编译 #下载依赖 rosdep install -y --from-paths src --rosdistro $ROS_DISTRO colcon build --symlink-install ------------------ --symlink-install :","tags":[" robot","ros2 "],"title":"ros2:命令的使用","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robot/ros2%E7%9A%84%E4%BD%BF%E7%94%A8/","year":"2022"},{"content":"常用的package包安装 matplotlib matlab 图形包\nconda install matplotlib\rnumpy Numeric Python。 它是一个由多维数组对象和用于处理数组的例程集合组成的库。\nconda install numpy\rSciPy Scientific Python。SciPy 是一个开源的 Python 算法库和数学工具包。SciPy 包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。\nconda install scipy\rpandas Pandas 是一个开源的第三方 Python 库，从 Numpy 和 Matplotlib 的基础上构建而来，享有数据分析“三剑客之一”的盛名（NumPy、Matplotlib、Pandas）。Pandas 已经成为 Python 数据分析的必备高级工具，它的目标是成为强大、灵活、可以支持任何编程语言的数据分析工具。\nPandas 这个名字来源于面板数据（Panel Data）与数据分析（data analysis）这两个名词的组合。\nconda install pandas\rcontrol 控制原理库\nconda install -c conda-forge control\r","id":11,"section":"categories","summary":"常用的package包安装 matplotlib matlab 图形包 conda install matplotlib numpy Numeric Python。 它是一个由多维数组对象和用于处理数组的例程集合组成的库。 conda install numpy SciPy Scientific Python。","tags":[" python"],"title":"一些常用的package包安装","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/python/package/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84package%E5%8C%85%E5%AE%89%E8%A3%85/","year":"2022"},{"content":"安装anaconda 1.环境配置 D:\\[Anaconda]\\ D:\\Anaconda\\Scripts D:\\Anaconda\\Library\\bin D:\\Anaconda\\Library\\mingw-w64\\bin（可选）\r2. 换源 打开C:\\Users\\Geton.condarc\nchannels:\r- defaults\rshow_channel_urls: true\rdefault_channels:\r- http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\r- http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\r- http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\rcustom_channels:\rconda-forge: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\rmsys2: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\rbioconda: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\rmenpo: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\rpytorch: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\rsimpleitk: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\r3.创建新的虚拟环境 conda create -p path python=3.10\r","id":12,"section":"categories","summary":"安装anaconda 1.环境配置 D:\\[Anaconda]\\ D:\\Anaconda\\Scripts D:\\Anaconda\\Library\\bin D:\\Anaconda\\Library\\mingw-w64\\bin（可选） 2. 换源 打开C:\\Users\\","tags":[" python"],"title":"如何安装anaconda","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/python/anaconda/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85anaconda/","year":"2022"},{"content":"一、.vscode的配置 1. c_cpp_properties.json ctrl+shift+p ,运行C/Cpp: Edit configurations...\n{\r\u0026quot;configurations\u0026quot;: [\r{\r\u0026quot;name\u0026quot;: \u0026quot;linux\u0026quot;,\r\u0026quot;includePath\u0026quot;: [\r\u0026quot;/opt/ros/melodic/include\u0026quot;,\r\u0026quot;/usr/include\u0026quot;,\r\u0026quot;${workspaceFolder}/**\u0026quot;,\r\u0026quot;${workspaceFolder}/devel/include\u0026quot;\r],\r\u0026quot;intelliSenseMode\u0026quot;: \u0026quot;linux-gcc-x64\u0026quot;,\r\u0026quot;compilerPath\u0026quot;: \u0026quot;/usr/bin/gcc\u0026quot;,\r\u0026quot;cppStandard\u0026quot;: \u0026quot;c++17\u0026quot;,\r\u0026quot;cStandard\u0026quot;: \u0026quot;c17\u0026quot;\r}\r],\r\u0026quot;version\u0026quot;: 4\r}\r2. tasks.json ctrl+shift+p ,运行task\n{\r// See https://go.microsoft.com/fwlink/?LinkId=733558\r// for the documentation about the tasks.json format\r\u0026quot;version\u0026quot;: \u0026quot;2.0.0\u0026quot;,\r\u0026quot;tasks\u0026quot;: [\r/*1. mkdir build*/\r{\r\u0026quot;label\u0026quot;: \u0026quot;mkdir build\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;shell\u0026quot;,\r\u0026quot;command\u0026quot;: \u0026quot;mkdir\u0026quot;,\r\u0026quot;args\u0026quot;: [\r\u0026quot;-p\u0026quot;,\r\u0026quot;build\u0026quot;\r],\r\u0026quot;options\u0026quot;: {\u0026quot;cwd\u0026quot;: \u0026quot;${workspaceFolder}\u0026quot;},\r\u0026quot;group\u0026quot;: \u0026quot;build\u0026quot;,\r},\r/*2. cmake ..*/\r{\r\u0026quot;label\u0026quot;: \u0026quot;cmake ..\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;shell\u0026quot;,\r\u0026quot;command\u0026quot;: \u0026quot;cmake\u0026quot;,\r\u0026quot;args\u0026quot;: [\r\u0026quot;..\u0026quot;\r],\r\u0026quot;options\u0026quot;: {\r\u0026quot;cwd\u0026quot;: \u0026quot;${workspaceFolder}/build\u0026quot;,\r},\r\u0026quot;group\u0026quot;: \u0026quot;build\u0026quot;,\r\u0026quot;dependsOn\u0026quot;:[\r\u0026quot;mkdir build\u0026quot;,//表示在\u0026quot;创建build\u0026quot;任务结束后进行\r]\r},\r/*3. make */\r{\r\u0026quot;label\u0026quot;: \u0026quot;make\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;shell\u0026quot;,\r\u0026quot;command\u0026quot;: \u0026quot;make\u0026quot;,\r\u0026quot;args\u0026quot;: [\r\u0026quot;\u0026quot;\r],\r\u0026quot;group\u0026quot;: \u0026quot;build\u0026quot;,\r\u0026quot;dependsOn\u0026quot;:[\r\u0026quot;cmake ..\u0026quot;,//表示在\u0026quot;创建build\u0026quot;任务结束后进行\r],\r\u0026quot;presentation\u0026quot;: {//配置用于显示任务输出并读取其输入的面板\r\u0026quot;echo\u0026quot;: true,\r\u0026quot;reveal\u0026quot;: \u0026quot;never\u0026quot;,\r\u0026quot;focus\u0026quot;: false,\r\u0026quot;panel\u0026quot;: \u0026quot;shared\u0026quot;,\r\u0026quot;showReuseMessage\u0026quot;: true,\r\u0026quot;clear\u0026quot;: false\r},\r\u0026quot;options\u0026quot;: {\u0026quot;cwd\u0026quot;: \u0026quot;${workspaceFolder}/build\u0026quot;},\r}\r]\r}\r预定义变量名字\n${workspaceFolder} - 当前工作目录(根目录)\r${workspaceFolderBasename} - 当前文件的父目录\r${file} - 当前打开的文件名(完整路径)\r${relativeFile} - 当前根目录到当前打开文件的相对路径(包括文件名)\r${relativeFileDirname} - 当前根目录到当前打开文件的相对路径(不包括文件名)\r${fileBasename} - 当前打开的文件名(包括扩展名)\r${fileBasenameNoExtension} - 当前打开的文件名(不包括扩展名)\r${fileDirname} - 当前打开文件的目录\r${fileExtname} - 当前打开文件的扩展名\r${cwd} - 启动时task工作的目录\r${lineNumber} - 当前激活文件所选行\r${selectedText} - 当前激活文件中所选择的文本\r${execPath} - vscode执行文件所在的目录\r${defaultBuildTask} - 默认编译任务(build task)的名字\r3.快捷键 vs code 的常用快捷键 1、注释：\na) 单行注释：[ctrl+k,ctrl+c] 或 ctrl+/\nb) 取消单行注释：[ctrl+k,ctrl+u] (按下ctrl不放，再按k + u)\nc) 多行注释：[alt+shift+A]\nd) 多行注释：/**\n2、移动行：alt+up/down\n3、显示/隐藏左侧目录栏 ctrl + b\n4、复制当前行：shift + alt +up/down\n5、删除当前行：shift + ctrl + k\n6、控制台终端显示与隐藏：ctrl + ~\n7、查找文件/安装vs code 插件地址：ctrl + p\n8、代码格式化：shift + alt +f\n9、新建一个窗口 : ctrl + shift + n\n10、行增加缩进: ctrl + [\n11、行减少缩进: ctrl + ]\n12、裁剪尾随空格(去掉一行的末尾那些没用的空格) : ctrl + shift + x\n13、字体放大/缩小: ctrl + ( + 或 - )\n14、拆分编辑器 : ctrl + 1/2/3\n15、切换窗口 : ctrl + shift + left/right\n16、关闭编辑器窗口 : ctrl + w\n17、关闭所有窗口 : ctrl + k + w\n18、切换全屏 : F11\n19、自动换行 : alt + z\n20、显示git : ctrl + shift + g\n**21、全局查找文件：**ctrl + shift + f\n22、显示相关插件的命令(如：git log)：ctrl + shift + p\n23、选中文字：shift + left / right / up / down\n24、折叠代码： ctrl + k + 0-9 (0是完全折叠)\n25、展开代码： ctrl + k + j (完全展开代码)\n26、删除行 ： ctrl + shift + k\n27、快速切换主题：ctrl + k / ctrl + t\n28、快速回到顶部 ： ctrl + home\n29、快速回到底部 : ctrl + end\n30、格式化选定代码 ：ctrl + k / ctrl +f\n31、选中代码 ： shift + 鼠标左键\n**32、多行同时添加内容（光标） ：**ctrl + alt + up/down\n**33、全局替换：**ctrl + shift + h\n**34、当前文件替换：**ctrl + h\n**35、打开最近打开的文件：**ctrl + r\n**36、打开新的命令窗：**ctrl + shift + c\nvs code 的常用插件 1、Auto Rename Tag 修改html标签，自动帮你完成尾部闭合标签的同步修改，和webstorm一样。\n2、Auto Close Tag 自动闭合HTML标签\n4、Beautiful 格式化代码的工具\n5、Dash Dash是MacOS的API文档浏览器和代码段管理器\n6、Ejs Snippets ejs 代码提示\n7、ESLint 检查javascript语法错误与提示\n8、File Navigator 快速查找文件\n9、Git History(git log) 查看git log\n10、Gulp Snippets 写gulp时用到，gulp语法提示。\n11、HTML CSS Support 在HTML标签上写class智能提示当前项目所支持的样式\n12、HTML Snippets 超级好用且初级的H5代码片段以及提示\n13、Debug for Chrome 让vs code映射chrome的debug功能，静态页面都可以用vscode来打断点调试、配饰稍微复杂一点\n14、Document this Js的注释模板\n15、jQuery Code Snippets jquery提示工具\n16、Html2jade html模板转pug模板\n17、JS-CSS-HTML Formatter 格式化\n18、Npm intellisense require 时的包提示工具\n19、Open in browser 打开默认浏览器\n20、One Dark Theme 一个vs code的主题\n21、Path Intellisense 自动路径补全、默认不带这个功能\n22、Project Manager 多个项目之间快速切换的工具\n23、Pug(Jade) snippets pug语法提示\n24、React Components 根据文件名创建反应组件代码。\n25、React Native Tools reactNative工具类为React Native项目提供了开发环境。\n26、Stylelint css/sass代码审查\n27、Typings auto installer 安装vscode 的代码提示依赖库，基于typtings的\n28、View In Browser 默认浏览器查看HTML文件（快捷键Ctrl+F1可以修改）\n29、Vscode-icons 让vscode资源目录加上图标、必备\n30、VueHelper Vue2代码段（包括Vue2 api、vue-router2、vuex2）\n31、Vue 2 Snippets vue必备vue代码提示\n32、Vue-color vue语法高亮主题\n33、Auto-Open Markdown Preview markdown文件自动开启预览\n34、EverMonkey 印象笔记\n35、atom one dark atom的一个高亮主题(个人推荐)\n三、常用的电脑快捷键\n1、ctrl + shift + delete 快速清除浏览器缓存\n2、ctrl + alt + delete 快速进入任务管理器页面\n3、window + L 快速锁定电脑\n4、window + d 所有窗口最小化\n5、 window + e 打开我的资源管理器(我的电脑)\n6、 window + f 快速打开搜索窗口\n7、 alt + tab 快速查看打开的应用与窗口\n二、离线使用remote ssh 参考链接\nVS Code Server的离线安装过程 - 知乎 (zhihu.com)\n准备工作 1 确定vscode的commit id\n点击帮助\u0026ndash;\u0026gt;关于\n2 观察并记录commit id 号\n版本: 1.67.0 (system setup) 提交: 57fd6d0195bb9b9d1b49f6da5db789060795de47 日期: 2022-05-04T12:06:02.889Z Electron: 17.4.1 Chromium: 98.0.4758.141 Node.js: 16.13.0 V8: 9.8.177.13-electron.0 OS: Windows_NT x64 10.0.19044\n3 下载远程连接机器的安装包\n用2中的内容替换${commit id}\r#arm64\rhttps://update.code.visualstudio.com/commit:${commit id}/server-linux-arm64/stable\r#x64\rhttps://update.code.visualstudio.com/commit:${commit id}/server-linux-x64/stable\r#armhf\rhttps://update.code.visualstudio.com/commit:${commit id}/server-linux-armhf/stable\r安装工作 1 进入要连接的机器上，创建文件夹\nmkdir -p $HOME/.vscode-server/bin\r2 将下载包拷贝进$HOME/.vscode-server/bin目录下\n3 解压\ncd $HOME/.vscode-server/bin\rtar -zxvf vscode-server-linux-armhf.tar.gz\rrm -rf vscode-server-linux-armhf.tar.gz\r4 重命名\nmv vscode-server-linux-armhf ${commit id}\r替换为具体的id\rmv vscode-server-linux-armhf 57fd6d0195bb9b9d1b49f6da5db789060795de47\r5 改权限\ncd $HOME/.vscode-server/bin\rchmod -R 775 ${commit id}\r即\rchmod -R 775 57fd6d0195bb9b9d1b49f6da5db789060795de47\r6 连接\n使用vscode远程连接\nother 如果需要插件，找到一个类似的机器，在上面联网安装，安装后的插件在$HOME/.vscode-server/extensions下，直接打包拷贝到离线机器人相同目录就可以了。\n用win上的拷贝也可以\n三、clangd\u0026ndash;智能提示 以ubuntu为例，需要先在ubuntu中安装\nsudo apt install llvm clangd lldb\rclang：前端编译器，将二进制码转换为IR码\nllvm：后端虚拟机，将IR码转换为机器码\nclangd：语言服务器的一种\nlldb：调试器\n再在打开vscode，下载两款插件 clangd 和 codelldb\n3.1 clangd 代码自动补全 clangd插件会自动提示你安装clangd\n生成compile_commands.json\n普通cmake编译：CMakeLists.txt\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\nROS编译指令：catkin_make -DCMAKE_EXPORT_COMPILE_COMMANDS=1\n3.2 codeLLDB代码调试 其中CodeLLDB可能会下载不成功，可以从vsix安装\n四、vscode-icons\u0026ndash;图标显示 五、NeoVim\u0026ndash;编辑器 在wsl中下载neovim\nsudo apt install neovim\r修改neovim插件的配置\n","id":13,"section":"categories","summary":"一、.vscode的配置 1. c_cpp_properties.json ctrl+shift+p ,运行C/Cpp: Edit configurations... { \u0026quot;configurations\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;linux\u0026quot;, \u0026quot;includePath\u0026quot;: [ \u0026quot;/opt/ros/melodic/include\u0026quot;, \u0026quot;/usr/include\u0026quot;, \u0026quot;${workspaceFolder}/**\u0026quot;, \u0026quot;${workspaceFolder}/devel/include\u0026quot; ], \u0026quot;intelliSenseMode\u0026quot;: \u0026quot;linux-gcc-x64\u0026quot;, \u0026quot;compilerPath\u0026quot;: \u0026quot;/usr/bin/gcc\u0026quot;, \u0026quot;cppStandard\u0026quot;: \u0026quot;c++17\u0026quot;, \u0026quot;cStandard\u0026quot;: \u0026quot;c17\u0026quot; } ], \u0026quot;version\u0026quot;: 4 } 2. tasks.json ctrl+shift+p ,运行task { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation","tags":[" vscode"],"title":"VScode：一款多插件多功能的编辑器","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/vscode/","year":"2022"},{"content":"GIT 一、git 流程图 二、gitflow 参考文档：\n图解git flow开发流程 - 知乎 (zhihu.com)\n三、git指令 1 分支操作 1查看 //查看本地所有分支 git branch //查看远程所有分支\rgit branch -r //查看本地和远程的所有分支\rgit branch -a 2新建\r//新建分支\rgit branch 本地分支名\r//新建一个本地分支并切换到该分支\rgit checkout -b 本地分支名\r3删除\r//删除本地分支\rgit branch -d \u0026lt;branchname\u0026gt; //删除远程分支\rgit push origin :XXX 4重命名\r//重命名本地分支\rgit branch -m \u0026lt;oldbranch\u0026gt; \u0026lt;newbranch\u0026gt; 5关联远程\r//本地分支与远程分支建立关联\rgit branch -u origin/分支名 git branch --set-upstream-to=origin/sit-basic-v1.0.1\r//撤销本地分支与远程分支的关系\rgit branch --unset-upstream\r//查看本地分支与远程分支的映射关系\rgit branch -vv\r6合并分支\r//切换到master分支\rgit checkout master\r//将develop分支合并到master分支\rgit merge develop\r2 fetch+merge操作 //拉取远程分支\rgit fetch origin\rgit fetch origin master\r//冲突查看\rgit log -p FETCH_HEAD\r//将拉取下来的最新内容合并到当前所在的分支中\rgit merge FETCH_HEAD git merge [远程主机名]/[branch] --allow-unrelated-histories\r3 push操作 git push \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt;\r4 remote操作 1.查看当前仓库\rgit remote -v\r2.新增远程仓库\rgit remote add [name] [url]\r3.删除远程仓库\rgit remote remove [name]\r4.修改远端仓库地址\rgit remote set-url [have_a_name] [url]\r5.修改远端仓库名字\rgit remote rename \u0026lt;old_name\u0026gt; \u0026lt;new_name\u0026gt;\r6.同步本地仓库与远程仓库的分支\r//场景：有些分支在远程其实早就被删除了，但是在你本地依然可以看见这些被删除的分支\rgit remote prune [远程仓库名]\r","id":14,"section":"categories","summary":"GIT 一、git 流程图 二、gitflow 参考文档： 图解git flow开发流程 - 知乎 (zhihu.com) 三、git指令 1 分支操作 1查看 //查看本地所有分支 git branch //查","tags":[" git"],"title":"git：日常用法","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/git/","year":"2022"},{"content":"一、docker安装 Docker 官方文档 | Docker Documentation\n1.自动安装 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; sudo bash fishros\r2.手动安装 2.1. ubuntu安装 1.系统需求 Ubuntu Jammy 22.04 (LTS) Ubuntu Impish 21.10 Ubuntu Focal 20.04 (LTS) Ubuntu Bionic 18.04 (LTS) Docker Engine is supported on x86_64 (or amd64), armhf, arm64, and s390x architectures.\n2.卸载旧版本 sudo apt-get remove docker docker-engine docker.io containerd runc\r3.使用仓库安装(也可以使用二进制包安装) sudo apt-get update\rsudo apt-get install \\\rca-certificates \\\rcurl \\\rgnupg \\\rlsb-release\r4.添加 GPG key curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\r5.添加docker源 echo \\\r\u0026quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\\r$(lsb_release -cs) stable\u0026quot; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null\r安装 Docker Engine #安装最新docker\rsudo apt-get update\rsudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\r#安装指定版本\rapt-cache madison docker-ce\rudo apt-get install docker-ce=\u0026lt;VERSION_STRING\u0026gt; docker-ce-cli=\u0026lt;VERSION_STRING\u0026gt; containerd.io docker-compose-plugin\r7.测试 docker version\rsudo docker run hello-world\r8.卸载 Docker Engine🔗 //1.Uninstall the Docker Engine, CLI, Containerd, and Docker Compose packages:\rsudo apt-get purge docker-ce docker-ce-cli containerd.io docker-compose-plugin\r//2.Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:\rsudo rm -rf /var/lib/docker\rsudo rm -rf /var/lib/containerd\r3.docker镜像元 轻量应用服务器 安装 Docker 并配置镜像加速源-最佳实践-文档中心-腾讯云-腾讯云 (tencent.com)\n二、docker常用命令 1.命令图 2.docker run流程 3.docker 命令 3.1 帮助命令 sudo docker version #显示docker版本信息\rsudo docker info #显示docker系统信息，包括镜像和容器的数量\rdocker 命令 --help\r3.2 镜像命令 查看所有镜像 sudo docker images -a\r搜索镜像 //搜索stars数量大于500的镜像\rsudo docker search [镜像名] --filter=STARS=500\r下载镜像 sudo docker pull [镜像名]\rsudo docker pull [镜像名]:[版本名]\r删除镜像 sudo docker rmi -f [镜像ID]\r3.3 容器命令 新建容器并启动 sudo docker run [可选参数] [镜像名]\r#参数说明\r--name='name' 容器的名字\r-d\t后台交互运行\r-it 使用交互方式运行，进入容器查看内容\r-P\t指定容器的端口 -P 8080:8080\r-p\t随机指定端口\r//启动并进入容器\rsudo docker run -it [镜像名] /bin/bash\r//退出容器\rexit #直接容器停止并退出\rctrl+p+q #容器不停止，退出\r列出容器 //列出所有正在运行中的容器\rsudo docker ps\r//列出所有正在运行中的容器+历史记录\rsudo docker ps -a\r//列出最近创建的前number个的容器\rsudo docker ps -a -n=number\r删除容器 //删除停止运行的容器\rsudo docker rm [容器id]\r//删除正在运行的容器\rsudo docker rm -f [容器id]\r//删除所有容器\rsudo docker rm -f $(docker ps -aq)\r启动和停止容器 //启动容器\rsudo docker start [容器ID]\r//重启容器\rsudo docker restart [容器ID]\r//停止当前正在运行的容器\rsudo docker stop [容器ID]\r//强制停止容器\rsudo docker kill [容器ID]\r3.4 常用的其他命令 日志信息 sudo docker logs [容器ID ]\r容器进程信息 sudo docker top [容器ID ]\r容器元数据 sudo docker inspect [容器ID] 进入正在运行的容器 //进入容器后开启一个新的终端\rsudo docker exec -it [容器ID] /bin/bash\r//进入容器执行的当前终端\rsudo docker attach [容器ID] copy[容器文件copy到linux系统] sudo docker cp [容器ID]:/home/chao/demo.txt /home/chao\r","id":15,"section":"categories","summary":"一、docker安装 Docker 官方文档 | Docker Documentation 1.自动安装 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; sudo bash fishros 2.手动安装 2.1. ubuntu安装 1.系统需求 Ubuntu Jammy 22.04 (LTS) Ubuntu Impish 21.10 Ubuntu Focal 20.04 (LTS) Ubuntu Bionic 18.04 (LTS) Docker Engine","tags":[" docker"],"title":"Docker：一个环境打包的容器","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/docker/","year":"2022"},{"content":"Mount挂载 mount网络挂载 1 win10上新建一个文件夹 修改属性，设置共享\n如果不确定win10的用户名和密码，就新建一个本地用户\n2 linux挂载命令 查看当前linux用户id\nid 挂载\nsudo mount -t cifs -o username=chao2,password=88888888zc! -o rw,uid=1000,gid=1000 //192.168.209.1/shrae_file /home/chao/Desktop/mountpoint\r3 other windows的cifs的端口是445\n端口映射\r树莓派(车体控制)\rsudo iptables -t nat -I PREROUTING -p tcp --dport 445 -j DNAT --to-destination 192.168.8.50:445\rsudo iptables -t nat -I POSTROUTING -p tcp -d 192.168.8.50/24 --dport 445 -j SNAT --to-source 192.168.8.101\rros(导航)\rsudo mount -t cifs -o username=chao2,password=88888888zc! -o rw,uid=1000,gid=1000 //192.168.20.3/shrae_file /home/ubuntu/mount\r","id":16,"section":"categories","summary":"Mount挂载 mount网络挂载 1 win10上新建一个文件夹 修改属性，设置共享 如果不确定win10的用户名和密码，就新建一个本地用户 2 lin","tags":["linux"," tool"],"title":"Mount：网络文件夹挂载","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/mount%E6%8C%82%E8%BD%BD/","year":"2022"},{"content":"netfilter 相关网址 官网：netfilter/iptables project homepage\niptables基础知识详解_LarryHai6的博客-CSDN博客_iptables\n使用iptables进行端口转发 - 云+社区 - 腾讯云 (tencent.com)\n原理图 iptables 1. 原理叙述 iptables具有Filter, NAT, Mangle, Raw四种内建表：\n1. Filter表\nFilter表示iptables的默认表，因此如果你没有自定义表，那么就默认使用filter表，它具有以下三种内建链：\nINPUT链 – 处理来自外部的数据。 OUTPUT链 – 处理向外发送的数据。 FORWARD链 – 将数据转发到本机的其他网卡设备上。 2. NAT表\nNAT表有三种内建链：\nPREROUTING链 – 处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标IP地址（destination ip address），通常用于DNAT(destination NAT)。 POSTROUTING链 – 处理即将离开本机的数据包。它会转换数据包中的源IP地址（source ip address），通常用于SNAT（source NAT）。 OUTPUT链 – 处理本机产生的数据包。 3. Mangle表\nMangle表用于指定如何处理数据包。它能改变TCP头中的QoS位。Mangle表具有5个内建链：\nPREROUTING OUTPUT FORWARD INPUT POSTROUTING 4. Raw表\nRaw表用于处理异常，它具有2个内建链：\nPREROUTING chain OUTPUT chain 2. 命令使用 显示表内容\nsudo iptables -t filter –L num – 指定链中的规则编号 target – 前面提到的target的特殊值 ACCEPT – 允许防火墙接收数据包 DROP – 防火墙丢弃包 QUEUE – 防火墙将数据包移交到用户空间 RETURN – 防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain)中。 prot – 协议：tcp, udp, icmp等 source – 数据包的源IP地址 destination – 数据包的目标IP地址 清空表\niptables -t NAT -F\r添加规则\niptables -t 表名 \u0026lt;-A/I/D/R\u0026gt; 规则链名 [规则号] \u0026lt;-i/o 网卡名\u0026gt; -p 协议名 \u0026lt;-s 源IP/源子网\u0026gt; --sport 源端口 \u0026lt;-d 目标IP/目标子网\u0026gt; --dport 目标端口 -j 动作\r3. 特定场景 端口映射 sudo nano /etc/sysctl.conf\rnet.ipv4.ip_forward=0 改为 net.ipv4.ip_forward=1\r生效\rsudo sysctl -p\r添加规则\niptables -t nat -A PREROUTING -p tcp --dport [端口号] -j DNAT --to-destination [目标IP]\riptables -t nat -A PREROUTING -p udp --dport [端口号] -j DNAT --to-destination [目标IP]\riptables -t nat -A POSTROUTING -p tcp -d [目标IP] --dport [端口号] -j SNAT --to-source [本地服务器IP]\riptables -t nat -A POSTROUTING -p udp -d [目标IP] --dport [端口号] -j SNAT --to-source [本地服务器IP]\r将本地(内网:192.168.20.3 外网:192.168.8.101)10022端口映射到192.168.20.2:22\rsudo iptables -t nat -I PREROUTING -p tcp --dport 10022 -j DNAT --to-destination 192.168.20.2:22\rsudo iptables -t nat -I PREROUTING -p udp --dport 10022 -j DNAT --to-destination 192.168.20.2:22\rsudo iptables -t nat -I POSTROUTING -p tcp -d 192.168.20.2/24 --dport 22 -j SNAT --to-source 192.168.20.3\rsudo iptables -t nat -I POSTROUTING -p udp -d 192.168.20.2/24 --dport 22 -j SNAT --to-source 192.168.20.3\r保存生效\nservice iptables save\rservice iptables restart\r永久保存\n首先安装iptables-persistent工具 sudo apt install iptables-persistent\r每当设置了新的iptables规则后，使用如下命令保存规则即可，规则会根据ipv4和ipv6分别保存在了/etc/iptables/rules.v4和/etc/iptables/rules.v6文件中。 sudo netfilter-persistent save\r由于 ipt­a­bles-per­sis­tent 在安装时已经把它作为一个服务设置为开机启动了，它在开机后会自动加载已经保存的规则，所以也就达到了永久保存的目的。其实原理和第一种方法是类似的，只是设置起来会更简单一些。\n","id":17,"section":"categories","summary":"netfilter 相关网址 官网：netfilter/iptables project homepage iptables基础知识详解_LarryHai6的博客-CSDN博客_iptable","tags":[" linux","net","tool"],"title":"Netfilter：iptable的使用","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/netfilter/","year":"2022"},{"content":"内网穿透 1. frp解决方案 1.1 下载 wget https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_linux_arm.tar.gz\rtar -zxvf frp_0.42.0_linux_arm.tar.gz\r1.2 server配置 ​\tnote：联塑项目：车体控制程序是服务端\n进入程序目录\ncd frp_0.42.0_linux_arm\r图中红线部分是server程序及其配置文件\n修改权限\nchmod 755 frpc frps\r配置文件\nnano frps.ini\r写入如下内容\n[common]\rbind_port = 7000\r1.3 client配置 note：联塑项目：ros是客户端\n进入程序目录\ncd frp_0.42.0_linux_arm\r修改权限\nchmod 755 frpc frps\r图中红线部分是client程序及其配置文件\n配置文件\nnano frpc.ini\r写入如下内容\n[common]\rserver_addr = 192.168.8.147\rserver_port = 7000\r[ssh]\rtype = tcp\rlocal_ip = 192.168.100.10\rlocal_port = 22\rremote_port = 10022\r1.4 测试 打开server端，即车体控制程序板子 ./frps\r打开client端，即ros程序板子 ./frpc\r打开本地电脑终端 ssh -oPort=10022 pi@192.168.8.147\r1.5 开机自启动 树莓派 sudo nano /etc/rc.local\r在\u0026quot;exit 0\u0026quot;前添加脚本\rsu pi -c \u0026quot;bash ~/start/Mystart.sh \u0026amp;\u0026quot;\r创建脚本\nmkdir $HOME/start \u0026amp;\u0026amp; cd $HOME/start \u0026amp;\u0026amp; touch Mystart.sh\rchmod 755 Mystart.sh\r脚本内容\n#!/bin/bash\rsu pi -c \u0026quot;exec ~/frp/frps \u0026gt;/dev/null \u0026amp;\u0026quot;\rubuntu cd /etc/init.d \u0026amp;\u0026amp; sudo nano Mystart.sh\r脚本内容\n#!/bin/bash\rsu ubuntu -c \u0026quot;exec ~/frp/frpc \u0026gt;/dev/null \u0026amp;\u0026quot;\r给与启动权限\nsudo chmod 775 Mystart.sh\rsudo update-rc.d Mystart.sh defaults 90\r删除启动权限\nsudo update-rc.d -f Mystart.sh remove\r","id":18,"section":"categories","summary":"内网穿透 1. frp解决方案 1.1 下载 wget https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_linux_arm.tar.gz tar -zxvf frp_0.42.0_linux_arm.tar.gz 1.2 server配置 ​ note：联塑项目：车体控制程序是服务端 进入程序目录 cd frp_0.42.0_linux_arm 图中红线部分是serve","tags":[" linux","tool"],"title":"内网穿透","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/linux/app/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","year":"2022"},{"content":"ros编程 1.topic 1.1 topic_pulisher程序实现四个步骤 1.2 topic_subscriber程序实现四个步骤 note：保证回调函数中处理不能太长\n1.3 话题消息的定义与使用 - \u0026mdash;\u0026ndash;\u0026gt;定义 #在功能包src/package/,创建msg文件夹\rmkdir msg\r#编写msg/*.msg\r#打开package.xml，添加动态生成程序的依赖\r\u0026lt;build_depend\u0026gt;message_generation\u0026lt;/build_depend\u0026gt;\r\u0026lt;exec_depend\u0026gt;message_runtime\u0026lt;/exec_depend\u0026gt;\r#CMakeLists.txt添加编译选项\rfind_package(..... message_generation)\radd_message_files(FILES person.msg)\rgenerate_messages(DEPENDENCIES std_msgs)#person.msg依赖那些库\rcatkin_package(CATKIN_DEPENDS ... message_runtime)\r\u0026mdash;\u0026mdash;-\u0026gt;使用：订阅自定义的消息 ROS订阅自定义消息_plokm789456的博客-CSDN博客\n1.package.xml custom_pack_name需要修改成发布消息的包名称。\n\u0026lt;depend\u0026gt;custom_pack_name\u0026lt;/depend\u0026gt;\r2.修改CMakeLists.txt,在find_package中添加声明，其中publish_pack_name为发布消息的包的名称,其中new_pack_name为需要订阅消息的包名。\nfind_package(catkin REQUIRED COMPONENTS\rroscpp\rrospy\rpublish_pack_name\r)\radd_dependencies(new_pack_name publish_pack_name_generate_messages_cpp)\r1.4 ros内置消息类型\u0026ndash;std_msgs\n详解常用的ROS内置消息类型\n","id":19,"section":"categories","summary":"ros编程 1.topic 1.1 topic_pulisher程序实现四个步骤 1.2 topic_subscriber程序实现四个步骤 note：保证回调函数中处理不能","tags":["robat"," ros"],"title":"ros编程","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robot/5_ros%E7%BC%96%E7%A8%8B/","year":"2022"},{"content":"WiringPi 安装 WiringPi\n官网介绍截取 WiringPi is a PIN based GPIO access library written in C for the BCM2835, BCM2836 and BCM2837 SoC devices used in all Raspberry Pi. versions. The source code is not publicly available but may be made available to those who wish commercial support.\nIt’s designed to be familiar to people who have used the Arduino “wiring” system1 and is intended for use by experienced C/C++ programmers. It is not a newbie learning tool.\nWiringPi is developed directly on a Raspberry Pi running 32-bit Raspbian.I do not support any other platform, cross compiling or operating systems.\nRaspberry Pi | Wiring | Download \u0026amp; Install | Wiring Pi\nnote:如果官网地址打不开，直接下载github中的下载包\ninstall wget https://github.com/WiringPi/WiringPi/archive/refs/tags/2.61-1.tar.gz\rtar zxvf 2.61-1.tar.gz cd WiringPi-2.61-1/\r./build\rOK\rtest gpio -v\rgpio readall\rwiringpi API 参考博客\n树莓派wiringPi库详解 - lulipro - 博客园 (cnblogs.com)\n树莓派WiringPi常用函数中文手册-Arduino中文社区 - Powered by Discuz!\n树莓派 wiringPi 库_~莘莘的博客-程序员宝宝_wiringpi - 程序员宝宝 (cxybb.com)\n//Core wiringPi functions\rextern struct wiringPiNodeStruct *wiringPiFindNode (int pin) ;\rextern struct wiringPiNodeStruct *wiringPiNewNode (int pinBase, int numPins) ;\rextern void wiringPiVersion\t(int *major, int *minor) ;\rextern int wiringPiSetup (void) ;\rextern int wiringPiSetupSys (void) ;\rextern int wiringPiSetupGpio (void) ;\rextern int wiringPiSetupPhys (void) ;\rextern void pinModeAlt (int pin, int mode) ;\rextern void pinMode (int pin, int mode) ;\rextern void pullUpDnControl (int pin, int pud) ;\rextern int digitalRead (int pin) ;\rextern void digitalWrite (int pin, int value) ;\rextern unsigned int digitalRead8 (int pin) ;\rextern void digitalWrite8 (int pin, int value) ;\rextern void pwmWrite (int pin, int value) ;\rextern int analogRead (int pin) ;\rextern void analogWrite (int pin, int value) ;\r","id":20,"section":"categories","summary":"WiringPi 安装 WiringPi 官网介绍截取 WiringPi is a PIN based GPIO access library written in C for the BCM2835, BCM2836 and BCM2837 SoC devices used in all Raspberry Pi. versions. The source code is not publicly available but may be made available to those who wish commercial support. It’s designed to be familiar to people who have used the Arduino “w","tags":[" raspberry"],"title":"Raspberry：Wiringpi的安装及使用","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/raspberry/wiringpi/","year":"2022"},{"content":"树莓派硬件资料 40pin SDA.0、SDA.1：I2C数据传输口 SCL.0、SCL.1：I2C的时钟信号 GPIO.x（x = 0,1,2,3,4,5,6,7;21,22,23,24,25,26,27,28,29）:通用的输入输出，自己定义即可 TXD\\RXD: 串口 MOSI：主输出 从输入(SPI) MISO：主输入 从输出(SPI) SCLK：SPI通信的时钟线(SPI) CE0、CE1：片选信号(SPI) ","id":21,"section":"categories","summary":"树莓派硬件资料 40pin SDA.0、SDA.1：I2C数据传输口 SCL.0、SCL.1：I2C的时钟信号 GPIO.x（x = 0,1,2,3,4,5,6","tags":["raspberry "],"title":"Raspberry：硬件资料","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%96%99/","year":"2022"},{"content":"Raspberry系统初始配置操作 note: Raspberry Pi OS从bullseye(2022-04-04 debaian 11)以后不在设置默认用户pi和密码raspberry，建议用官方下载器烧录系统，可以自定义初始化一个用户名和密码。\n下载器地址：Raspberry Pi OS – Raspberry Pi\nRaspberry Pi OS下载地址：Operating system images – Raspberry Pi\n1. 网络配置 1.1 以太网固定ip地址 sudo nano /etc/dhcpcd.conf\r取消相应的注释\ninterface wlan0\rstatic ip_address=192.168.1.102/24\rstatic ip6_address=fd51:42f8:caae:d92e::ff/64\rstatic routers=192.168.1.1\rstatic domain_name_servers=192.168.18.1 192.168.1.1 fd51:42f8:caae:d92e::1\rinterface eth0\rstatic ip_address=192.168.1.181/24\rstatic routers=192.168.1.1\rstatic domain_name_servers=192.168.1.1\r1.2 wifi连接 1.2.1 已经进入系统，联网情况下 //进入配置文件\rsudo nano /etc/wpa_supplicant/wpa_supplicant.conf\r//添加\rnetwork={\rssid=\u0026quot;无线名称\u0026quot;\rpsk=\u0026quot;无线密码\u0026quot;\r}\r1.2.1 没用进入到系统，boot中配置 boot盘中，新建文件，文件名为wpa_supplicant.conf,写入\ncountry=CN\rctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\rupdate_config=1\rnetwork={\rssid=\u0026quot;无线名称\u0026quot;\rpsk=\u0026quot;无线密码\u0026quot;\rkey_mgmt=WPA-PSK\rpriority=1\r}\r同上创建一个名字是ssh的文本文档，什么都不写，开启ssh服务\n2. 换源 参考资源—树莓派实验室\n确定树莓派系统版本\nlsb_release -a\rnote:\n树莓派有如下两个架构：\narm64 armhf 树莓派系统有如下几个版本\nwheezy jessie stretch（Debian 9） buster（Debian 10） bullseye（Debian 11） 可用以下网站替换下面源\n中国科学技术大学 Raspbian http://mirrors.ustc.edu.cn/raspbian/raspbian/\n阿里云 Raspbian http://mirrors.aliyun.com/raspbian/raspbian/\n清华大学 Raspbian http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/\n华中科技大学 Raspbian http://mirrors.hustunique.com/raspbian/raspbian/ Arch Linux ARM http://mirrors.hustunique.com/archlinuxarm/\n华南农业大学（华南用户） Raspbian http://mirrors.scau.edu.cn/raspbian/\n大连东软信息学院源（北方用户） Raspbian http://mirrors.neusoft.edu.cn/raspbian/raspbian/\n重庆大学源（中西部用户） Raspbian http://mirrors.cqu.edu.cn/Raspbian/raspbian/\n中山大学 已跳转至中国科学技术大学源 Raspbian http://mirror.sysu.edu.cn/raspbian/raspbian/\n新加坡国立大学 Raspbian http://mirror.nus.edu.sg/raspbian/raspbian\n牛津大学 Raspbian http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian/\n韩国KAIST大学 Raspbian http://ftp.kaist.ac.kr/raspbian/raspbian/\nsudo nano /etc/apt/sources.list wheezy\ndeb http://mirrors.sysu.edu.cn/raspbian/raspbian/ wheezy main contrib non-free\rdeb-src http://mirrors.sysu.edu.cn/raspbian/raspbian/ wheezy main contrib non-free\rjessie\ndeb http://mirrors.sysu.edu.cn/raspbian/raspbian/ jessie main contrib non-free\rdeb-src http://mirrors.sysu.edu.cn/raspbian/raspbian/ jessie main contrib non-free\rstretch\ndeb http://mirrors.sysu.edu.cn/raspbian/raspbian/ stretch main contrib non-free\rdeb-src http://mirrors.sysu.edu.cn/raspbian/raspbian/ stretch main contrib non-free\rbuster\ndeb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib\rdeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib\rbullseye\n#如果需要 armhf软件源\rdeb [arch=armhf] http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib rpi\rdeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib rpi\r# 如果需要 arm64 软件源，在 `/etc/apt/sources.list` 中加上\rdeb [arch=arm64] http://mirrors.tuna.tsinghua.edu.cn/raspbian/multiarch/ bullseye main\r","id":22,"section":"categories","summary":"Raspberry系统初始配置操作 note: Raspberry Pi OS从bullseye(2022-04-04 debaian 11)以后不在设置默认用户pi和密码raspberry","tags":["command","raspberry"],"title":"Raspberry：系统初始配置操作","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/raspberry/raspberry%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E6%93%8D%E4%BD%9C/","year":"2022"},{"content":"linux官方蓝牙协议bluez的使用 相关网址 官网源码 官网文档 python调用bluez bluepy - a Bluetooth LE interface for Python — bluepy 0.9.11 documentation (ianharvey.github.io) 安装bluez (Ubuntu 20.04编译安装BlueZ-5.6_修不好的BUG的博客-CSDN博客_bluez安装\n树莓派安装BlueZ协议栈（Raspberry pi Bluetooth LE）_PaulYoung_Blog的博客-CSDN博客_bluez安装\nxz -d bluez-5.64.tar.xz\rtar zvf bluez-5.64.tar ./configure --prefix=/usr/local --mandir=/usr/local/share/man --sysconfdir=/etc --localstatedir=/var\r","id":23,"section":"categories","summary":"linux官方蓝牙协议bluez的使用 相关网址 官网源码 官网文档 python调用bluez bluepy - a Bluetooth LE interface for Python — bluepy 0.9.11 documentation (ianharvey.github.io) 安装bluez (Ubuntu 20.04","tags":["c ","project"],"title":"Bluez","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/bluez/","year":"2022"},{"content":"TCP server epoll 头文件 #include \u0026lt;sys/epoll.h\u0026gt;\r结构体 typedef union epoll_data\r{\rvoid *ptr;\rint fd;\ruint32_t u32;\ruint64_t u64;\r} epoll_data_t;\rstruct epoll_event\r{\ruint32_t events;\t/* Epoll events 即enum EPOLL_EVENTS*/\repoll_data_t data;\t/* User data variable */\r} __EPOLL_PACKED;\r宏 enum EPOLL_EVENTS\r{\rEPOLLIN = 0x001,//表示对应的文件描述符可以读\r#define EPOLLIN EPOLLIN\rEPOLLPRI = 0x002,//表示对应的文件描述符有紧急的数据可读\r#define EPOLLPRI EPOLLPRI\rEPOLLOUT = 0x004,//表示对应的文件描述符可以写\r#define EPOLLOUT EPOLLOUT\rEPOLLRDNORM = 0x040,\r#define EPOLLRDNORM EPOLLRDNORM\rEPOLLRDBAND = 0x080,\r#define EPOLLRDBAND EPOLLRDBAND\rEPOLLWRNORM = 0x100,\r#define EPOLLWRNORM EPOLLWRNORM\rEPOLLWRBAND = 0x200,\r#define EPOLLWRBAND EPOLLWRBAND\rEPOLLMSG = 0x400,\r#define EPOLLMSG EPOLLMSG\rEPOLLERR = 0x008,//表示对应的文件描述符发生错误\r#define EPOLLERR EPOLLERR\rEPOLLHUP = 0x010,//表示对应的文件描述符被挂断\r#define EPOLLHUP EPOLLHUP\rEPOLLRDHUP = 0x2000,\r#define EPOLLRDHUP EPOLLRDHUP\rEPOLLEXCLUSIVE = 1u \u0026lt;\u0026lt; 28,\r#define EPOLLEXCLUSIVE EPOLLEXCLUSIVE\rEPOLLWAKEUP = 1u \u0026lt;\u0026lt; 29,\r#define EPOLLWAKEUP EPOLLWAKEUP\rEPOLLONESHOT = 1u \u0026lt;\u0026lt; 30,//只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。\r#define EPOLLONESHOT EPOLLONESHOT\rEPOLLET = 1u \u0026lt;\u0026lt; 31//将EPOLL设为边缘触发(Edge Triggered)模式\r#define EPOLLET EPOLLET\r};\r/* Valid opcodes ( \u0026quot;op\u0026quot; parameter ) to issue to epoll_ctl(). */\r#define EPOLL_CTL_ADD 1\t/* Add a file descriptor to the interface. */\r#define EPOLL_CTL_DEL 2\t/* Remove a file descriptor from the interface. */\r#define EPOLL_CTL_MOD 3\t/* Change file descriptor epoll_event structure. */\rAPI epoll_create()函数 功能：创建一个epoll实例。\n返回值：如果成功，返回一个epoll 的句柄fd（note：epoll占用一个fd，发生错误时，返回-1，\n注意：从Linux 2.6.8开始，size参数被忽略，但必须大于零；\n#include \u0026lt;sys/epoll.h\u0026gt;\rint epoll_create (int __size)\r这个文件描述符用于所有后续调用epoll的所有接口。 当不再需要文件描述符时，使用close关闭。 当所有指向这个epoll实例的文件描述符都关闭时，内核销毁实例并释放关联的重用资源\nepoll_create1()函数 功能：创建一个epoll实例。 如果flags为0，epoll_create1（）和删除了过时size参数的epoll_create（）相同。\n#include \u0026lt;sys/epoll.h\u0026gt;\rint epoll_create1 (int __flags)\repoll_ctl()函数 功能：该系统调用对文件描述符epfd引用的epoll实例执行控制操作。\n#include \u0026lt;sys/epoll.h\u0026gt;\rint epoll_ctl (int __epfd, int __op, int __fd,struct epoll_event *__event) op: EPOLL_CTL_ADD、EPOLL_CTL_DEL、EPOLL_CTL_MOD\nepoll_wait()函数 #include \u0026lt;sys/epoll.h\u0026gt;\rint epoll_wait (int __epfd, struct epoll_event *__events,int __maxevents, int __timeout)\repoll_pwait()函数 #include \u0026lt;sys/epoll.h\u0026gt; int epoll_pwait (int __epfd, struct epoll_event *__events,int __maxevents, int __timeout,\rconst __sigset_t *__ss);\r","id":24,"section":"categories","summary":"TCP server epoll 头文件 #include \u0026lt;sys/epoll.h\u0026gt; 结构体 typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events 即enum EPOLL_EVENTS*/ epoll_data_t data; /* User data variable */ } __EPOLL_PACKED; 宏 enum EPOLL_EVENTS { EPOLLIN = 0x001,//表示对应的文件描","tags":[" c","linux ","project","net"],"title":"Tcp_server","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/tcp_server/","year":"2022"},{"content":"LINUX串口编程\u0026ndash;raw 参考blog [ linux-串口应用编程_邻居家的小南瓜的博客-CSDN博客](https://blog.csdn.net/qq_37932504/article/details/121125906?ops_request_misc=\u0026amp;request_id=\u0026amp;biz_id=102\u0026amp;utm_term=linux 串口api\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-121125906.142^v9^pc_search_result_control_group,157^v4^new_style\u0026amp;spm=1018.2226.3001.4187)\nAPI总结 \u0026lt;termios.h\u0026gt; /* Return the output baud rate stored in *TERMIOS_P. */\rextern speed_t cfgetospeed (const struct termios *__termios_p) __THROW;\r/* Return the input baud rate stored in *TERMIOS_P. */\rextern speed_t cfgetispeed (const struct termios *__termios_p) __THROW;\r/* Set the output baud rate stored in *TERMIOS_P to SPEED. */\rextern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __THROW;\r/* Set the input baud rate stored in *TERMIOS_P to SPEED. */\rextern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __THROW;\r#ifdef\t__USE_MISC\r/* Set both the input and output baud rates in *TERMIOS_OP to SPEED. */\rextern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __THROW;\r#endif\r/* Put the state of FD into *TERMIOS_P. */\rextern int tcgetattr (int __fd, struct termios *__termios_p) __THROW;\r/* Set the state of FD to *TERMIOS_P.\rValues for OPTIONAL_ACTIONS (TCSA*) are in \u0026lt;bits/termios.h\u0026gt;. */\rextern int tcsetattr (int __fd, int __optional_actions,\rconst struct termios *__termios_p) __THROW;\r#ifdef\t__USE_MISC\r/* Set *TERMIOS_P to indicate raw mode. */\rextern void cfmakeraw (struct termios *__termios_p) __THROW;\r#endif\r/* Send zero bits on FD. */\rextern int tcsendbreak (int __fd, int __duration) __THROW;\r/* Wait for pending output to be written on FD.\rThis function is a cancellation point and therefore not marked with\r__THROW. */\rextern int tcdrain (int __fd);\r/* Flush pending data on FD.\rValues for QUEUE_SELECTOR (TC{I,O,IO}FLUSH) are in \u0026lt;bits/termios.h\u0026gt;. */\rextern int tcflush (int __fd, int __queue_selector) __THROW;\r/* Suspend or restart transmission on FD.\rValues for ACTION (TC[IO]{OFF,ON}) are in \u0026lt;bits/termios.h\u0026gt;. */\rextern int tcflow (int __fd, int __action) __THROW;\r#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8\r/* Get process group ID for session leader for controlling terminal FD. */\rextern __pid_t tcgetsid (int __fd) __THROW;\r#endif\ropen()函数 功能：打开设备文件\n返回值：如果操作成功，它将返回一个文件描述符，如果操作失败，它将返回-1\nint open (const char *__path, int __oflag, ...)\rnote:flags = O_RDWR | O_NOCTTY | O_NDELAY | O_EXCL;（libmodbus代码截取）\nO_RDWR ： 可读可写\nO_NOCTTY ：该参数不会使打开的文件成为该进程的控制终端。如果没有指定这个标志，那么任何一个 输入都将会影响用户的进程。\nO_NDELAY ：这个程序不关心DCD信号线所处的状态,端口的另一端是否激活或者停止。如果用户不指定了这个标志，则进程将会一直处在睡眠状态，直到DCD信号线被激活。\nO_EXCL：原子操作，确保只有一个执行流使用这个设备文件\ntcgetattr()函数 功能：获取终端的属性\n返回值：返回值：调用成功时返回 0；失败将返回-1\n#include \u0026lt;termios.h\u0026gt;\rint tcgetattr(int fd, struct termios *termios_p);\rtcsetattr()函数 功能：修改终端的属性\n返回值：返回值：调用成功时返回 0；失败将返回-1\n#include \u0026lt;termios.h\u0026gt;\rint tcsetattr(int fd, int optional_actions,const struct termios *termios_p);\rnote：optional_actions\u0026ndash;更改何时生效\nTCSANOW 配置立即生效 TCSADRAIN 配置在所有写入 fd 的输出都传输完毕之后生效 TCSAFLUSH 所有已接收但未读取的输入都将在配置生效之前被丢弃 cfmakeraw()函数 功能：将终端配置为原始模式。\nvoid cfmakeraw(struct termios *termios_p);\r波特率设置 //获取输入输出波特率\rextern speed_t cfgetospeed (const struct termios *__termios_p) __THROW;\rextern speed_t cfgetispeed (const struct termios *__termios_p) __THROW;\r//修改输入输出波特率\rextern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __THROW;\rextern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __THROW;\r//同时修改输入输出波特率\rextern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __THROW;\rtcdrain()函数 功能：调用 tcdrain()函数后会使得应用程序阻塞， 直到串口输出缓冲区中的数据全部发送完毕为止\n返回值：调用成功时返回 0；失败将返回-1，\n#include \u0026lt;termios.h\u0026gt; int tcdrain(int fd);\rtcflush()函数 功能：调用该函数会清空输入/输出缓冲区中的数据\n返回值：返回值：调用成功时返回 0；失败将返回-1\n#include \u0026lt;termios.h\u0026gt;\rint tcflush(int fd, int queue_selector);\rnote:queue_selector\nTCIFLUSH 对接收到而未被读取的数据进行清空处理 TCOFLUSH 对尚未传输成功的输出数据进行清空处理 TCIOFLUSH 对尚未处理的输入/输出数据进行清空处理 tcflow()函数 功能：调用 tcflow()函数会暂停数据传输或接收工作。\n返回值：返回值：调用成功时返回 0；失败将返回-1。\n#include \u0026lt;termios.h\u0026gt;\rint tcflow(int fd, int action);\rnote: action\nTCOOFF 暂停数据输出（输出传输） TCOON 重新启动暂停的输出 TCIOFF 发送 STOP 字符，停止终端设备向系统发送数据 TCION 发送一个 START 字符，启动终端设备向系统发送数据； struct termios结构体 struct termios\r{\rtcflag_t c_iflag; /* input mode flags */\rtcflag_t c_oflag; /* output mode flags */\rtcflag_t c_cflag; /* control mode flags */\rtcflag_t c_lflag; /* local mode flags */\rcc_t c_line; /* line discipline */\rcc_t c_cc[NCCS]; /* control characters */\rspeed_t c_ispeed; /* input speed */\rspeed_t c_ospeed; /* output speed */\r};\r波特率、数据位、停止位使用案例 /*0. 保存原有的termios*/\rtcgetattr(this-\u0026gt;fd, \u0026amp;old_termios);\r/*1. 设置波特率 */\rnew_termios.c_cflag\u0026amp;=~CBAUD;//波特率掩码(000000010017 /* baud speed mask)\rif(cfsetispeed(\u0026amp;(new_termios),baud_adapt(baudrate))\u0026lt;0)\r{\rstd::cerr\u0026lt;\u0026lt;\u0026quot;[err]:function cfsetispeed()--set \u0026quot;\u0026lt;\u0026lt; baudrate\u0026lt;\u0026lt;\u0026quot; input baudrate failed!!!\\n\u0026quot;;\rthis-\u0026gt;uart_close();\rreturn -1;\r}\rif(cfsetospeed(\u0026amp;(new_termios),baud_adapt(baudrate))\u0026lt;0)\r{\rstd::cerr\u0026lt;\u0026lt;\u0026quot;[err]:function cfsetospeed()--set \u0026quot;\u0026lt;\u0026lt; baudrate\u0026lt;\u0026lt;\u0026quot; output baudrate failed!!!\\n\u0026quot;;\rthis-\u0026gt;uart_close();\rreturn -1;\r}\r/* 2.设置数据位 */\rnew_termios.c_cflag\u0026amp;=~CSIZE;//屏蔽其他标志\rswitch (databits)//设置数据位\r{\rcase 5:\rnew_termios.c_cflag|=CS5;\rbreak;\rcase 6:\rnew_termios.c_cflag|=CS6;\rbreak;\rcase 7:\rnew_termios.c_cflag|=CS7;\rbreak;\rcase 8:\rnew_termios.c_cflag|=CS8;\rbreak;\rdefault:\rthis-\u0026gt;uart_close();\rstd::cerr\u0026lt;\u0026lt;\u0026quot;[err]:set databits failed!!!\\n\u0026quot;;\rreturn -1;\rbreak;\r}\r/*3. 设置奇偶检验 */\rswitch (parity)\r{\rcase 'N'://无\rnew_termios.c_iflag \u0026amp;= ~(INPCK | ISTRIP);//关闭输入奇偶检验检查\rnew_termios.c_cflag \u0026amp;= ~PARENB;//关闭奇偶位\rbreak;\rcase 'E'://奇\rnew_termios.c_iflag |= (INPCK );//开启输入奇偶检验检查\rnew_termios.c_cflag |= PARENB;//开启奇偶位\rnew_termios.c_cflag \u0026amp;= ~PARODD;//关闭偶位\rbreak;\rcase 'O'://偶\rnew_termios.c_iflag |= (INPCK);//开启输入奇偶检验检查\rnew_termios.c_cflag|= PARENB;//开启奇偶位\rnew_termios.c_cflag |= PARODD;//开启偶位\rbreak;\rdefault:\rthis-\u0026gt;uart_close();\rstd::cerr\u0026lt;\u0026lt;\u0026quot;[err]:set parity failed!!!\\n\u0026quot;;\rreturn -1;\rbreak;\r}\r/*4. 设置停止位 */\rswitch (stopbits)\r{\rcase 1:\rnew_termios.c_cflag \u0026amp;= ~CSTOPB;\rbreak;\rcase 2:\rnew_termios.c_cflag |= CSTOPB;//每个字符使用2bit停止位，否者就使用一个\rbreak;\rdefault:\rthis-\u0026gt;uart_close();\rbreak;\r}\r/*5. 设置非规范模式(即raw模式)，也可以使用cfmakeraw()函数*/\rnew_termios.c_lflag \u0026amp;= ~(ICANON | ECHO | ECHOE | ISIG);\rnew_termios.c_oflag \u0026amp;=~ OPOST; /* Raw output */\rnew_termios.c_cc[VMIN]=0;\rnew_termios.c_cc[VTIME]=1;\r/*6.other*/\rnew_termios.c_oflag \u0026amp;= ~OPOST; /* Raw output */\rnew_termios.c_iflag \u0026amp;= ~(IXON | IXOFF | IXANY); /* Software flow control is disabled */\rnew_termios.c_iflag \u0026amp;= ~(IUCLC|ICRNL|INLCR|IGNCR);/* 1.关闭input大小写转换 2.禁止CR、LF相互转换 3.不忽略CR、LF*/\rnew_termios.c_oflag \u0026amp;= ~(OLCUC|OCRNL|ONLCR);/* 1.关闭output大小写转换 2.同上*/\r/*7.设置生效 */\rif(tcsetattr(this-\u0026gt;fd,TCSANOW,\u0026amp;(new_termios))\u0026lt;0)\r{\rstd::cerr\u0026lt;\u0026lt;\u0026quot;[err]:function tcsetattr()--set attr failed!!!\\n\u0026quot;;\rthis-\u0026gt;uart_close();\rreturn -1;\r}\r非规范模式：C_CC[]\u0026ndash;MIN TIME 代码及其测试 代码 [代码案例 click here](code/02c/uart at main · Getonechao/code (github.com))\n测试 %写\rclear;\rdevice=serialport(\u0026quot;COM5\u0026quot;,115200,\u0026quot;Parity\u0026quot;,\u0026quot;even\u0026quot;,\u0026quot;DataBits\u0026quot;,8,\u0026quot;StopBits\u0026quot;,1);\rflush(device);\rfor i=1:10\rwrite(device,[0:255],\u0026quot;uint8\u0026quot;);\rend\r%读\rclear;\rdevice=serialport(\u0026quot;COM5\u0026quot;,115200,\u0026quot;Parity\u0026quot;,\u0026quot;even\u0026quot;,\u0026quot;DataBits\u0026quot;,8,\u0026quot;StopBits\u0026quot;,1);\rflush(device);\rret=read(device,3,\u0026quot;uint8\u0026quot;)\r","id":25,"section":"categories","summary":"LINUX串口编程\u0026ndash;raw 参考blog [ linux-串口应用编程_邻居家的小南瓜的博客-CSDN博客](https://blog","tags":[" c","project ","linux"],"title":"Linux串口编程","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/linux%E4%B8%B2%E5%8F%A3%E7%BC%96%E7%A8%8B/","year":"2022"},{"content":"ubuntu系统初始化常用一些指令 换源 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\rsudo nano /etc/apt/sources.list\r清华源 # 清华源\r18.04\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\r20.04\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse multiverse\r阿里源 18.04\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\rdeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\r20.04\rdeb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\r更新源 sudo apt-get update\r安装工具 sudo apt install g++ cmake openssh-server libtool autoconf git\rnote：如果vscode或者ssh在装新系统失败后，可能是.ssh/known_hosts文件中ip对应的指纹还是旧的。\ngit config --global user.email \u0026quot;1509670272@qq.com\u0026quot;\rgit config --global user.name \u0026quot;chao\u0026quot;\rSSH-公钥生成 ssh-keygen -t rsa -C \u0026quot;chao\u0026quot;\rcat ~/.ssh/id_rsa.pub 无密码ssh登入其他ubuntu系统\r$ cat ~/.ssh/id_rsa.pub(本地) \u0026gt;\u0026gt; ~/.ssh/authorized_keys(远程) 创建新用户 创建用户\ruseradd chao -p chao -m -G wheel（或sudo） -s /bin/bash -c \u0026quot;2021-6-3 create 'chao' username \u0026quot;\r修改密码\rpasswd chao\r","id":26,"section":"categories","summary":"ubuntu系统初始化常用一些指令 换源 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak sudo nano /etc/apt/sources.list 清华源 # 清华源 18.04 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src","tags":[" ubuntu","command"],"title":"ubuntu系统初始化常用一些指令","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/ubuntu/ubuntu%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E6%93%8D%E4%BD%9C/","year":"2022"},{"content":"libmodbus的使用 安装 wget https://github.com/stephane/libmodbus/archive/refs/tags/v3.1.7.zip\runzip v3.1.7.zip\rsudo apt install libtool\rsudo apt install autoconf\r./autoconf\r./configure --prefix=/usr/local/\rsudo make install\r源码解析 参考网址\n【嵌入式】Libmodbus源码分析(一)-类型和结构体_沧海一笑-dj的博客-CSDN博客_libmodbus源码 【嵌入式】Libmodbus源码分析(二)-常用接口函数分析_沧海一笑-dj的博客-CSDN博客_modbus接口函数 【嵌入式】Libmodbus源码分析(三)-modbus相关函数分析_沧海一笑-dj的博客-CSDN博客_libmodbus代码示例 【嵌入式】Libmodbus源码分析(四)-RTU相关函数分析_沧海一笑-dj的博客-CSDN博客 【嵌入式】Libmodbus源码分析(五)-TCP相关函数分析_沧海一笑-dj的博客-CSDN博客 【嵌入式】嵌入式天地博客汇总_沧海一笑-dj的博客-CSDN博客 [libmodbus官方手册中文翻译_跃动的风的博客-CSDN博客_libmodbus使用说明](https://blog.csdn.net/qq_23670601/article/details/82155378?ops_request_misc=\u0026amp;request_id=\u0026amp;biz_id=102\u0026amp;utm_term=libmodbus debug\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-82155378.142^v9^pc_search_result_control_group,157^v4^new_style\u0026amp;spm=1018.2226.3001.4187) note: 如果使用matlab modbus explorer,matlab中的寄存器地址从1开开始算起，实际应该libmodbus中的地址0\n","id":27,"section":"categories","summary":"libmodbus的使用 安装 wget https://github.com/stephane/libmodbus/archive/refs/tags/v3.1.7.zip unzip v3.1.7.zip sudo apt install libtool sudo apt install autoconf ./autoconf ./configure --prefix=/usr/local/ sudo make install 源码解析 参考网址 【嵌入式】Libmodbus源码分析(一)-类型和结构体_沧","tags":[" project","c"],"title":"Libmodbus","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/libmodbus/","year":"2022"},{"content":"一、Cmake模板 cmake_minimum_required(VERSION 3.1)\rproject(PROJECT_XXX VERSION 0.0.0.0 )\r#C/C++标准\rset(CMAKE_CXX_STANDARD 14)\rset(CMAKE_C_STANDARD 11)\r#设置编译器\rset (CMAKE_C_COMPILER \u0026quot;/usr/bin/gcc\u0026quot;)\rset (CMAKE_CXX_COMPILER \u0026quot;/usr/bin/g++\u0026quot;)\r#lib\u0026amp;\u0026amp;bin\rset(LIBRARY_OUTPUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/lib)\rset(EXECUTABLE_OUTPUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/bin)\r#release debug\rset(CMAKE_BUILD_TYPE Debug#[[Release | Debug| RelWithDebInfo |MinSizeRel]])\r#add_compile_options()#等同CMAKE_CXXFLAGS_RELESE,前者可以对所有的编译器设置，后者只能是C++编译器\r#find_package(Eigen3 REQUIRED)\r#find_path (\u0026lt;VAR\u0026gt; name1 [path1 path2 ...])\r#find_file (\u0026lt;VAR\u0026gt; name1 [path1 path2 ...])\r#find_library (\u0026lt;VAR\u0026gt; name1 [path1 path2 ...])\r######### Target LIB #########\raux_source_directory(目录 变量)\radd_library(${PROJECT_NAME} )#默认是STATIC\rtarget_include_directories(EigenSample PRIVATE )\rtarget_sources(EigenSample PRIVATE )\rtarget_link_libraries(EigenSample )\rtarget_compile_options(EigenSample PRIVATE -Wall\r-O3 -std=c++11 )\rtarget_compile_definitions(EigenSample PRIVATE\rCMAKE_BUILD_TYPE=Release\rCMAKE_EXPORT_COMPILE_COMMANDS=ON)\r######### Target EXE #########\raux_source_directory(目录 变量)\radd_executable(${PROJECT_NAME} )\rtarget_include_directories(EigenSample PRIVATE )\rtarget_sources(EigenSample PRIVATE )\rtarget_link_libraries(EigenSample )\rtarget_compile_options(EigenSample PRIVATE -Wall\r-O3 -std=c++11 )\rtarget_compile_definitions(EigenSample PRIVATE\rCMAKE_BUILD_TYPE=Release\rCMAKE_EXPORT_COMPILE_COMMANDS=ON)\r########## TEST ##########\renable_testing()\radd_test(NAME test COMMAND ${PROJECT_NAME} -arg1 -arg2) 二、参数设置 编译选项\nCMAKE_BUILD_TYPE Release | Debug| RelWithDebInfo |MinSizeRel\n三、命令解释 3.1 find命令 find_path：用于找到指定文件或目录路径的命令(安装ini文件) find_path(\u0026lt;VAR\u0026gt; name1 [path1 path2 ...])\reg：\rfind_path(STDIO_H_INCLUDE_DIR stdio.h\r/usr/include\r/usr/local/include)\r其中，\u0026lt;VAR\u0026gt;是用于存储找到的路径的变量名。name1是要查找的文件或目录的名称。path1，path2等是可选的搜索路径。\nfind_path命令特别适用于需要在构建过程中动态查找头文件路径的情况\nfind_file：用于查找指定文件的路径 find_file(\u0026lt;VAR\u0026gt; name1 [path1 path2 ...])\reg：\rfind_file(EXAMPLE_FILE example.txt)\r执行上述命令后，如果找到了example.txt文件，路径将存储在EXAMPLE_FILE变量中，否则该变量将为空。\rfind_file(EXAMPLE_FILE example.txt\r/usr/data\r/home/user/data\r)\r这将在/usr/data和/home/user/data目录下搜索example.txt文件\r其中，\u0026lt;VAR\u0026gt;是一个变量，用于存储找到的文件路径。name1是要查找的文件的名称。path1，path2等是可选的搜索路径。\nfind_library：用于查找指定库文件的路径 find_library(\u0026lt;VAR\u0026gt; name1 [path1 path2 ...])\r其中，\u0026lt;VAR\u0026gt;是用于存储找到的库文件路径的变量名。name1是要查找的库文件的名称（不包括前缀lib和文件扩展名）。\n使用案例\ncmake_minimum_required(VERSION 3.12)\rproject(MyProject)\r# 查找名为 mylibrary 的库文件\rfind_library(MYLIBRARY_LIB mylibrary)\r# 如果找到了库文件\rif(MYLIBRARY_LIB)\rmessage(\u0026quot;Found mylibrary at: ${MYLIBRARY_LIB}\u0026quot;)\r# 添加库文件的路径到链接器\rtarget_link_libraries(MyExecutable ${MYLIBRARY_LIB})\relse()\rmessage(FATAL_ERROR \u0026quot;mylibrary not found\u0026quot;)\rendif()\rfind_program：用于查找指定可执行程序的路径 find_program(\u0026lt;VAR\u0026gt; name1 [path1 path2 ...])\reg：\rfind_program(MYPROGRAM_EXECUTABLE myprogram\r/usr/bin\r/usr/local/bin\r)\r这将在/usr/bin和/usr/local/bin目录下搜索myprogram可执行程序。\n使用案例\ncmake_minimum_required(VERSION 3.12)\rproject(MyProject)\r# 查找名为 myprogram 的可执行程序\rfind_program(MYPROGRAM_EXECUTABLE myprogram)\r# 如果找到了可执行程序\rif(MYPROGRAM_EXECUTABLE)\rmessage(\u0026quot;Found myprogram at: ${MYPROGRAM_EXECUTABLE}\u0026quot;)\r# 在构建过程中使用可执行程序\radd_custom_target(run_myprogram COMMAND ${MYPROGRAM_EXECUTABLE})\relse()\rmessage(FATAL_ERROR \u0026quot;myprogram not found\u0026quot;)\rendif()\r在这个案例中，假设我们的项目想要运行名为myprogram的可执行程序。\n通过find_program(MYPROGRAM_EXECUTABLE myprogram)命令，CMake会尝试在系统的默认可执行程序搜索路径中找到名为myprogram的可执行程序。\n如果成功找到了可执行程序，CMake会将路径存储在变量MYPROGRAM_EXECUTABLE中，并通过add_custom_target命令定义一个自定义目标，使得我们可以在构建过程中使用该可执行程序。\n如果未找到可执行程序，则会输出错误消息并终止构建过程\nfind_package: CMake中用于查找和加载第三方库的命令 使用案例\ncmake_minimum_required(VERSION 3.12)\rproject(MyProject)\r# 查找并加载 OpenCV\rfind_package(OpenCV 4 REQUIRED)\r# 检查是否找到库\rif(OpenCV_FOUND)\rmessage(\u0026quot;Found OpenCV version ${OpenCV_VERSION}\u0026quot;)\rinclude_directories(${OpenCV_INCLUDE_DIRS})\radd_executable(MyApp main.cpp)\rtarget_link_libraries(MyApp ${OpenCV_LIBS})\relse()\rmessage(FATAL_ERROR \u0026quot;OpenCV not found\u0026quot;)\rendif()\r# 添加其他项目配置和构建指令...\r变量\n\u0026lt;PackageName\u0026gt;_FOUND： 表示是否找到了指定的库。它是一个布尔值，如果找到了库，则为 TRUE，否则为 FALSE。 \u0026lt;PackageName\u0026gt;_VERSION： 当找到库时，它表示所找到的库的版本号。该值可能是一个字符串或一个列表。 \u0026lt;PackageName\u0026gt;_INCLUDE_DIRS： 包含着所找到的库的头文件路径的变量。这允许您在项目中包含库的头文件。 \u0026lt;PackageName\u0026gt;_LIBRARIES： 存储了所找到的库的完整库文件路径的变量。通过这个变量，您可以将所需的库链接到项目的可执行文件或库中。 这些变量的命名约定在不同的 Find 模块中可能会有所不同，因此请查阅库的相关文档来获取详细的变量名称和用途。\n3.2 file 执行与文件和目录相关的操作 它可以用于创建、复制、删除、重命名、读取文件内容等操作。以下是一些 file() 命令的常见用法：\nfile(COPY ...)： 将指定的文件或目录复制到指定的目标目录下。该命令可以用于将文件复制到构建目录或安装位置。\nfile(COPY source_file DESTINATION destination_directory)\rfile(REMOVE ...)： 删除指定的文件或目录。\nfile(REMOVE file_path)\rfile(RENAME ...)： 将文件或目录重命名。\nfile(RENAME old_name new_name)\rfile(READ ...)： 读取文件内容到变量中。\nfile(READ file_path variable_name)\rfile(WRITE ...)： 将字符串内容写入文件中。\nfile(WRITE file_path \u0026quot;content\u0026quot;)\rfile(APPEND ...)： 将字符串内容追加到文件末尾。\nfile(APPEND file_path \u0026quot;content\u0026quot;)\r这只是 file() 命令的一些常见用法示例，实际上它还有很多其他用法，例如创建目录、查找文件、获取文件属性等。您可以在 CMake 官方文档中查找 file() 命令的完整参考以获取更详细的信息和用法示例。\n3.3 自定义命令 在很多时候，需要在cmake中创建一些目标，如clean、copy等等，这就需要通过add_custom_target来指定。同时，add_custom_command可以用来完成对add_custom_target生成的target的补充。\n区别 在CMake中，\u0026ldquo;add_custom_command\u0026quot;和\u0026quot;add_custom_target\u0026quot;是两个常用的命令，用于定义自定义编译命令和自定义构建目标。它们之间的区别如下：\nadd_custom_command： add_custom_command用于定义在构建时执行的自定义命令。它可以用来生成文件、生成代码、运行脚本等。add_custom_command通常被用作目标的依赖项。 add_custom_command并不会创建真正的构建目标，它仅仅是一个构建过程中执行的命令。因此，默认情况下，add_custom_command不会导致重新构建整个项目。 add_custom_target： add_custom_target用于定义一个构建目标，该目标不与实际的文件或输出相关联，而是与一组其他规则相关联。 add_custom_target可以用来执行一系列自定义命令或构建步骤。它对于组织和管理构建过程非常有用。 add_custom_target通常用作构建系统的入口点，通过依赖其他目标和规则来执行自定义构建任务。 总结来说，add_custom_command用于定义构建过程中的自定义命令，而add_custom_target用于定义自定义构建目标。两者可以结合使用，以实现更复杂的构建逻辑。\nadd_custom_target：自定义构建目标 add_custom_target(Name [ALL] [command1 [args1...]]\r[COMMAND command2 [args2...] ...]\r…\r)\r# Name：定义的target的名字\r# COMMAND：该target要执行的命令\radd_custom_target(\rtarget_name\r[COMMAND command1 [ARGS] [args1...]]\r[COMMAND command2 [ARGS] [args2...] ...]\r[DEPENDS [depend1...]]\r[WORKING_DIRECTORY dir]\r[COMMENT comment]\r[VERBATIM]\r[USES_TERMINAL]\r)\r其中，常用的参数和选项包括：\rtarget_name：自定义构建目标的名称。\rCOMMAND：指定要执行的命令。\rDEPENDS：指定自定义目标所依赖的其他目标或文件。\rWORKING_DIRECTORY：设置命令的工作目录。\rCOMMENT：添加对命令或目标的注释。\rVERBATIM：保留命令中的转义字符，确保按原样传递给底层的构建工具。\rUSES_TERMINAL：指示命令是否会使用终端。\r通过使用 add_custom_target，可以在构建过程中定义各种自定义的构建目标，例如运行测试、生成文档、执行代码检查等。这些目标可以依赖其他目标或文件，并根据需要执行自定义的命令或操作\radd_custom_target 命令不会生成实际的构建产物（如可执行文件或库），它只是定义了一个自定义的构建目标。您可以通过 add_dependencies 命令将这个自定义目标与其他目标关联起来，以确保在构建过程中执行相关的自定义操作。\r使用案例\nadd_custom_target(RunTests\rCOMMAND run_tests.sh\rDEPENDS test_files\rWORKING_DIRECTORY ${CMAKE_BINARY_DIR}\rCOMMENT \u0026quot;Running tests...\u0026quot;\r)\radd_dependencies(RunTests MyApp)\r在这个示例中，RunTests 是一个自定义目标，通过执行 run_tests.sh 脚本来运行测试。它依赖于 test_files 目标（或文件），并在 ${CMAKE_BINARY_DIR} 目录下执行。通过 COMMENT 可以添加注释，说明正在运行的操作。最后，通过 add_dependencies 将 RunTests 目标与 MyApp 目标关联起来，以确保在构建 RunTests 目标时先构建 MyApp 目标。\r使用教程\n创建自定义目标： 首先，使用 add_custom_target 命令创建一个自定义构建目标并指定它的名称。\nadd_custom_target(MyTarget)\r在上述示例中，我们创建了一个名为 MyTarget 的自定义目标，这个目标还没有定义任何操作。\n添加命令： 使用 COMMAND 选项来添加要执行的命令或操作。\nadd_custom_target(MyTarget\rCOMMAND echo \u0026quot;Hello, World!\u0026quot;\r)\r在这个例子中，我们在 MyTarget 目标中添加了一个命令，即输出 “Hello, World!”。您可以根据实际需求添加更多的命令或操作。\n添加依赖项： 使用 DEPENDS 选项来指定 MyTarget 目标所依赖的其他目标或文件。\nadd_custom_target(MyTarget\rCOMMAND echo \u0026quot;Hello, World!\u0026quot;\rDEPENDS other_target file.txt\r)\r在上述示例中，我们将 MyTarget 目标设置为依赖于 other_target 目标和 file.txt 文件。这意味着在构建 MyTarget 之前，CMake 将确保先构建 other_target 目标和检查 file.txt 文件的更新。\n设置工作目录和注释： 使用其他选项如 WORKING_DIRECTORY 和 COMMENT 来设置工作目录和添加注释。\nadd_custom_target(MyTarget\rCOMMAND echo \u0026quot;Hello, World!\u0026quot;\rDEPENDS other_target file.txt\rWORKING_DIRECTORY ${CMAKE_BINARY_DIR}\rCOMMENT \u0026quot;Running custom commands...\u0026quot;\r)\r在上述示例中，我们设置了 MyTarget 的工作目录为 ${CMAKE_BINARY_DIR}，并添加了一个注释以描述正在执行的操作。\n添加到其他目标的依赖项： 使用 add_dependencies 命令将自定义目标与其他目标关联起来。\nadd_executable(MyApp main.cpp)\radd_custom_target(MyTarget\rCOMMAND echo \u0026quot;Hello, World!\u0026quot;\rDEPENDS other_target file.txt\rWORKING_DIRECTORY ${CMAKE_BINARY_DIR}\rCOMMENT \u0026quot;Running custom commands...\u0026quot;\r)\radd_dependencies(MyApp MyTarget)\r在这个例子中，我们将自定义目标 MyTarget 添加为可执行文件 MyApp 的依赖项。这意味着在构建 MyApp 时，CMake 将确保先构建 MyTarget。\nadd_custom_command：自定义编译命令 add_custom_command(OUTPUT output1 [output2 ...]\rCOMMAND command1 [ARGS] [args1...]\r[COMMAND command2 [ARGS] [args2...] ...]\r[MAIN_DEPENDENCY depend]\r[DEPENDS [depends...]]\r[BYPRODUCTS [files...]]\r[IMPLICIT_DEPENDS \u0026lt;lang1\u0026gt; depend1\r[\u0026lt;lang2\u0026gt; depend2] ...]\r[WORKING_DIRECTORY dir]\r[COMMENT comment]\r[DEPFILE depfile]\r[JOB_POOL job_pool]\r[VERBATIM] [APPEND] [USES_TERMINAL]\r[COMMAND_EXPAND_LISTS]\r[DEPENDS_EXPLICIT_ONLY])\r其中，常用的参数和选项包括：\nTARGET：指定目标（可执行文件或库），表示该自定义命令与构建目标相关联。 PRE_BUILD、PRE_LINK、POST_BUILD：指定自定义命令在何时执行，分别表示前置构建、前置链接和后置构建。 COMMAND：指定要执行的命令。 WORKING_DIRECTORY：设置命令的工作目录。 COMMENT：添加对命令的注释。 MAIN_DEPENDENCY：指定自定义命令所依赖的主文件。 DEPENDS：指定自定义命令所依赖的其他文件。 BYPRODUCTS：指定由命令生成的副产品文件。 IMPLICIT_DEPENDS：指定命令的隐式依赖关系，这些依赖关系可能是根据源文件的语言推断出来的。 USES_TERMINAL：指示命令是否会使用终端（仅在可执行文件的情况下）。 通过使用 add_custom_command，可以在构建过程中执行各种自定义的命令，如生成代码、拷贝文件、运行脚本等。这允许您在构建过程中执行与编译和链接无关的任意操作。\n请注意，add_custom_command 命令必须与 add_custom_target 或 add_executable / add_library 配合使用，以将其与构建目标关联起来。\n使用案例\nadd_custom_command 命令用于在构建过程中执行自定义的命令。下面是一个简单的教程，介绍了如何使用 add_custom_command：\n添加生成文件的自定义命令： 首先，使用 add_custom_command 命令定义一个用于生成文件的自定义命令。\nadd_custom_command(\rOUTPUT generated_file.txt\rCOMMAND generate_file.py\rDEPENDS generate_file.py\r)\r在上述示例中，我们定义了一个自定义命令，它使用 Python 脚本 generate_file.py 来生成一个名为 generated_file.txt 的文件。DEPENDS 参数指定生成文件的依赖项，例如脚本文件本身。\n将生成的文件作为构建目标使用： 可以将生成的文件作为构建目标的一部分使用，例如作为源文件或目标文件。\nadd_executable(MyApp main.cpp generated_file.txt)\r在上述示例中，我们将生成的文件 generated_file.txt 作为一个源文件之一与 main.cpp 一起使用，构建一个名为 MyApp 的可执行文件。\n声明生成文件的依赖关系： 使用 add_dependencies 命令将自定义命令与其他目标关联起来。\nadd_custom_command(\rOUTPUT generated_file.txt\rCOMMAND generate_file.py\rDEPENDS generate_file.py\r)\radd_executable(MyApp main.cpp)\radd_dependencies(MyApp generated_file.txt)\r在这个例子中，我们在自定义命令与目标之间建立了依赖关系。通过 add_dependencies 命令，MyApp 目标将在构建之前先构建 generated_file.txt。\n使用 add_custom_command，您可以执行各种自定义的命令或操作，并将其与构建目标进行关联。这使得您可以在构建过程中执行额外的操作，例如生成代码、复制文件、预处理资源等。根据自己的项目需求，您可以根据需要实现适合的自定义命令，并根据构建逻辑设置相关的依赖关系。\n3.4 配置文件 configure_file命令是CMake提供的一个常用命令，用于在构建过程中根据模板文件生成配置文件\n四、自动化测试 当使用CTest来运行测试时，通常需要按照以下步骤进行配置和执行：\n创建测试目录：在项目中创建一个用于存放测试脚本和测试数据的目录。可以将该目录命名为tests或者其他合适的名称。\n编写测试脚本：在测试目录中创建一个或多个测试脚本文件，用于描述测试用例和测试步骤。测试脚本可以使用CTest的命令和语法来定义测试行为、验证结果等。以下是一个简单的示例：\n# tests/mytest.cmake\r# 定义一个测试用例\radd_test(NAME MyTest COMMAND my_program input_data.txt output_data.txt)\r# 验证测试结果\rset_tests_properties(MyTest PROPERTIES PASS_REGULAR_EXPRESSION \u0026quot;Expected output\u0026quot;)\r创建CTest配置文件：在项目的根目录中创建一个名为CTestTestfile.cmake的配置文件，用于配置测试设置、测试套件和测试驱动程序等细节。该文件会被CTest自动加载。以下是一个简单的示例：\n# CTestTestfile.cmake\r# 添加测试目录\radd_subdirectory(tests)\r构建项目：使用CMake构建项目，此时确保CTest被启用并已成功集成到项目中。\n运行CTest：在项目构建完成后，在构建目录中运行ctest命令来执行测试。可以使用ctest --verbose来显示详细的测试输出。\n$ ctest\r或者使用图形界面工具来运行CTest，例如运行ccmake或cmake-gui命令来查看和运行CTest。\n查看测试结果：CTest将测试结果输出到终端或CTest的GUI前端。你将看到每个测试的状态（通过、失败、跳过等），以及相关的错误消息和日志文件。\n这只是一个简单的CTest使用示例，你可以根据项目的特定需求和测试要求自定义和扩展CTest的功能。参阅CTest文档以获取更多详细信息和更高级的CTest配置选项。\n记住，在编写测试脚本时，应该尽可能涵盖项目的各方面，并验证预期的行为和结果。测试是质量保证过程的重要组成部分，能够提供反馈以确保项目的正确性和可靠性。\n","id":28,"section":"categories","summary":"一、Cmake模板 cmake_minimum_required(VERSION 3.1) project(PROJECT_XXX VERSION 0.0.0.0 ) #C/C++标准 set(CMAKE_CXX_STANDARD 14) set(CMAKE_C_STANDARD 11) #设置编译器 set (CMAKE_C_COMPILER \u0026quot;/usr/bin/gcc\u0026quot;) set (CMAKE_CXX_COMPILER \u0026quot;/usr/bin/g++\u0026quot;) #lib\u0026amp;\u0026amp;bin set(LIBRARY_OUTPUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/lib) set(EXECUTABLE_OUTPUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/bin) #release debug set(CMAKE_BUILD_TYPE Debug#[[Release | Debug| RelWithDebInfo |MinSizeRel]]) #add_compile_optio","tags":[" project","cmake"],"title":"cmake：c/c++的工程构建工具","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/cmake/","year":"2022"},{"content":"使用vspd配置VM的虚拟机的串口调试 下载vspd 链接：https://pan.baidu.com/s/15sQ3B3Ty4QGH8Rvl7yFz0g 提取码：kjdw\n创建虚拟串口 VM绑定相应的串口 note:\n将windows的串口com5绑定到linux的串口/dev/ttyS1上 如果Vm没有检测到虚拟串口，请关闭vm，重启vm 图片中的\u0026quot;串行端口n\u0026quot;，实际对应linux系统中/dev/ttyS(n-1) ","id":29,"section":"categories","summary":"使用vspd配置VM的虚拟机的串口调试 下载vspd 链接：https://pan.baidu.com/s/15sQ3B3Ty4QGH8Rvl7","tags":[" project"],"title":"vspd\u0026VM","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/vspd/","year":"2022"},{"content":"freemodus 源码 cwalter-at/freemodbus\narmink/FreeModbus_Slave-Master-RTT-STM32: Add master mode to FreeModbus. | 在 FreeModbus 中添加主机模式 (github.com)\nmodbus 0x01 读线圈寄存器 0x02 读离散输入寄存器 0x03 读保持寄存器 0x04 读输入寄存器 0x05 写单个线圈寄存器 0x06 写单个保持寄存器 0x0f 写多个线圈寄存器 0x10 写多个保持寄存器 线圈寄存器（0x01、0x05、0x0f） 寄存器的单位是1bit,类比为开关量，每一个bit都对应一个信号的开关状态，1byte有8bit\n离散输入寄存器（0x02） 离散输入寄存器就相当于线圈寄存器的只读模式\n保持寄存器（0x03、0x06、0x10） 寄存器的单位是2byte,即16bit\n输入寄存器（0x04） 和保持寄存器类似，但是也是只支持读而不能写\nmodbus地址规范 00001至09999是离散输出(线圈)\u0026mdash;\u0026ndash;Coil status 10001至19999是离散输入(触点)\u0026mdash;\u0026ndash;Input status 30001至39999是输入寄存器(通常是模拟量输入)\u0026mdash;\u0026mdash;Input register 40001至49999是保持寄存器 \u0026mdash;\u0026mdash;-Holding register\n0x代表线圈（DO）类地址，1x代表触点（DI）类地址、 3x代表输入寄存器（AI）类地址、4x代表输出寄存器（AO）类地址。在实际编程中，由于前缀的区分作用，所以只需说明后4位数，而且需转换为4位十六进制地址\nLinux的使用 官方规定的流程：\n* // Initialize protocol stack in RTU mode for a slave with address 10 = 0x0A\r* eMBInit( MB_RTU, 0x0A, 38400, MB_PAR_EVEN );\r* // Enable the Modbus Protocol Stack.\r* eMBEnable( );\r* for( ;; )\r* {\r* // Call the main polling loop of the Modbus protocol stack.\r* eMBPoll( );\r* ...\r* }\rRTU #include \u0026lt;iostream\u0026gt;\r#include \u0026quot;mb.h\u0026quot;\r#include \u0026quot;mbport.h\u0026quot;\r#define REG_INPUT_START 1000 /* 输入寄存器开始地址 */\r#define REG_INPUT_NREGS 4 /* usRegInputBuf数组大小 */\r#define REG_HOLDING_START 2000 /* 保持寄存器开始地址 */\r#define REG_HOLDING_NREGS 130 /* usRegHoldingBuf数组大小 */\rint main()\r{\r/*RTUm模式 从机地址 uart 波特率 奇偶无校验 */\reMBInit( MB_RTU, 0x05,0,115200, MB_PAR_NONE );\rif(eMBEnable( )== MB_ENOERR)\r{ for( ;; )\r{\r// Call the main polling loop of the Modbus protocol stack.\rif( eMBPoll( ) != MB_ENOERR )\rbreak;\r}\rstd::cerr\u0026lt;\u0026lt;\u0026quot;err: eMBPoll failed!\u0026quot;;\r}\relse\r{\rstd::cerr\u0026lt;\u0026lt;\u0026quot;err: eMBEnable failed!\u0026quot;;\r}\rreturn 0;\r}\r/* ----------------------- Static variables ---------------------------------*/\rstatic USHORT usRegInputStart = REG_INPUT_START;\rstatic USHORT usRegInputBuf[REG_INPUT_NREGS]={0x1,0x2,0x3,0x4}; //输入寄存器数组\rstatic USHORT usRegHoldingStart = REG_HOLDING_START;\rstatic USHORT usRegHoldingBuf[REG_HOLDING_NREGS];//保持寄存器数组\r/* 输入寄存器 */\reMBErrorCode eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress,USHORT usNRegs )\r{\reMBErrorCode eStatus = MB_ENOERR;\rint iRegIndex;\rstd::cout\u0026lt;\u0026lt;\u0026quot;enter\\n\u0026quot;;\r/**\r* 满足条件：\r* 1. 主机请求地址大于REG_INPUT_START\r* 2. 主机请求数据量不超过 usRegInputBuf数组大小\r*/\rif( ( usAddress \u0026gt;= REG_INPUT_START )\r\u0026amp;\u0026amp; ( usAddress + usNRegs \u0026lt;= REG_INPUT_START + REG_INPUT_NREGS ) )\r{\riRegIndex = ( int )( usAddress - usRegInputStart );\rwhile( usNRegs \u0026gt; 0 )\r{\r*pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] \u0026gt;\u0026gt; 8 );\r*pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] \u0026amp; 0xFF );\riRegIndex++;\rusNRegs--;\r}\r}\relse\r{\reStatus = MB_ENOREG;\r}\rreturn eStatus;\r}\r/* 保持寄存器 */\reMBErrorCode eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress,USHORT usNRegs, eMBRegisterMode eMode )\r{\r}\r/* 线圈寄存器 */\reMBErrorCode eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress,USHORT usNCoils, eMBRegisterMode eMode )\r{\r}\r/* 离散输入寄存器 */\reMBErrorCode eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress,USHORT usNDiscrete )\r{\r}\r","id":30,"section":"categories","summary":"freemodus 源码 cwalter-at/freemodbus armink/FreeModbus_Slave-Master-RTT-STM32: Add master mode to FreeModbus. | 在 FreeModbus 中添加主机模式 (github.com) modbus 0x01 读线圈寄存器 0x02 读离散输入寄存器 0x03 读保持寄存器 0x04 读输入寄存器 0x05 写单个线圈寄存器 0x06 写单个保持寄存器","tags":["project","c"],"title":"Freemodbus","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/freemodbus/","year":"2022"},{"content":"matlab\u0026ndash;符号表达式转LaTeX、C、mathml代码 网址\u0026ndash;Code Generation - MATLAB \u0026amp; Simulink - MathWorks 中国\nlatex syms f(t);\ry=f==5*exp(-0.8*t)*sin(pi*t);\rlatex(y)\rans= \u0026lsquo;f\\left(t\\right)=5,{\\mathrm{e}}^{-\\frac{4,t}{5}},\\sin\\left(\\pi ,t\\right)\u0026rsquo;\nMathml syms f(t);\ry=f==5*exp(-0.8*t)*sin(pi*t);\rmathml(y)\rf\r(\rt\r)\r\u0026equals;\r5\r\u0026InvisibleTimes;\r\u0026ee;\r-\r4\r\u0026InvisibleTimes;\rt\r5\r\u0026InvisibleTimes;\rsin\r(\r\u0026pi;\r\u0026InvisibleTimes;\rt\r)\rC 1. 得到一个函数表达式\rsyms f(t);\rf=5*exp(-0.8*t)*sin(pi*t);\rccode(f)\r2. 矩阵\rI3 = sym(eye(3));\rI3code = ccode(I3)\r结果\nans =' t0 = exp(t*(-4.0/5.0))*sin(t*3.141592653589793)*5.0;'\rI3code =\r' I3[0][0] = 1.0;\rI3[1][1] = 1.0;\rI3[2][2] = 1.0;'\r","id":31,"section":"categories","summary":"matlab\u0026ndash;符号表达式转LaTeX、C、mathml代码 网址\u0026ndash;Code Generation - MATLAB \u0026amp; Simulink - MathWorks 中国 latex syms f(t); y=f==5*exp(-0.8*t)*sin(pi*t); latex(y) ans= \u0026lsquo;f\\left(t\\right)=5,{\\mathrm{e}}^{-\\frac{4,t}{5}},\\sin\\left(\\pi ,t\\right)\u0026rsquo; Mathml syms f(t); y=f==5*exp(-0.8*t)*sin(pi*t); mathml(y)","tags":[" matlab"],"title":"matlab--符号表达式转LaTeX、C、mathml代码","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/matlab/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/","year":"2022"},{"content":"Matlab中一些画图方式 符号表达式-画图 fimplicit 隐函数 fimplicit3 Plot 3-D implicit equation or function fmesh Plot 3-D mesh fplot 一般式、参数方程 fplot3 Plot 3-D parametric curve fsurf Plot 3-D surface ezpolar 极坐标 fcontour 3维，等高线 例子\nfigure(1);\rsyms f(t);\rf=5*exp(-0.8*t)*sin(pi*t);\rfplot(f,[0,5]);\r符号表达式-动画 fanimator Create stop-motion animation object(创造动画对象) playAnimation Play animation objects in a MATLAB figure window(播放) rewindAnimation Rewind previously played animation objects（回放） writeAnimation Save animation as video file(保存) animationToFrame Return structure of frames from animation objects（用一个数组存储每一帧） 例子\nsyms y(x) t;\rfigure(1);\ry=sin(x);\rfanimator(@fplot,x,y,[0 t],\u0026quot;FrameRate\u0026quot;,2)%帧率为2\raxis equal %xy轴相等\rplayAnimation(figure(4),'AnimationRange',[0 15]);%t的取值范围定为[0 15]\rwriteAnimation('wheel.gif')%保存为GIF\r","id":32,"section":"categories","summary":"Matlab中一些画图方式 符号表达式-画图 fimplicit 隐函数 fimplicit3 Plot 3-D implicit equation or function fmesh Plot 3-D mesh fplot 一般式、参数方程 fplot3 Plot 3-D parametric curve fsurf Plot 3-D surface ezpolar 极坐标 fcontour 3维，等高线 例子 figure(1); syms f(t);","tags":[" matlab"],"title":"matlab-画图","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/matlab/%E7%94%BB%E5%9B%BE/","year":"2022"},{"content":"周期信号的傅里叶级数表示 知识回顾 欧拉公式 复分析的欧拉公式特例\n假设$z=r(cos(\\theta )+ isin(\\theta))$\n复数的乘除公式 $$Z_{1}Z_{2}=(r_{1}r_{2})(cos(ArgZ_{1}+Arg Z_{2})+isin(ArgZ_{1}+ArgZ_{2}))$$\n$$\\frac{Z_{1}}{Z_{2}}=(\\frac{r_{1}}{r_{2}} )(cos(ArgZ_{1}-Arg Z_{2})+isin(ArgZ_{1}-ArgZ_{2}))$$\n复数的乘幂公式 ","id":33,"section":"categories","summary":"周期信号的傅里叶级数表示 知识回顾 欧拉公式 复分析的欧拉公式特例 假设$z=r(cos(\\theta )+ isin(\\theta))$ 复数的乘除公式 $$Z_{1}Z_{2}=(r_{1}r_{2})(cos(ArgZ_{1}+Arg Z_{2})+isin(ArgZ_{1}+ArgZ_{2}))$$ $$\\frac{Z_{1}}{Z_{2}}=(\\frac{r_{1}}{r_{2}} )(cos(ArgZ_{1}-Arg Z_{2})+isin(ArgZ_{1}-ArgZ_{2}))$$ 复数的乘幂公式","tags":[],"title":"《信号与系统》读书笔记2","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/signalsandsystems/bookmark2/","year":"2022"},{"content":"LTS 卷积的概念 连续系统:\n$$(f * g)(n)=\\int_{-\\infty}^{\\infty} f(\\tau) g(n-\\tau) d \\tau$$\n离散系统:\n$$(f * g)(n)=\\sum_{\\tau=-\\infty}^{\\infty} f(\\tau) g(n-\\tau)$$\n卷积这个名词的理解：**所谓两个函数的卷积，本质上就是先将一个函数翻转，然后进行滑动叠加。**在连续情况下，叠加指的是对两个函数的乘积求积分。在离散情况下就是加权求和，为简单起见就统一称为叠加。\n离散时间线性时不变(LTS)系统：卷积和 $x[n]=\\sum_{k=-\\infty}^{+\\infty}x[k]\\delta [n-k]$\u0026mdash;\u0026mdash;$x[k]$是线性组合式中的权因子 $y[n]=\\sum_{k=-\\infty}^{+\\infty}x[k]h_{k} [n]$，令$h_{k}[n]$(即$h_{0}[n-k]$)为线性系统对移动单位脉冲$\\delta[n-k]$的响应 LTS系统的单位脉冲响应可以完全刻画系统的特征。 ","id":34,"section":"categories","summary":"LTS 卷积的概念 连续系统: $$(f * g)(n)=\\int_{-\\infty}^{\\infty} f(\\tau) g(n-\\tau) d \\tau$$ 离散系统: $$(f * g)(n)=\\sum_{\\tau=-\\infty}^{\\infty} f(\\tau) g(n-\\tau)$$ 卷积这个名词的理解：**所谓两个函数的卷积，本质上就是先将一个函数翻转，然后进行滑动","tags":[],"title":"《信号与系统》读书笔记1--LTS","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/signalsandsystems/bookmark1/","year":"2022"},{"content":"command 1. 常用命令 1.1 新建文档 math类\rhugo new categories/math/\r--\u0026gt; hugo new categories/math/signalsAndSystems/\rapp类\rhugo new categories/app/\ros类\rhugo new categories/os/\rrobat类\rhugo new categories/robat/\rlang类\rhugo new categories/lang/\rother类\rhugo new categories/other/\r1.2 上传命令 CMD hugo -D \u0026amp;\u0026amp; git add .\u0026amp;\u0026amp;git commit -m \u0026quot;\u0026quot;\rgit push \u0026amp;\u0026amp; tcb hosting deploy ./public -e blog-0g8860131649bb29\rpowershell hugo -D | git add .|git commit -m \u0026quot;\u0026quot;\rgit push | tcb hosting deploy ./public -e blog-0g8860131649bb29\r1.3 markdown技巧 打开调试，获取bilibili的aid console.log(playerInfo.aid)\rnote：去除'\\'\r{\\{\u0026lt; bilibili aid \u0026gt;}\\}\r跳转 []({\\{\u0026lt; ref \u0026quot;blog/neat.md\u0026quot; \u0026gt;}\\})\r2. 腾讯云部署 静态网站托管 部署 Hugo - 最佳实践 - 文档中心 - 腾讯云 (tencent.com)\n3.hugo hugo-theme-pure/README-ZH.md at master · xiaoheiAh/hugo-theme-pure (github.com)\nnote: 注意submoudel\n","id":35,"section":"categories","summary":"command 1. 常用命令 1.1 新建文档 math类 hugo new categories/math/ --\u0026gt; hugo new categories/math/signalsAndSystems/ app类 hugo new categories/app/ os类 hugo new categories/os/ robat类 hugo new categories/robat/ lang类 hugo new categories/lang/ other类 hugo new categories/other/ 1.2 上传命令 CMD hugo -D","tags":["blog","command"],"title":"一些部署博客blog的常用指令","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/other/blog/command/","year":"2022"},{"content":"希腊字母 ","id":36,"section":"categories","summary":"希腊字母","tags":[" math"],"title":"希腊字母","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/other/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D/","year":"2022"},{"content":"win10安装clash 1.下载 clash for win软件是一个开源项目，被开源在github上，它是具有windows,mac,linux(x86和arm)多版本的gui软件。\n点击跳转：开源地址\n由于github的网站位于国外，可能打不开，下载地址如下：\n点击下载:clash下载地址\n2.安装 解压软件包\n软件包是安装的，可以直接运行\n3.汉化 由于软件是国外开发的，所以gui界面文字是英语，我们需要将它汉化。\n汉化教程在github上开源的 点击跳转：开源地址 点击下载：汉化包下载地址 - 解压汉化包，得到一个app.asar文件，用汉化包中的app.asar替换resources/app.asar 启动clash\r4.节点导入 导入yaml配置文件\n4.1 在线转换 v2ray转换到clash,将vmess协议转换为yaml配置文件在线小工具 点击跳转\n由于是纯前端的转换工具，所以加载可能有点慢，耐心等待一下 转换完成后，下载yaml文件，然后见上图，导入yaml文件 4.2 自己配置yaml文件模板 ​\tClash支持SS、V2ray和trojan协议\n深入理解Clash配置文件 - VPS攻略 (vpsgongyi.com)\n开启系统代理\n检测网络是否通\n大功告成！！！\n","id":37,"section":"categories","summary":"win10安装clash 1.下载 clash for win软件是一个开源项目，被开源在github上，它是具有windows,mac,linux(x86和a","tags":["net"],"title":"clash：一款代理科学上网的软件","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/app/clash/","year":"2022"},{"content":"概率论与数理统计 古典概型 试验中所有可能出现的基本事件只有有限个 试验中每个基本事件出现的可能性相等。 具有以上两个特点的概率模型是大量存在的，这种概率模型称为古典概率模型，简称古典概型，也叫等可能概型\n几何概型： 无限性：试验中所有可能出现的基本事件（结果）有无限多个. 等可能性：每个基本事件出现的可能性相等. 如果每个事件发生的概率只与构成该事件区域的长度(面积或体积或度数)成比例，则称这样的概率模型为几何概率模型，简称为几何概型。古典概型与几何概型的主要区别在于：几何概型是另一类等可能概型，它与古典概型的区别在于试验的结果是无限个。\n全概率公式 意义：全概率公式为概率论中的重要公式，它将对一复杂事件A的概率求解问题转化为了在不同情况下发生的简单事件的概率的求和问题。\n内容：如果事件B1、B2、B3…Bi构成一个完备事件组，即它们两两互不相容，其和为全集；并且P（Bi)大于0，则对任一事件A有\nP(A)=P(A|B1)P(B1) + P(A|B2)P(B2) + ... + P(A|Bi)P(Bi)\r\u0026emsp;\u0026emsp;概率论的一个重要内容是研究怎样从一些较简单事件概率的计算来推算较复杂事件的概率，全概率公式和Bayes公式正好起到了这样的作用。\r贝叶斯公式 $$ P(A|B)=\\frac{P(B|A)P(A)}{P(B)} $$ 贝叶斯公式用来描述两个条件概率之间的关系。即通常，事件A在事件B(发生)的条件下的概率，与事件B在事件A的条件下的概率是不一样的；然而，这两者是有确定的关系,贝叶斯法则就是这种关系的陈述。\n在贝叶斯法则中，每个名词都有约定俗成的名称：\nP(A)是A的先验概率或边缘概率。之所以称为\u0026quot;先验\u0026quot;是因为它不考虑任何B方面的因素。 P(A|B)是已知B发生后A的条件概率，也由于得自B的取值而被称作A的后验概率。 P(B|A)是已知A发生后B的条件概率，也由于得自A的取值而被称作B的后验概率。 P(B)是B的先验概率或边缘概率，也作标准化常量（normalized constant）。 按这些术语，Bayes法则可表述为：\n后验概率 = (似然度 * 先验概率)/标准化常量\n也就是说，后验概率与先验概率和似然度的乘积成正比。\n另外，比例Pr(B|A)/Pr(B)也有时被称作标准似然度（standardised likelihood），Bayes法则可表述为： 后验概率 = 标准似然度 * 先验概率。 [1]\n1.可测空间\n2.常用的一维分布\n链接\n","id":38,"section":"categories","summary":"概率论与数理统计 古典概型 试验中所有可能出现的基本事件只有有限个 试验中每个基本事件出现的可能性相等。 具有以上两个特点的概率模型是大量存在的，这","tags":["概率论"],"title":"概率论学习之旅1","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/probability/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%851/","year":"2022"},{"content":"ROS的使用 一、安装ros 脚本安装 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; sudo bash fishros\r原文章链接：鱼香ros\nrosdep 安装 note: 注意安装ros过程中，可以不安装rosdep，它不是ros系统必须安装的，它的功能类似于ubuntu中的apt\n，当我们安装ros的一些功能包的时候，也可以用apt安装，可以不用rosdep\n参考视频：小鱼在古月居开课视频\u0026ndash;聊聊ROS安装过程中的那些坑\n二、ros的常用命令 创建ros工作空间 mkdir -p ~/catkin_ws/src\rcd ~/catkin_ws\rcatkin_make\rsource devel/setup.bash\recho $ROS_PACKAGE_PATH\recho \u0026quot;source /home/chao/Desktop/code/02c/ros1/src/devel/setup.bash\u0026quot; \u0026gt;\u0026gt; ~/.bashrc 创建ros程序包 cd ~/catkin_ws/src\rcatkin_create_pkg beginner_tutorials std_msgs rospy roscpp\rros参数命令 rosparam set [param_name] 设置参数\rrosparam get [param_name] 获取参数\rrosparam load params.yaml 从文件中加载参数\rrosparam dump params.yaml 向文件中转储参数\rrosparam delete [param_name] 删除参数\rrosparam list 列出参数名\r三、ros的使用教程 1. 发布者与订阅者 2.服务器 3.tf函数的使用 安装 sudo apt install ros-melodic-turtle-tf\r可视化观测tf tree #pdf\rrosrun tf view_frames\r#stdout\rrosrun tf tf_echo node1 nodde2\r常用的tf坐标系 laser_link：激光雷达\rbase_link：车体\rodom:里程计坐标系\rmap：单个机器人全局坐标系\rearth：多个机器人协作\rros坐标转换的类 rosmsg info geometry_msgs/TransformStamped\rgeometry_msgs头文件内容 Accel.h AccelStamped.h AccelWithCovariance.h AccelWithCovarianceStamped.h Inertia.h\rInertiaStamped.h\rPoint32.h\rPoint.h\rPointStamped.h\rPolygon.h\rPolygonStamped.h\rPose2D.h\rPoseArray.h\rPose.h\rPoseStamped.h\rPoseWithCovariance.h\rPoseWithCovarianceStamped.h\rQuaternion.h QuaternionStamped.h Transform.h TransformStamped.h Twist.h TwistStamped.h TwistWithCovariance.h\rTwistWithCovarianceStamped.h Vector3.h\rVector3Stamped.h\rWrench.h\rWrenchStamped.h\r1. geometry_msgs::TransformStamped 坐标系之间的关联信息\nstd_msgs/Header header\ruint32 seq\rtime stamp\rstring frame_id\rstring child_frame_id\rgeometry_msgs/Transform transform\rgeometry_msgs/Vector3 translation\rfloat64 x\rfloat64 y\rfloat64 z\rgeometry_msgs/Quaternion rotation\rfloat64 x\rfloat64 y\rfloat64 z\rfloat64 w\r2.geometry_msgs/PointStamped 坐标点信息\nstd_msgs/Header header\ruint32 seq\rtime stamp\rstring frame_id\rgeometry_msgs/Point point\rfloat64 x\rfloat64 y\rfloat64 z\r四、launch文件的使用 \u0026lt;?xml version=\u0026quot;1.0\u0026quot;?\u0026gt;\r\u0026lt;launch\u0026gt;\r\u0026lt;include file=\u0026quot;$(find pepperl_fuchs_r2000)/launch/r2000.launch\u0026quot;/\u0026gt;\r\u0026lt;!--pkg:功能包名称(文件夹) type：节点的可执行文件名称。name：运行节点名（优先级高于ros::init()中的参数） --\u0026gt;\r\u0026lt;node pkg=\u0026quot;\u0026quot; type=\u0026quot;\u0026quot; name=\u0026quot;\u0026quot; output=\u0026quot;screen\u0026quot;\u0026gt;\u0026lt;/node\u0026gt;\r\u0026lt;/launch\u0026gt;\r五、VScode的配置 头文件智能提示 进入c/c++插件 配置头文件路径\nros中文乱码问题 setlocale(LC_ALL,\u0026quot;\u0026quot;);\rc_cpp_properties.json {\r\u0026quot;configurations\u0026quot;: [\r{\r\u0026quot;name\u0026quot;: \u0026quot;linux\u0026quot;,\r\u0026quot;includePath\u0026quot;: [\r\u0026quot;/opt/ros/melodic/include\u0026quot;,\r\u0026quot;/usr/include\u0026quot;,\r\u0026quot;${workspaceFolder}/**\u0026quot;,\r\u0026quot;${workspaceFolder}/devel/include\u0026quot;\r],\r\u0026quot;intelliSenseMode\u0026quot;: \u0026quot;linux-gcc-x64\u0026quot;,\r\u0026quot;compilerPath\u0026quot;: \u0026quot;/usr/bin/gcc\u0026quot;,\r\u0026quot;cppStandard\u0026quot;: \u0026quot;c++17\u0026quot;,\r\u0026quot;cStandard\u0026quot;: \u0026quot;c17\u0026quot;\r}\r],\r\u0026quot;version\u0026quot;: 4\r}\r六、xlaunch的使用 1.安装VcXsrv 2.解决wsl2 ping不通windows，而windows可以ping通wsl2 管理员终端设置防火墙\nNew-NetFirewallRule -DisplayName \u0026quot;WSL\u0026quot; -Direction Inbound -InterfaceAlias \u0026quot;vEthernet (WSL)\u0026quot; -Action Allow\r3.解决wsl每次重启之后IP地址都会重新配置和分配 nano ~/.bashrc\r加入\r#########display############\rexport LIBGL_ALWAYS_INDIRECT=0 #直接硬件渲染\rexport DISPLAY=$(awk '/nameserver / {print $2; exit}' /etc/resolv.conf 2\u0026gt;/dev/null):0\r############################\rsource ~/.bashrc\r4.xlaunch设置\n参数-ac 等同 Disable access control的作用一样，允许所有客户端程序都能连接上这个VcXsrv\n七、gazebo使用 一、报错 运行gazebo报错libcurl: (51) SSL\nnano ~/.ignition/fuel/config.yaml\r把api.ignitionfuel.org换成 fuel.ignitionrobotics.org，然后保存退出\r二、gazebo插件 cd ~/.gazebo \u0026amp;\u0026amp; git clone git@github.com:osrf/gazebo_models.git\rmv gazebo_models models\r三、验证 八、ros相关功能包收集 scan_tools\rrf2o_laser_odometry\rrobot_localization\r在robot_localization包中包含了两个状态估计节点\r1. ekf_localization_node 是一个扩展卡尔曼估计器，它使用一个三维测量模型随着时间生成状态，同时利用感知数据校正已经监测过的估计。\r2. ukf_localization_node 是一个无迹卡尔曼滤波估计器，它使用一系列sigma点通过非线性变换生成状态，并使用这些估计过的sigma点覆盖状态估计点和协方差，这个估计使用雅克比矩阵并使得估计器更加稳定。然而缺点是比ekf_localization_node耗费更大的计算量。\r","id":39,"section":"categories","summary":"ROS的使用 一、安装ros 脚本安装 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; sudo bash fishros 原文章链接：鱼香ros rosdep 安装 note: 注意安装ros过程中，可以不安装rosdep，它不是ros系","tags":["ros"],"title":"ROS的使用","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robot/ros%E7%9A%84%E4%BD%BF%E7%94%A8/","year":"2022"},{"content":"网络配置 ubuntu18.04配置IP 使用ip addr 只限于以太网配置(临时)\rip addr add 192.168.8.30/24 dev eth0\r/etc/netplan/*配置文件 服务器中是50-cloud-init.yaml,桌面版01-network-manager-all.yaml\n信息格式如下：\nnetwork:\rethernets:\reth0:\rdhcp4: no\raddresses: [192.168.30.201/24]\roptional: true\reth1:\rdhcp4: no\raddresses: [192.168.30.202/24]\roptional: true\rversion: 2\rwifis:\rwlan0:\raccess-points:\rchao:\rpassword: '88888888'\rdhcp4: true\roptional: true\r","id":40,"section":"categories","summary":"网络配置 ubuntu18.04配置IP 使用ip addr 只限于以太网配置(临时) ip addr add 192.168.8.30/24 dev eth0 /etc/netplan/*配置文件 服务器中是50-cl","tags":["linux","net"],"title":"eth wifi 网络配置","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/linux/etc/eth_wifi%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","year":"2022"},{"content":"slam资料汇集 ros学习网站收集 Ros官网 wiki.ros.org 中国大学MOOC\u0026mdash;《机器人操作系统入门》课程讲义 中国大学MOOC\u0026mdash;《智能机器人系统》 创客智造 zhangrelay的专栏 古月居 易科机器人实验室 ROBOTIS 知乎\u0026ndash;SLAM开发最强最全资源汇总 2D激光slam发展历史 书籍 机器人导论\n现代机器人学\n概率机器人\n机器人学中的状态估计\n视觉slam十四讲\n机器人感知：因子图在slam中的应用\n卡尔曼滤波及其实时应用\n","id":41,"section":"categories","summary":"slam资料汇集 ros学习网站收集 Ros官网 wiki.ros.org 中国大学MOOC\u0026mdash;《机器人操作系统入门》课程讲义 中国大学MOOC\u0026mdash;《智","tags":["slam"],"title":"slam的相关资料：一","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robot/slam%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/","year":"2022"},{"content":"一、wsl与wsl2相互切换 1.开启windows相关功能 2.安装Windows升级软件 3.重启，然后“管理员终端” wsl --set-version \u0026lt;分发版名称 wsl -l -v 查看\u0026gt; 2或1\r二、如何在wsl中使用网络代理？ wsl2需要在管理员终端，先开启windows防火墙权限\nNew-NetFirewallRule -DisplayName \u0026quot;WSL\u0026quot; -Direction Inbound -InterfaceAlias \u0026quot;vEthernet (WSL)\u0026quot; -Action Allow\r打开clash的端口\n代理端口设置\nnano ~/.bashrc\r#加入，其中7890为clash的代理端口\rhostip=$(cat /etc/resolv.conf |grep -oP '(?\u0026lt;=nameserver\\ ).*')\rexport https_proxy=\u0026quot;http://${hostip}:7890\u0026quot;\rexport http_proxy=\u0026quot;http://${hostip}:7890\u0026quot;\rexport all_proxy=\u0026quot;socks5://${hostip}:7890\u0026quot;\r三、WSL2中使用USB WSL2连接 USB 设备 - liu-huan - 博客园 (cnblogs.com)\n需要Linux 内核 5.10.60.1 或更高版本\nuname -a查看版本号\n更新\nwsl --update\r安装 USBIPD-WIN 项目\n连接 USB 设备 | Microsoft Learn\n","id":42,"section":"categories","summary":"一、wsl与wsl2相互切换 1.开启windows相关功能 2.安装Windows升级软件 3.重启，然后“管理员终端” wsl --set-version \u0026lt;分发版名称 wsl","tags":[" wsl"],"title":"wsl：window下一款Linux环境","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/test-post/","year":"2022"},{"content":"继承与面向对象设计 条款32：确定你的public继承塑模出“is-a”（是一种）关系 结论 “public继承关系”意味is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，每一个derived classes对象也是一个base class对象\n存在于classes之间的三种关系： is-a （是一个）A是B has-a（有一个，条款38）A有B is-implemented-in-term-of(根据某物实现出，条款39) 条款33：避免遮掩继承而来的名称 结论 derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。 为了让被遮掩的名称再见天日，可以使用using声明式或转交函数。 条款34：区分接口继承和实现继承 结论 接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口。\npure vitrual（纯虚函数）只具体指定接口继承。\nimpure vitrual(非纯函数)具体指定指定接口继承和缺省实现继承（可以覆写）。\nnon-virtual（成员函数）具体指定接口继承以及强制性实现继承。\n条款35：考虑virtual函数以外的其他选择 结论 virtual函数的替代方案包括NVI手法及Strategy（策略）设计模式的多种形式。NVI手法自身是一种特殊形式的Template Method设计模式。 将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。 trl::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物 条款36：绝不重新定义继承而来的non-virtual函数 原因 违反\u0026quot;is-a\u0026quot;的继承体系\n条款37： 绝不重新定义继承而来的缺省参数值 结论 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数\u0026mdash;你唯一应该覆写的东西\u0026mdash;-却是动态绑定。\n原因 你只能继承两种函数：virtual 和 non-virtual函数。然而重新定义一个继承而来的non-virtual函数永远是错误（条款36）\nvirtual函数系动态绑定，而缺省参数值却是静态绑定。\n条款38：通过复合塑模出“has-a”或“根据某物实现出” 结论 复合关系的意义和public继承关系完全不同 在应用域，在复合意味has-a（有一个）。在实现域，复合意味is-implemented-in-terms-of(根据某物实现出)。 内容 继承关系 复合关系\n在程序员之间，复合这个词有很多同义词，譬如分层、内含、聚合、内嵌。\n应用域 相当于塑造的世界中的某些事物，例如人、汽车\n实现域 实现细节上的人工制品，例如缓冲区、互斥器、查找树\n条款39：明智而审慎地使用private继承 结论 private继承关系意味着is-implemented-in-terms-of(根据某物实现出)。它通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。 和复合不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。 原因 C++将public继承视为is-a关系\n​\t将private继承视为is-implemented-in-terms-of(根据某物实现出)\n注意：private继承纯粹只是一种实现技术（private base class的每样东西在你的class内都是private） 如非必要（必要条件，见P188），在复合与private继承中，尽量选择复合。\n条款40：明智而审慎地使用多重继承 结论 多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。 virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes不会带任何数据，将是最具实用价值的情况。 多重继承的确有正当用途。其中一个情景涉及“public继承某个interface class”和“private继承某个协助实现的class”两相组合。 ","id":43,"section":"categories","summary":"继承与面向对象设计 条款32：确定你的public继承塑模出“is-a”（是一种）关系 结论 “public继承关系”意味is-a。适用于base","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记5","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/5/","year":"2021"},{"content":"实现 大多情况下，适当提出你的class（和class templates）定义以及functions(和 function templates)声明，是花费最多心力的两件事。\n实现大多直截了当，但实现仍然有一些东西要小心。\n条款26：尽可能延后变量定义式的出现时间 结论 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序的效率。\n原因 只要你定义了一个变量而其类型带有一个构造函数或析构函数，\n那么当程序的控制流到达这个变量定义式时，你便得承受构造成本；\n当这个变量离开其作用域时，你便要承受析构成本。\n即使这个变量最终并未被使用，仍需消耗这些成本。\nstd::string encrytPassword(const std::string\u0026amp;　password)\r{\rusing namespace std;\rstring encrypted;\rif(password.length()\u0026lt;MinimumPasswordLength){\rthrow logic_error(\u0026quot;Password is too short\u0026quot;);\r}\r...\t//必要动作，将一个加密后的密码置入变量encrypted内\rreturn encrypted;\r}\r如果密码长度不够，丢出异常，那么string encrypted被构造了，也被析构了，但没有被使用。\nP116重要，关于循环体内的定义 条款27：尽量少做转型动作 结论 如果可以，尽量避免转型，特别是注重效率的代码中避免dynamic_casts。如果有个设计需要转型设计，试着发展无需转型的替代设计 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要转型放进它们自己的代码内。 宁可使用C++style（新式）转型，不要使用旧式转型。 条款28：避免返回handles指向对象内部成分（即它的成员变量） 结论 避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条约可增加封装性，帮助cosnt成员函数的行为更像const，并将发生内存对象被销毁的可能性降到最低。\n原因 假设你的程序涉及矩形，每一个矩形由其左上角和右下角表示。\nclass Point{\t//这个class用来表述“点”\rpublic：\rpoint（int x,int y）;\r...\rvoid setX（int newVal）;\rvoid setY(int newval);\r...\r}\rstruct RectData{\t//这些点数据用来表现一个矩形\rPoint ulhc;\t//ulhc=\u0026quot;右下角\u0026quot;\rPoint lrhc;//lrhc=\u0026quot;右上角\u0026quot;\r};\rclass Rectangle{\r....\rprivate:\rstd::trl::shared_ptr\u0026lt;RectData\u0026gt; pData;\r};\rby reference 方式传递用户自定义类型往往比by value方式更高效\nclass Rectangle{\rpublic：\r....\rPoint\u0026amp; upperLeft() const { return pData-\u0026gt;ulhc;}\rPoint\u0026amp; upperRight() const { return pData-\u0026gt;lrhc;}\r}\rconst成员函数：若将成员成员函数声明为const，则该函数不允许修改类的数据成员，但若数据成员是指针，则还是可以修改指针指向的内容\nupperLeft和upperRight被声明为const成员函数，是为了提供客户一个得知Rectangle相关坐标点的方法，而不是让客户修改Rectangle（客户是可以通过by reference修改内部数据）。\n解决方法 它们的返回类型加上const\nclass Rectangle\r{\rpublic：\r...\rconst Point\u0026amp; upperLeft() const{ return pData-\u0026gt;ulhc;}\rconst Point\u0026amp; lowerRight() const {return pData-\u0026gt;lrhc;}\r...\r}\r条款29：为“异常安全”而努力是值得的 结论 异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型 “强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。 \u0026ldquo;COPY-AND-SWAP\u0026quot;技术 按照C++ primer的理解，赋值运算符（A=B）应该实现两个方面的工作：\n1.析构函数（删除A原有的内容）\n2.拷贝构造函数（将B的值赋值给A）\nClassA\u0026amp; ClassA::operator= (\u0026hellip;.): 首先把\u0026rdquo;=\u0026ldquo;右边的值复制到\u0026rdquo;=\u0026ldquo;左边, 然后析构\u0026rdquo;=\u0026ldquo;左边的值;\n为了保证可以自赋值(self-assignment), 需要使用****临时变量****存储, 再删除对象;\nclass A {\rprivate:\rint *b;\rint a;\rpublic:\rA():a(0),b(nullptr){};\rA(const A\u0026amp;rhs):a(rhs.a),b(rhs.b==nullptr?nullptr:new int(*rhs.b)){};\r~A(){\rdelete b;\rb = nullptr;\r};\r};\rA\u0026amp; operator=(const A\u0026amp; rhs) {\rif(this!=\u0026amp;rhs) { // 防止自赋值\rdelete b;\rthis-\u0026gt;b = new int(*rhs.b);// 可能失败\rthis-\u0026gt;a = rhs.a;\r}\rreturn *this; // 返回this对象的引用\r}\r可以看到我们的代码几乎是对拷贝构造函数和析构函数的完全复制，此外，上述代码虽然完成了自赋值的验证，但并未保障异常安全。一旦new失败，原this对象的b已经被删除，因此会引发异常。\n异常不安全主要在于，b对应的对象可能在异常到来之前被删除。因此我们首先保存该对象的副本，从而保证了异常安全特性，无论new是否成功，this对象中的b指针都会指向已知对象 A\u0026amp; operator=(const A\u0026amp; rhs) {\rauto orign = this-\u0026gt;b;\t//使b指针所指向的内存有orgin指针指向\rthis-\u0026gt;b = new int(*rhs.b);\rdelete orign;\rthis-\u0026gt;a = rhs.a;\rreturn *this;\r}\rcopy and swap 为了使用copy-swap，我们需要三件事：\n一个有效的拷贝构造函数 一个有效的析构函数 一个自定义的交换函数，不能用std::swap,因为该函数实现中调用了拷贝构造和复制函数，且交换函数不抛异常 该技术的核心就是不再使用引用作为赋值运算符参数，形参将直接是对象，这样的写法将会使编译器自动调用拷贝构造函数，由于拷贝构造函数的调用，异常安全将在进入函数体之前被避免（若拷贝失败则什么都不会发生）。经过swap后的对象在离开函数体后会自动销毁，因此也就自动调用了析构函数，具体写法如下： ———————————————— 版权声明：本文为CSDN博主「feifeiiong」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/feifeiiong/article/details/77866579\nvoid swap(A\u0026amp; rhs) {\rusing std::swap;\rswap(this-\u0026gt;a,rhs.a);\rswap(this-\u0026gt;b,rhs.b);\r}\rA\u0026amp; operator=(A rhs) {\rswap(rhs);\rreturn *this;\r}\r网络资源：\nhttps://blog.csdn.net/hiwubihe/article/details/116667884?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162631218716780264010481%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D\u0026amp;request_id=162631218716780264010481\u0026amp;biz_id=0\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-10-116667884.first_rank_v2_pc_rank_v29\u0026amp;utm_term=copy+and+swap\u0026amp;spm=1018.2226.3001.4187 条款30：透彻了解inlining的里里外外 结论 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更为容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。 不要只因为function templates出现在头文件，就将它们声明为inline。 原因 一开始先不要将任何函数声明为inline，或者至少将inline施行范围局限在那些“一定成为inline（条款46）”或“十分平淡无奇”的函数身上，可以使程序达到优化。\n（28法则）平均而言一个程序往往将80%的执行时间花费在20%的代码上头，作为软件开发者，我们的目标是找出这可以有效增进程序整体效率的20%的代码\ninline缺点：\n以代码膨胀为代价 空间换时间\ninline对于编译器而言，只是建议。\n建议：\n开栈的开销 \u0026gt; 执行的开销 建议设为inline 开栈的开销 \u0026lt; 执行的开销 不建议 为什么使用inline关键字？ 1.1为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）。 在预编译的时候，编译器将程序中出现的内联函数的调用表达式的地方直接插入用内联函数的代码。\n条款31：将文件间的编译依存关系降到最低 结论 支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和interface classes 程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及templates都适合。 方法 pimpl idiom技术\nhttps://blog.csdn.net/qq_33775402/article/details/76274678?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162632039416780261938712%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D\u0026amp;request_id=162632039416780261938712\u0026amp;biz_id=0\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-4-76274678.first_rank_v2_pc_rank_v29\u0026amp;utm_term=%E9%99%8D%E4%BD%8E%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB\u0026amp;spm=1018.2226.3001.4187\n","id":44,"section":"categories","summary":"实现 大多情况下，适当提出你的class（和class templates）定义以及functions(和 function templates)声明，是花费最多","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记4","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/4/","year":"2021"},{"content":"资源管理 资源：一旦用了它，将来必须还给系统。\n譬如：动态分配内存、文件描述器、互斥锁、图形界面中的字型和笔刷、数据库连接、网络sockets。\n条款13：以对象管理资源 创建一个对象管理资源，资源管理类\n结论 ​\t1.为防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。\n​\t2.两个常被使用的RAII classes分别trl::share_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为直观。\n条款14：在资源管理中，小心copying行为 copying行为也应该参考\n浅拷贝\u0026amp;\u0026amp;深拷贝\n结论 1.复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。\n2.普遍而常见的RAII class copying行为是：禁止copying、施行引用计数法。\n原因 资源管理类对象被复制，是一件不合理的行为，因为例如“互斥锁”、“动态内存分配”、等是具有唯一性的，两个对象的指针同时指向同一块内存，那么对象销毁时，内存释放，就必然一个指针称为悬空指针。\n解决方法 因此：有两种做法：\n禁止复制\u0026mdash;\u0026mdash;\u0026ndash;详细地见，条款6，将copying操作声明为private。\n对底层资源祭出“引用计数法”。\n有时候我们希望保存资源，直到它最后一个使用者（某对象）被销毁。\nclass Lock{\rpublic：\rexplict Lock（Mutex* pm）:mutexPtr(pm,unlock)//以某个Mutex初始化share_ptr,并以unlock函数为删除器\r{\rlock（mutePtr.get()）;//条款15\r}\rprivate：\rstd::trl::shared_ptr\u0026lt;Mutex\u0026gt; mutexPtr;//使用share_ptr\r}\rshared_ptr(智能指针)的妙用。\n本例的Lock Class不再声明析构函数，因为没用必要。\nmutex的析构函数会在互斥器的引用次数为0时自动调用trl：share_ptr的删除器（本例为unlock）。\n条款15：在资源管理类中提供对原始资源的访问 结论： APIs往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理之资源”的方法。 对原始资源的访问可能经由显式转换或隐式转换。一般而言，显式转换比较安全，但隐式转换对客户比较方便。 做法 trl::share_ptr和auto_ptr都提供一个get成员函数，用来执行显式转换，也就是它会返回智能指针内部的原始指针（的复件）\n条款16：成对使用new和delete时要采取相同形式 结论 如果你在new表达式中使用[],必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[],一定不要在相应的delete表达式中使用[]\n条款17：以独立语句将newed对象置入智能指针 结论 以独立语句将newed对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。\n原因 假设我们有个函数用来揭示处理程序的优先权，另一个函数用来在某动态分配所得的widget上进行某些带有优先权的处理：\nint priority();\rvoid processWidget(std::trl::shared_ptr\u0026lt;Widget\u0026gt; pw, int priority);\r调用processWidget\nprocessWidget(new Widget, priority());\r不能通过编译，因为trl::share_ptr构造函数需要一个原始指针，但该构造函数是个explicit构造函数，无法进行隐式转换，需要将“new Widget”的原始指针转换为processWidget所要求的Trl：share_ptr。\n但\n这样，就可以通过编译。\nprocessWidget(std::trl::share_ptr\u0026lt;Widget\u0026gt;(new Widget), priority());\r强制转换\n缺陷是：可能泄漏资源\n假设执行顺序：\n执行“new Widget” 调用priority 调用trl::shared_ptr构造函数 对priority的调用可以排在第一、第二、第三执行，不一定，不可知。\n如果在第二位执行，如果对priority的调用导致异常呢？那么“new Widget”返回的指针将会遗失，因第三步执行不了，而第三步则是我们期盼用来防卫资源泄漏的武器，RAII。\n解决方法 使用分离语句\n（1）创建widget\n（2）将它置入一个智能指针，然后再把那个智能指针传给processWidget\nstd::trl::shared_ptr\u0026lt;Widget\u0026gt; pw(new Widget);//在单独语句内以智能指针存储newed所得的对象。\rprocessWidget(pw,priority());//不会造成内存泄漏\r","id":45,"section":"categories","summary":"资源管理 资源：一旦用了它，将来必须还给系统。 譬如：动态分配内存、文件描述器、互斥锁、图形界面中的字型和笔刷、数据库连接、网络sockets。","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记2","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/2/","year":"2021"},{"content":"接口的设计与声明 接口设计的准则： 让接口容易被正确使用，不容易被误用。\n什么是接口？\n​\t内部实现细节封装起来，外部用户用过预留的接口可以使用接口的功能而不需要知晓内部具体细节。\n​\tC++中，通过类实现面向对象的编程，而在基类中只给出纯虚函数的声明，然后在派生类中实现纯虚函数的具体定义的方式实现接口，不同派生类实现接口的方式也不尽相同，从而实现多态。\n条款18：\t让接口容易被正确使用，不容易被误用。 ### 结论\r好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。 “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。 “阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。 trl::shared_ptr支持定制删除器。这可防范DLL问题，可被用来自动解除互斥锁（条款14）。 原因 首先必须考虑客户可能做出什么错误。\nclass Date{\rpublic：\rDate（int month，int day，int year）;\r.....\r}\r如果年月日的顺序错误呢？\n例如\nDate d（30,3,1995）错误\n亦或者按错\nDate d（2,30,1995）\n解决方法 导入简单的外覆类型来区别天数、月份、年份，然后于Date构造函数中使用这些类型：\nstruct Day\r{\rexplicit Day(int d):val(d){}\rint val;\r};\rstruct Month\r{\rexplicit Month(int m):val(m){}\rint val;\r};\rstruct Year\r{\rexplicit Year(int y):val(y){}\rint val;\r};\rclass Date{\rPublic:\rDate（const Month\u0026amp; m,const Day\u0026amp; d,const Year\u0026amp; y）;//包装了一下\r...\r}\rDate d（30,3,1995）;\t//错误！\rDate d（Day（30），Month（3），Year（1995））；//错误\rDate d(Month(3),Day(30),Year(1995))//OK,类型正确\r条款19：设计class犹如type 结论 class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款覆盖的所有讨论主题。\n如何设计高效的class呢？ 新type的对象应该如何被创建和销毁？\n对象的初始化和对象的赋值该有什么样的差别？\n新type的对象如果被passed by value(以值传递)，意味着什么？\n条款20：宁以pass-by-reference-to-const替换pass-by-value 结论 尽量以Pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题。 以上规则并不适用内置类型、STL的迭代器和函数对象。对它们而言，pass-by-value往往比较合适。 条款21：必须返回对象时，别妄想返回其reference 条款22：将成员变量声明为private 从封装角度来看：其实只有两种访问权限：private（提供封装）和其他（不提供封装，即public、protected）\n条款23：宁以non-member、non-friend替换member函数 结论 宁以non-member、non-friend替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性\n原因 一个例子\n想象有一个class用来表示网页浏览器。class可能提供的许多函数中，有一些用来清除下载元素高速缓存区、清除访问过的URLs的历史记录、以及移除系统中的所有cookies：\nclass WebBrowser{\rpublic：\r...\rvoid clearCache(); //清除高速缓存\rvoid clearHistory();//清除历史记录\rvoid removeCookies();//清除cookies\r...\r}\r许多用户想一个函数执行所有动作，因此webBrowser也提供这样一个函数：\n方法一：\rclass WebBrowser\r{\rpublic:\r...\rvoid clearEverything();//调用clearCache（），clearHistory（）和removeCookies（）\r}\r方法一的行为可以由non-member函数调用适用的member函数而提供出来（方法二）：\r方法二：\rvoid clearBrowser（WebBrowser\u0026amp; wb）\r{\rwb.clearCache(); //清除高速缓存\rwb.clearHistory();//清除历史记录\rwb.removeCookies();//清除cookies\r}\r方法一与方法二，哪一个更好一些呢？\n从封装性考虑，为保护数据的封装性（private），应该选择方法二。\n封装的目的：愈多的东西被封装，我们改变那些东西的能力也就越大。愈多函数可访问它，数据的封装性就愈低。\n能够访问private成员变量的函数只有class的member函数+friend函数而已。\n因为成员函数（member）可以访问无限制的访问private的数据，而non-member、non-friend函数并不能增加“能访问class内之private成分”的数据。\n铭记：如果要你在一个member函数（它不只是可以访问class内的private数据，也可以取用private函数、enums、typedefs等等）和一个non-member，non-friend函数（它无法访问上述的任何东西）之间做抉择，而且两者提供相同机能，那么，导致较大封装性的是non-member non-friend函数，因此选择后者。 注意：non-member函数也可以是另一个class的member\n条款24：若所有参数皆需类型转换，请为此采用non-member函数 结论 如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member\n","id":46,"section":"categories","summary":"接口的设计与声明 接口设计的准则： 让接口容易被正确使用，不容易被误用。 什么是接口？ ​ 内部实现细节封装起来，外部用户用过预留的接口可以使用接口的","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记3","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/3/","year":"2021"},{"content":"条款05： C++默认编写并调用那些函数 默认创建\nclass Base\r{\rpublic：\rdefualt构造函数\rcopy构造函数\rcopy assignment操作符\r析构函数\r}\r条款06：若不想使用编译器自动生成的函数，就该明确拒绝（即不可被调用） 作法：\n​\t将默认创建的函数声明为私有的（——private——），为防止member函数和friend函数的内部调用，将成员函数声明为private而且故意不实现它们\nclass HomeForSale\r{\rpublic:\rprivate:\rHomeForSale(const HomeForSale\u0026amp;);\t//只有声明，不实现它们\rHomeForSale\u0026amp; operator=(const HomeForSale\u0026amp;);\r}\r更为常用的作法： 设计一个基类（base class） ，在这个基类内实现阻止copying等默认函数动作，然后继承它。\n条款07：为多态基类声明virtual析构函数 用法: 1.如果class不含virtual函数，通常表示它并不意图被用做一个base class。\n​\t即：class的设计目的如果不是作为base class使用，或者不是为了具备多态性，就不应该virtual析构函数。\n2.当class不企图被当做base class，令其析构函数为virtual往往是个馊主意\n3.多态性质的base classes应该声明一个virtual析构函数，如果class带有任何virtual函数，他就应该拥有一个virtual析构函数\n目的： 1.C++中基类采用virtual虚析构函数是为了防止内存泄漏。\n2.假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数\n可参考blog https://blog.csdn.net/sinat_20265495/article/details/51775724?ops_request_misc=\u0026amp;request_id=\u0026amp;biz_id=102\u0026amp;utm_term=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%20virtual\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-.pc_search_result_before_js\u0026amp;spm=1018.2226.3001.4187 https://blog.csdn.net/yhc166188/article/details/81587442?ops_request_misc=%7B%22request%5Fid%22%3A%22162622287916780261951132%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D 条款08：被让异常逃离析构函数 ###　结论\n１．析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。\n２．如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。\n原因 为什么析构函数不应吐出异常？\nvector的使用\nclass widget{\rpublic:\r~widget(){}\t//假设吐出一个异常\r}\rvoid dosomething()\r{\rstd::vector\u0026lt;Widget\u0026gt; v;\r}\t//v在这里被自动销毁\r假设v内含十个Widgets,而在析构第一个元素期间，有一个异常被抛出，其他九个widgets还是应该被销毁。\n这会导致多个异常同时存在，程序会结束执行或导致不明确行为。（结论1）\n若析构函数需要吐出异常，怎么办?\n一个例子： 数据库的连接，创建一个用来管理DBConnection资源的class，并在其析构函数中调用close（）。但close（）函数可能关闭失败，从而输出异常。\nclass DBConn\r{\rpublic:\r~DBConn()//确保数据库连接总是会被关闭\r{\rdb.close();//可能会关闭失败，输出异常\r}\rprivate:\rDBConnection db;\r}\r如果close（）失败，那么异常会离开~DBConn（）析构函数，成为麻烦。应该阻止异常从析构函数中传播出去。\n解决办法： 1.如果close抛出异常就结束程序。通常通过调用abort完成：\n即：\nDBConn::~DBConn()\r{\rtry{db.close();}\rcatch(...){\r制作运转记录，记录对close（）的调用失败（即日志库）;\rstd::abort();\r}\r}\r2.吞下因调用close而发生的异常（即对发生的异常，catch中不做处理）：\nDBConn::~DBConn()\r{\rtry{db.close();}\rcatch(...){\r制作运转记录，记录对close（）的调用失败（即日志库）;\r}\r}\r具体做法 重新设计DBConn接口,给客户一个关闭close函数的机会\nclass DBConn{\rpublic：\r...\rvoid close（）//供客户使用的新函数\r{\rdb.close();\rclosed=true;\r}\r~DBConn()\r{\rif(!closed)\r{\rtry{\rdb.close();\t//关闭连接（如果客户不主动关闭）\r}\rcatch(...){\t//如果关闭动作失败\r制作运转记录，记录对close的调用失败；//记录下来并结束程序 或 吞下异常\r} }\r}\rprivate：\rDBConnectin db;\rbool closed; }\r条款09：绝不在构造和析构函数过程中调用virtual函数 ###　结论\n在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class\n原因 一个例子：\n模拟股市交易如买进、卖出的订单等，每当创建一个交易对象，在审计日志中也需要创建一笔适当的记录。\n基类\rclass Transaction{\t//所有交易的base class\rpublic:\rTransaction();\rvirtual void logTransaction() const = 0;//做出一份因类型不同而不同的日志记录\r};\rTransaction::Transaction()\r{\r.....\rlogTransaction();\t//问题点\r}\r子类\rclass BuyTansaction:public Transaction{\rpublic:\rvirtual void logTransaction() const; //log此记录\r....\r} class SellTansaction:public Transaction{\rpublic:\rvirtual void logTransaction() const; //log此记录\r....\r} BuyTrasaction b;\r当BuyTrasaction b后，首先Transaction构造函数一定会被先调用，然后BuyTransaction构造函数被调用。\nTransaction::Transaction()中的logTransaction()函数执行的base class中的logTransaction。\n解决方法 在class Transaction内将logTransaction函数改为non-virtual，然后要求derived class构造函数传递必要信息给Transaction构造函数，而后那个构造函数便可安全地调用non-virtual logTransaction。\n即，通过构造函数的参数传递\n虚函数是从base class向下调用。 dervice class将必要的构造信息向上传递至base class构造函数。 注意形参\rclass Transaction\r{\rpublic：\rexplicit Transaction(const std::string\u0026amp; logInfo);\rvoid logTransaction(const std::string\u0026amp; logInfo) const;//如今是一个non-virtual函数\r....\r};\rTransaction::Transacton(const std::string\u0026amp; logInfo)\r{\r...\rlogTransaction(logInfo)\r}\rclass BuyTransaction:public Transaction{\rpublic:\rBuyTransaction( parameters ): Transaction（createLogString（parameter））//将log信息传给base class构造函数\r{\r...\r}\r...\rprivate:\rstatic std::string createLogString( parameter );//注意这个函数返回string类型， 函数是static类型的，可以作为构造函数的参数使用\r}\r函数使用static类型，使之不可能意外指向“初期未成熟之BuyTransaction对象内部尚未初始化的成员变量”。\n","id":47,"section":"categories","summary":"条款05： C++默认编写并调用那些函数 默认创建 class Base { public： defualt构造函数 copy构造函数 copy assignment操作符 析构函数","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记1","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/1/","year":"2021"}],"tags":[{"title":"blog","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/blog/"},{"title":"book","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/book/"},{"title":"c ","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/c/"},{"title":"cmake","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/cmake/"},{"title":"command","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/command/"},{"title":"cpp","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/cpp/"},{"title":" docker","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/docker/"},{"title":" git","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/git/"},{"title":"linux","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/linux/"},{"title":" math","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/math/"},{"title":" matlab","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/matlab/"},{"title":"net","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/net/"},{"title":" project","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/project/"},{"title":" python","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/python/"},{"title":"raspberry","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/raspberry/"},{"title":"robat","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/robat/"},{"title":" robot","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/robot/"},{"title":" ros","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/ros/"},{"title":"ros2 ","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/ros2/"},{"title":"slam","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/slam/"},{"title":" tool","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/tool/"},{"title":" ubuntu","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/ubuntu/"},{"title":" vim","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/vim/"},{"title":" vscode","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/vscode/"},{"title":"win ","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/win/"},{"title":" wsl","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/wsl/"},{"title":"概率论","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"title":" 网络","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/%E7%BD%91%E7%BB%9C/"}]}