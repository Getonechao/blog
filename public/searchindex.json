{"categories":[{"title":"lang","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/"},{"title":"math","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/"},{"title":"net","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/net/"},{"title":"os","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/"},{"title":"other","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/other/"},{"title":"robat","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robat/"}],"posts":[{"content":"command 1. 常用命令 1.1 新建文档 math类\rhugo new categories/math/\rnet类\rhugo new categories/net/\ros类\rhugo new categories/os/\rrobat类\rhugo new categories/robat/\rother类\rhugo new categories/other/\rlang类\rhugo new categories/lang/\r 1.2 上传命令 hugo -D\rgit add .\rgit commit -m \u0026quot;\u0026quot;\rgit push gitee\rcloudbase hosting deploy ./public -e blog-0g8860131649bb29\r 1.3 markdown技巧  打开调试，获取bilibili的aid  console.log(playerInfo.aid)\rnote：去除'\\'\r{\\{\u0026lt; bilibili aid \u0026gt;}\\}\r  跳转  []({\\{\u0026lt; ref \u0026quot;blog/neat.md\u0026quot; \u0026gt;}\\})\r 2. 腾讯云部署 静态网站托管 部署 Hugo - 最佳实践 - 文档中心 - 腾讯云 (tencent.com)\n","id":0,"section":"categories","summary":"command 1. 常用命令 1.1 新建文档 math类 hugo new categories/math/ net类 hugo new categories/net/ os类 hugo new categories/os/ robat类 hugo new categories/robat/ other类 hugo new categories/other/ lang类 hugo new categories/lang/ 1.2 上传命令 hugo -D git add . git commit","tags":["blog"],"title":"Command","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/other/blog/command/","year":"2022"},{"content":"希腊字母 ","id":1,"section":"categories","summary":"希腊字母","tags":[" math"],"title":"希腊字母","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/other/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D/","year":"2022"},{"content":"win10安装clash 下载 clash for win软件是一个开源项目，被开源在github上，它是具有windows,mac,linux(x86和arm)多版本的gui软件。\n点击跳转：开源地址 由于github的网站位于国外，可能打不开，下载地址如下：\n点击下载：clash下载地址\n安装 解压软件包 软件包是安装的，可以直接运行 汉化 由于软件是国外开发的，所以gui界面文字是英语，我们需要将它汉化。 汉化教程在github上开源的\n点击跳转：开源地址 点击下载：汉化包下载地址 解压汉化包，得到一个app.asar文件，用汉化包中的app.asar替换resources/app.asar 启动clash\n节点导入 导入yaml配置文件 v2ray转换到clash,将vmess协议转换为yaml配置文件在线小工具 点击跳转\n由于是纯前端的转换工具，所以加载可能有点慢，耐心等待一下 转换完成后，下载yaml文件，然后见上图，导入yaml文件 开启系统代理 检测网络是否通 大功告成！！！\n","id":2,"section":"categories","summary":"win10安装clash 下载 clash for win软件是一个开源项目，被开源在github上，它是具有windows,mac,linux(x86和arm","tags":["win10"],"title":"安装clash","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/net/win/%E5%AE%89%E8%A3%85clash/","year":"2022"},{"content":"概率论与数理统计 古典概型  试验中所有可能出现的基本事件只有有限个 试验中每个基本事件出现的可能性相等。  具有以上两个特点的概率模型是大量存在的，这种概率模型称为古典概率模型，简称古典概型，也叫等可能概型\n 几何概型：  无限性：试验中所有可能出现的基本事件（结果）有无限多个. 等可能性：每个基本事件出现的可能性相等.   如果每个事件发生的概率只与构成该事件区域的长度(面积或体积或度数)成比例，则称这样的概率模型为几何概率模型，简称为几何概型。古典概型与几何概型的主要区别在于：几何概型是另一类等可能概型，它与古典概型的区别在于试验的结果是无限个。\n 全概率公式  意义：全概率公式为概率论中的重要公式，它将对一复杂事件A的概率求解问题转化为了在不同情况下发生的简单事件的概率的求和问题。\n内容：如果事件B1、B2、B3…Bi构成一个完备事件组，即它们两两互不相容，其和为全集；并且P（Bi)大于0，则对任一事件A有\nP(A)=P(A|B1)P(B1) + P(A|B2)P(B2) + ... + P(A|Bi)P(Bi)\r\u0026emsp;\u0026emsp;概率论的一个重要内容是研究怎样从一些较简单事件概率的计算来推算较复杂事件的概率，全概率公式和Bayes公式正好起到了这样的作用。\r 贝叶斯公式 $$ P(A|B)=\\frac{P(B|A)P(A)}{P(B)} $$ 贝叶斯公式用来描述两个条件概率之间的关系。即通常，事件A在事件B(发生)的条件下的概率，与事件B在事件A的条件下的概率是不一样的；然而，这两者是有确定的关系,贝叶斯法则就是这种关系的陈述。\n在贝叶斯法则中，每个名词都有约定俗成的名称：\n P(A)是A的先验概率或边缘概率。之所以称为\u0026quot;先验\u0026quot;是因为它不考虑任何B方面的因素。 P(A|B)是已知B发生后A的条件概率，也由于得自B的取值而被称作A的后验概率。 P(B|A)是已知A发生后B的条件概率，也由于得自A的取值而被称作B的后验概率。 P(B)是B的先验概率或边缘概率，也作标准化常量（normalized constant）。  按这些术语，Bayes法则可表述为：\n后验概率 = (似然度 * 先验概率)/标准化常量\n也就是说，后验概率与先验概率和似然度的乘积成正比。\n另外，比例Pr(B|A)/Pr(B)也有时被称作标准似然度（standardised likelihood），Bayes法则可表述为： 后验概率 = 标准似然度 * 先验概率。 [1]\n1.可测空间\n2.常用的一维分布\n链接\n","id":3,"section":"categories","summary":"概率论与数理统计 古典概型 试验中所有可能出现的基本事件只有有限个 试验中每个基本事件出现的可能性相等。 具有以上两个特点的概率模型是大量存在的，这","tags":["概率论"],"title":"概率论学习之旅1","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/probability/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%851/","year":"2022"},{"content":"如何安装ros 脚本安装 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; sudo bash fishros\r 原文章链接：鱼香ros\nrosdep 安装  note: 注意安装ros过程中，可以不安装rosdep，它不是ros系统必须安装的，它的功能类似于ubuntu中的apt\n，当我们安装ros的一些功能包的时候，也可以用apt安装，可以不用rosdep\n 参考视频：小鱼在古月居开课视频\u0026ndash;聊聊ROS安装过程中的那些坑\n","id":4,"section":"categories","summary":"如何安装ros 脚本安装 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; sudo bash fishros 原文章链接：鱼香ros rosdep 安装 note: 注意安装ros过程中，可以不安装rosdep，它不是ros系统必须安装的","tags":["ros"],"title":"Ros学习之旅3","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/ros/ros%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%853/","year":"2022"},{"content":"网络配置 ubuntu18.04配置IP 使用ip addr 只限于以太网配置(临时)\rip addr add 192.168.8.30 dev eth0\r /etc/netplan/*配置文件 服务器中是50-cloud-init.yaml,桌面版01-network-manager-all.yaml\n信息格式如下：\nnetwork:\rethernets:\reth0:\rdhcp4: no\raddresses: [192.168.30.201/24]\roptional: true\reth1:\rdhcp4: no\raddresses: [192.168.30.202/24]\roptional: true\rversion: 2\rwifis:\rwlan0:\raccess-points:\rchao:\rpassword: '88888888'\rdhcp4: true\roptional: true\r ","id":5,"section":"categories","summary":"网络配置 ubuntu18.04配置IP 使用ip addr 只限于以太网配置(临时) ip addr add 192.168.8.30 dev eth0 /etc/netplan/*配置文件 服务器中是50-cl","tags":["linux","net"],"title":"网络配置","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/liunx/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","year":"2022"},{"content":"激光有反 激光有反..............\n引用\n","id":6,"section":"categories","summary":"激光有反 激光有反.............. 引用","tags":["导航"],"title":"激光有反","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robat/%E6%BF%80%E5%85%89%E6%9C%89%E5%8F%8D/","year":"2022"},{"content":"","id":7,"section":"categories","summary":"","tags":["project"],"title":"纯追踪","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robat/carcontrol/%E5%AF%BB%E8%BF%B9/%E7%BA%AF%E8%BF%BD%E8%B8%AA/","year":"2022"},{"content":"概率机器人 1. 基础课程 1.1 概率论基础  概率论与数理统计基本概念  1.2 随机过程  随机过程可依其在任一时刻的状态是连续型随机变量或离散型随机变量而分成连续型随机过程和离散型随机过程.\n定义：就是一个随\u0026quot;时间\u0026quot;演化的随机系统\n学习参考课程和教材  随机过程-华中科技大学  2. 贝叶斯滤波  贝叶斯滤波是卡尔曼滤波、粒子滤波的基础，应用到汽车、金融、航空航天、机器学习等行业。\n  后验概率 = 标准似然度 *先验概率\n 学习资料\n 理解贝叶斯滤波  2.1 概率生成法则   初始置信度$p(x_{0})$\n  状态转移概率：$p(x_{t} |z_{t-1},u_{t})$\n  测量概率：$p(z_{t} |x_{t})$\n  状态转移概率和测量概率一起描述机器人及其环境组成的动态系统\n  2.2 置信度  置信度：反映机器人有关环境状态的内部信息。。 置信度用$bel(x_{t} )$表达，其为时刻t下状态$x_{t}$的概率分布的后验的缩写：$bel(x_{t} )=p(x_{t} |z_{1:t},u_{1:t})$表达，x表示状态。 预测：$\\overline{bel(x_{t})}=p(x_{t} |z_{1: t-1},u_{1:t})$ 修正：由$\\overline{bel(x_{t})}$计算$bel(x_{t})$的过程。  2.3 贝叶斯滤波的过程  预测 修正  3.高斯滤波   高斯滤波是递归状态估计器家族的统称。\n  高斯滤波中的参数均值（一阶矩）和方差（二阶矩）称为矩参数。\n  3.1 卡尔曼滤波KF  KF是由swerling和Kalman作为线性高斯系统中的预测和滤波技术而发明的，是用矩来定义的,它不适用于离散或混合状态空间。 KF用矩参数表达置信度：在时刻t，置信度用均值$\\mu_{t} $ 和方差$\\Sigma_{t}$表达。  条件：除了贝叶斯滤波的马尔可夫假设，它还具有以下的三个特性，则后验就是高斯的\n  状态转移概率必须是带有随机高斯噪声的参数的线性函数，如下式：\n$$ x_{t}=A_{t}x_{t-1}+B_{t}u{t}+\\varepsilon_{t}$$\n  测量概率也与带有高斯噪声的自变量呈线性关系\n$$z_{t}=C_{t}x_{t}+\\delta_{t}$$\n  初始置信度$bel(x_{0})$必须是正态分布的。\n$$bel(x_{0})=p(x_{0})\u0026mdash;-x_{0}\\sim N(\\mu ,\\Sigma _{0})$$\n  卡尔曼滤波过程如下：\n4.非参数滤波 4.2 直方图滤波 4.2 静态二值贝叶斯滤波 4.3 粒子滤波(pf)   粒子滤波(particle filter)是贝叶斯滤波的另一种非参数实现。\n  粒子滤波以有限个参数来近似后验\n  主要思想：用一系列从后验得到的随机状态采样表示$bel(x_{t})$\n  一个粒子就是根据真实世界状态在时刻t的一个可能假设。\n  粒子滤波的直观感觉就是用粒子群$X_{t}$来近似置信度$bel(x_{t})$\n 理想情况下，状态假设$x_{t}$包含在粒子集$X_{t}$中的可能性与其贝叶斯滤波的后验$bel(x_{t})$成比例：\n$$x_{t}^{m}\\sim p(x_{t}|z_{1:t},u_{1:t}) $$\n状态空间的一个子区域被样本填充得越密集，真实状态落入该区域的可能性越大\n    粒子滤波算法由上一个时间步长的置信度$bel(x_{t-1})$递归地构建置信度$bel(x_{t})$,因为置信度由粒子集表示，这就意味粒子滤波可由粒子集$X_{t-1}$递归地构建粒子集$X_{t}$\n","id":8,"section":"categories","summary":"概率机器人 1. 基础课程 1.1 概率论基础 概率论与数理统计基本概念 1.2 随机过程 随机过程可依其在任一时刻的状态是连续型随机变量或离散型随机变量而分成连续型","tags":["slam","导航","book"],"title":"《概率机器人》-读书笔记","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/robat/slam/%E6%A6%82%E7%8E%87%E6%9C%BA%E5%99%A8%E4%BA%BA/","year":"2022"},{"content":"ROS学习之旅2 机器人种类 AGV的框架(搬运机器人) 穿梭车 ","id":9,"section":"categories","summary":"ROS学习之旅2 机器人种类 AGV的框架(搬运机器人) 穿梭车","tags":["ros"],"title":"Ros学习之旅2","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/ros/ros%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%852/","year":"2022"},{"content":"ros学习之旅1 ros学习网站收集  Ros官网 wiki.ros.org 中国大学MOOC\u0026mdash;《机器人操作系统入门》课程讲义 中国大学MOOC\u0026mdash;《智能机器人系统》 创客智造 zhangrelay的专栏 古月居 易科机器人实验室 ROBOTIS 知乎\u0026ndash;SLAM开发最强最全资源汇总 ing\u0026hellip;.  代码示例  中国大学MOOC\u0026mdash;《机器人操作系统入门》课程讲义\u0026ndash;代码示例 hector slam gmapping  书籍  机器人导论  ","id":10,"section":"categories","summary":"ros学习之旅1 ros学习网站收集 Ros官网 wiki.ros.org 中国大学MOOC\u0026mdash;《机器人操作系统入门》课程讲义 中国大学MOOC\u0026mdash;《智","tags":["ros"],"title":"Ros学习之旅1","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/os/ros/ros%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%851/","year":"2022"},{"content":"如何在wsl1中使用网络代理？ 代理工具   polipo   proxychain\n  前提条件 v2ray中开启允许局域网连接\n记住以下ip:port\n开始代理 polipo 参考博客：为 windows wsl 配置 socks5 代理 (github.com)\n步骤总结：\n下载\rsudo apt install polipo\r打开配置文件\rsudo nano /etc/polipo/config\r写入\rsocksParentProxy = \u0026quot;localhost:10808\u0026quot;\rsocksProxyType = socks5\rproxyPort = 8123\r环境设置\rnano ~/.bashrc\r写入\rexport https_proxy=http://127.0.0.1:8123\rexport http_proxy=http://127.0.0.1:8123 export all_proxy=socks5://127.0.0.1:8123\r启动\rsudo service polipo stop sudo service polipo start 测试\rcurl www.google.com\r proxychain 参考博客：linux下的全局代理工具proxychain | MonkeyWie\u0026rsquo;s Blog\n","id":11,"section":"categories","summary":"如何在wsl1中使用网络代理？ 代理工具 polipo proxychain 前提条件 v2ray中开启允许局域网连接 记住以下ip:port 开始代理 polipo 参考博客：为 windows wsl 配置 socks5 代理 (github.com)","tags":[" wsl1","Linux"],"title":"如何在wsl1中使用网络代理？","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/net/wsl1/test-post/","year":"2022"},{"content":"矩阵论之二 ","id":12,"section":"categories","summary":"矩阵论之二","tags":["矩阵","线性代数"],"title":"矩阵论之二","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/matrix/%E7%9F%A9%E9%98%B5%E8%AE%BA%E4%B9%8B%E4%BA%8C/","year":"2022"},{"content":"矩阵论之一 线性空间  线性空间也称\u0026quot;向量空间\u0026quot;。\\( \\sqrt{x} \\)\n$$ \\sqrt{x} $$\n","id":13,"section":"categories","summary":"矩阵论之一 线性空间 线性空间也称\u0026quot;向量空间\u0026quot;。\\( \\sqrt{x} \\) $$ \\sqrt{x} $$","tags":["矩阵","线性代数"],"title":"矩阵论之一","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/math/matrix/%E7%9F%A9%E9%98%B5%E8%AE%BA%E4%B9%8B%E4%B8%80/","year":"2022"},{"content":"继承与面向对象设计 条款32：确定你的public继承塑模出“is-a”（是一种）关系 结论 “public继承关系”意味is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，每一个derived classes对象也是一个base class对象\n存在于classes之间的三种关系：  is-a （是一个）A是B has-a（有一个，条款38）A有B is-implemented-in-term-of(根据某物实现出，条款39)  条款33：避免遮掩继承而来的名称 结论  derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。 为了让被遮掩的名称再见天日，可以使用using声明式或转交函数。  条款34：区分接口继承和实现继承 结论   接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口。\n  pure vitrual（纯虚函数）只具体指定接口继承。\n  impure vitrual(非纯函数)具体指定指定接口继承和缺省实现继承（可以覆写）。\n  non-virtual（成员函数）具体指定接口继承以及强制性实现继承。\n  条款35：考虑virtual函数以外的其他选择 结论  virtual函数的替代方案包括NVI手法及Strategy（策略）设计模式的多种形式。NVI手法自身是一种特殊形式的Template Method设计模式。 将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。 trl::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物  条款36：绝不重新定义继承而来的non-virtual函数 原因 违反\u0026quot;is-a\u0026quot;的继承体系\n条款37： 绝不重新定义继承而来的缺省参数值 结论 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数\u0026mdash;你唯一应该覆写的东西\u0026mdash;-却是动态绑定。\n原因 你只能继承两种函数：virtual 和 non-virtual函数。然而重新定义一个继承而来的non-virtual函数永远是错误（条款36）\nvirtual函数系动态绑定，而缺省参数值却是静态绑定。\n条款38：通过复合塑模出“has-a”或“根据某物实现出” 结论  复合关系的意义和public继承关系完全不同 在应用域，在复合意味has-a（有一个）。在实现域，复合意味is-implemented-in-terms-of(根据某物实现出)。  内容 继承关系 复合关系\n在程序员之间，复合这个词有很多同义词，譬如分层、内含、聚合、内嵌。\n应用域 相当于塑造的世界中的某些事物，例如人、汽车\n实现域 实现细节上的人工制品，例如缓冲区、互斥器、查找树\n条款39：明智而审慎地使用private继承 结论  private继承关系意味着is-implemented-in-terms-of(根据某物实现出)。它通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。 和复合不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。  原因 C++将public继承视为is-a关系\n​\t将private继承视为is-implemented-in-terms-of(根据某物实现出)\n注意：private继承纯粹只是一种实现技术（private base class的每样东西在你的class内都是private） 如非必要（必要条件，见P188），在复合与private继承中，尽量选择复合。\n条款40：明智而审慎地使用多重继承 结论  多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。 virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes不会带任何数据，将是最具实用价值的情况。 多重继承的确有正当用途。其中一个情景涉及“public继承某个interface class”和“private继承某个协助实现的class”两相组合。  ","id":14,"section":"categories","summary":"继承与面向对象设计 条款32：确定你的public继承塑模出“is-a”（是一种）关系 结论 “public继承关系”意味is-a。适用于base","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记5","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/5/","year":"2021"},{"content":"实现 大多情况下，适当提出你的class（和class templates）定义以及functions(和 function templates)声明，是花费最多心力的两件事。\n实现大多直截了当，但实现仍然有一些东西要小心。\n条款26：尽可能延后变量定义式的出现时间 结论 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序的效率。\n原因 只要你定义了一个变量而其类型带有一个构造函数或析构函数，\n那么当程序的控制流到达这个变量定义式时，你便得承受构造成本；\n当这个变量离开其作用域时，你便要承受析构成本。\n即使这个变量最终并未被使用，仍需消耗这些成本。\nstd::string encrytPassword(const std::string\u0026amp;　password)\r{\rusing namespace std;\rstring encrypted;\rif(password.length()\u0026lt;MinimumPasswordLength){\rthrow logic_error(\u0026quot;Password is too short\u0026quot;);\r}\r...\t//必要动作，将一个加密后的密码置入变量encrypted内\rreturn encrypted;\r}\r 如果密码长度不够，丢出异常，那么string encrypted被构造了，也被析构了，但没有被使用。\nP116重要，关于循环体内的定义 条款27：尽量少做转型动作 结论  如果可以，尽量避免转型，特别是注重效率的代码中避免dynamic_casts。如果有个设计需要转型设计，试着发展无需转型的替代设计 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要转型放进它们自己的代码内。 宁可使用C++style（新式）转型，不要使用旧式转型。  条款28：避免返回handles指向对象内部成分（即它的成员变量） 结论 避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条约可增加封装性，帮助cosnt成员函数的行为更像const，并将发生内存对象被销毁的可能性降到最低。\n原因 假设你的程序涉及矩形，每一个矩形由其左上角和右下角表示。\nclass Point{\t//这个class用来表述“点”\rpublic：\rpoint（int x,int y）;\r...\rvoid setX（int newVal）;\rvoid setY(int newval);\r...\r}\rstruct RectData{\t//这些点数据用来表现一个矩形\rPoint ulhc;\t//ulhc=\u0026quot;右下角\u0026quot;\rPoint lrhc;//lrhc=\u0026quot;右上角\u0026quot;\r};\rclass Rectangle{\r....\rprivate:\rstd::trl::shared_ptr\u0026lt;RectData\u0026gt; pData;\r};\r by reference 方式传递用户自定义类型往往比by value方式更高效\nclass Rectangle{\rpublic：\r....\rPoint\u0026amp; upperLeft() const { return pData-\u0026gt;ulhc;}\rPoint\u0026amp; upperRight() const { return pData-\u0026gt;lrhc;}\r}\r const成员函数：若将成员成员函数声明为const，则该函数不允许修改类的数据成员，但若数据成员是指针，则还是可以修改指针指向的内容\nupperLeft和upperRight被声明为const成员函数，是为了提供客户一个得知Rectangle相关坐标点的方法，而不是让客户修改Rectangle（客户是可以通过by reference修改内部数据）。\n解决方法 它们的返回类型加上const\nclass Rectangle\r{\rpublic：\r...\rconst Point\u0026amp; upperLeft() const{ return pData-\u0026gt;ulhc;}\rconst Point\u0026amp; lowerRight() const {return pData-\u0026gt;lrhc;}\r...\r}\r 条款29：为“异常安全”而努力是值得的 结论  异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型 “强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。  \u0026ldquo;COPY-AND-SWAP\u0026quot;技术 按照C++ primer的理解，赋值运算符（A=B）应该实现两个方面的工作：\n1.析构函数（删除A原有的内容）\n2.拷贝构造函数（将B的值赋值给A）\n ClassA\u0026amp; ClassA::operator= (\u0026hellip;.): 首先把\u0026rdquo;=\u0026ldquo;右边的值复制到\u0026rdquo;=\u0026ldquo;左边, 然后析构\u0026rdquo;=\u0026ldquo;左边的值;\n为了保证可以自赋值(self-assignment), 需要使用****临时变量****存储, 再删除对象;\nclass A {\rprivate:\rint *b;\rint a;\rpublic:\rA():a(0),b(nullptr){};\rA(const A\u0026amp;rhs):a(rhs.a),b(rhs.b==nullptr?nullptr:new int(*rhs.b)){};\r~A(){\rdelete b;\rb = nullptr;\r};\r};\rA\u0026amp; operator=(const A\u0026amp; rhs) {\rif(this!=\u0026amp;rhs) { // 防止自赋值\rdelete b;\rthis-\u0026gt;b = new int(*rhs.b);// 可能失败\rthis-\u0026gt;a = rhs.a;\r}\rreturn *this; // 返回this对象的引用\r}\r 可以看到我们的代码几乎是对拷贝构造函数和析构函数的完全复制，此外，上述代码虽然完成了自赋值的验证，但并未保障异常安全。一旦new失败，原this对象的b已经被删除，因此会引发异常。\n异常不安全主要在于，b对应的对象可能在异常到来之前被删除。因此我们首先保存该对象的副本，从而保证了异常安全特性，无论new是否成功，this对象中的b指针都会指向已知对象 A\u0026amp; operator=(const A\u0026amp; rhs) {\rauto orign = this-\u0026gt;b;\t//使b指针所指向的内存有orgin指针指向\rthis-\u0026gt;b = new int(*rhs.b);\rdelete orign;\rthis-\u0026gt;a = rhs.a;\rreturn *this;\r}\r copy and swap 为了使用copy-swap，我们需要三件事：\n 一个有效的拷贝构造函数 一个有效的析构函数 一个自定义的交换函数，不能用std::swap,因为该函数实现中调用了拷贝构造和复制函数，且交换函数不抛异常  该技术的核心就是不再使用引用作为赋值运算符参数，形参将直接是对象，这样的写法将会使编译器自动调用拷贝构造函数，由于拷贝构造函数的调用，异常安全将在进入函数体之前被避免（若拷贝失败则什么都不会发生）。经过swap后的对象在离开函数体后会自动销毁，因此也就自动调用了析构函数，具体写法如下： ———————————————— 版权声明：本文为CSDN博主「feifeiiong」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/feifeiiong/article/details/77866579\nvoid swap(A\u0026amp; rhs) {\rusing std::swap;\rswap(this-\u0026gt;a,rhs.a);\rswap(this-\u0026gt;b,rhs.b);\r}\rA\u0026amp; operator=(A rhs) {\rswap(rhs);\rreturn *this;\r}\r 网络资源：\n https://blog.csdn.net/hiwubihe/article/details/116667884?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162631218716780264010481%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D\u0026amp;request_id=162631218716780264010481\u0026amp;biz_id=0\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-10-116667884.first_rank_v2_pc_rank_v29\u0026amp;utm_term=copy+and+swap\u0026amp;spm=1018.2226.3001.4187  条款30：透彻了解inlining的里里外外 结论  将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更为容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。 不要只因为function templates出现在头文件，就将它们声明为inline。  原因 一开始先不要将任何函数声明为inline，或者至少将inline施行范围局限在那些“一定成为inline（条款46）”或“十分平淡无奇”的函数身上，可以使程序达到优化。\n（28法则）平均而言一个程序往往将80%的执行时间花费在20%的代码上头，作为软件开发者，我们的目标是找出这可以有效增进程序整体效率的20%的代码\ninline缺点：\n以代码膨胀为代价 空间换时间\ninline对于编译器而言，只是建议。\n建议：\n 开栈的开销 \u0026gt; 执行的开销 建议设为inline 开栈的开销 \u0026lt; 执行的开销 不建议  为什么使用inline关键字？ 1.1为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）。 在预编译的时候，编译器将程序中出现的内联函数的调用表达式的地方直接插入用内联函数的代码。\n条款31：将文件间的编译依存关系降到最低 结论  支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和interface classes 程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及templates都适合。  方法 pimpl idiom技术\nhttps://blog.csdn.net/qq_33775402/article/details/76274678?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162632039416780261938712%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D\u0026amp;request_id=162632039416780261938712\u0026amp;biz_id=0\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-4-76274678.first_rank_v2_pc_rank_v29\u0026amp;utm_term=%E9%99%8D%E4%BD%8E%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB\u0026amp;spm=1018.2226.3001.4187\n","id":15,"section":"categories","summary":"实现 大多情况下，适当提出你的class（和class templates）定义以及functions(和 function templates)声明，是花费最多","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记4","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/4/","year":"2021"},{"content":"资源管理 资源：一旦用了它，将来必须还给系统。\n譬如：动态分配内存、文件描述器、互斥锁、图形界面中的字型和笔刷、数据库连接、网络sockets。\n条款13：以对象管理资源 创建一个对象管理资源，资源管理类\n结论 ​\t1.为防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。\n​\t2.两个常被使用的RAII classes分别trl::share_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为直观。\n条款14：在资源管理中，小心copying行为 copying行为也应该参考\n浅拷贝\u0026amp;\u0026amp;深拷贝\n结论 1.复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。\n2.普遍而常见的RAII class copying行为是：禁止copying、施行引用计数法。\n原因 资源管理类对象被复制，是一件不合理的行为，因为例如“互斥锁”、“动态内存分配”、等是具有唯一性的，两个对象的指针同时指向同一块内存，那么对象销毁时，内存释放，就必然一个指针称为悬空指针。\n解决方法 因此：有两种做法：\n  禁止复制\u0026mdash;\u0026mdash;\u0026ndash;详细地见，条款6，将copying操作声明为private。\n  对底层资源祭出“引用计数法”。\n有时候我们希望保存资源，直到它最后一个使用者（某对象）被销毁。\n  class Lock{\rpublic：\rexplict Lock（Mutex* pm）:mutexPtr(pm,unlock)//以某个Mutex初始化share_ptr,并以unlock函数为删除器\r{\rlock（mutePtr.get()）;//条款15\r}\rprivate：\rstd::trl::shared_ptr\u0026lt;Mutex\u0026gt; mutexPtr;//使用share_ptr\r}\r shared_ptr(智能指针)的妙用。\n本例的Lock Class不再声明析构函数，因为没用必要。\nmutex的析构函数会在互斥器的引用次数为0时自动调用trl：share_ptr的删除器（本例为unlock）。\n条款15：在资源管理类中提供对原始资源的访问 结论：  APIs往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理之资源”的方法。 对原始资源的访问可能经由显式转换或隐式转换。一般而言，显式转换比较安全，但隐式转换对客户比较方便。  做法 trl::share_ptr和auto_ptr都提供一个get成员函数，用来执行显式转换，也就是它会返回智能指针内部的原始指针（的复件）\n条款16：成对使用new和delete时要采取相同形式 结论 如果你在new表达式中使用[],必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[],一定不要在相应的delete表达式中使用[]\n条款17：以独立语句将newed对象置入智能指针 结论 以独立语句将newed对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。\n原因 假设我们有个函数用来揭示处理程序的优先权，另一个函数用来在某动态分配所得的widget上进行某些带有优先权的处理：\nint priority();\rvoid processWidget(std::trl::shared_ptr\u0026lt;Widget\u0026gt; pw, int priority);\r 调用processWidget\nprocessWidget(new Widget, priority());\r 不能通过编译，因为trl::share_ptr构造函数需要一个原始指针，但该构造函数是个explicit构造函数，无法进行隐式转换，需要将“new Widget”的原始指针转换为processWidget所要求的Trl：share_ptr。\n但\n这样，就可以通过编译。\nprocessWidget(std::trl::share_ptr\u0026lt;Widget\u0026gt;(new Widget), priority());\r 强制转换\n缺陷是：可能泄漏资源\n假设执行顺序：\n 执行“new Widget” 调用priority 调用trl::shared_ptr构造函数  对priority的调用可以排在第一、第二、第三执行，不一定，不可知。\n如果在第二位执行，如果对priority的调用导致异常呢？那么“new Widget”返回的指针将会遗失，因第三步执行不了，而第三步则是我们期盼用来防卫资源泄漏的武器，RAII。\n解决方法 使用分离语句\n（1）创建widget\n（2）将它置入一个智能指针，然后再把那个智能指针传给processWidget\nstd::trl::shared_ptr\u0026lt;Widget\u0026gt; pw(new Widget);//在单独语句内以智能指针存储newed所得的对象。\rprocessWidget(pw,priority());//不会造成内存泄漏\r ","id":16,"section":"categories","summary":"资源管理 资源：一旦用了它，将来必须还给系统。 譬如：动态分配内存、文件描述器、互斥锁、图形界面中的字型和笔刷、数据库连接、网络sockets。","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记2","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/2/","year":"2021"},{"content":"接口的设计与声明 接口设计的准则： 让接口容易被正确使用，不容易被误用。\n什么是接口？\n​\t内部实现细节封装起来，外部用户用过预留的接口可以使用接口的功能而不需要知晓内部具体细节。\n​\tC++中，通过类实现面向对象的编程，而在基类中只给出纯虚函数的声明，然后在派生类中实现纯虚函数的具体定义的方式实现接口，不同派生类实现接口的方式也不尽相同，从而实现多态。\n条款18：\t让接口容易被正确使用，不容易被误用。 ### 结论\r  好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。 “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。 “阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。 trl::shared_ptr支持定制删除器。这可防范DLL问题，可被用来自动解除互斥锁（条款14）。  原因 首先必须考虑客户可能做出什么错误。\nclass Date{\rpublic：\rDate（int month，int day，int year）;\r.....\r}\r 如果年月日的顺序错误呢？\n例如\nDate d（30,3,1995）错误\n亦或者按错\nDate d（2,30,1995）\n解决方法 导入简单的外覆类型来区别天数、月份、年份，然后于Date构造函数中使用这些类型：\nstruct Day\r{\rexplicit Day(int d):val(d){}\rint val;\r};\rstruct Month\r{\rexplicit Month(int m):val(m){}\rint val;\r};\rstruct Year\r{\rexplicit Year(int y):val(y){}\rint val;\r};\rclass Date{\rPublic:\rDate（const Month\u0026amp; m,const Day\u0026amp; d,const Year\u0026amp; y）;//包装了一下\r...\r}\rDate d（30,3,1995）;\t//错误！\rDate d（Day（30），Month（3），Year（1995））；//错误\rDate d(Month(3),Day(30),Year(1995))//OK,类型正确\r 条款19：设计class犹如type 结论 class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款覆盖的所有讨论主题。\n如何设计高效的class呢？   新type的对象应该如何被创建和销毁？\n  对象的初始化和对象的赋值该有什么样的差别？\n  新type的对象如果被passed by value(以值传递)，意味着什么？\n  条款20：宁以pass-by-reference-to-const替换pass-by-value 结论  尽量以Pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题。 以上规则并不适用内置类型、STL的迭代器和函数对象。对它们而言，pass-by-value往往比较合适。  条款21：必须返回对象时，别妄想返回其reference 条款22：将成员变量声明为private 从封装角度来看：其实只有两种访问权限：private（提供封装）和其他（不提供封装，即public、protected）\n条款23：宁以non-member、non-friend替换member函数 结论 宁以non-member、non-friend替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性\n原因 一个例子\n想象有一个class用来表示网页浏览器。class可能提供的许多函数中，有一些用来清除下载元素高速缓存区、清除访问过的URLs的历史记录、以及移除系统中的所有cookies：\nclass WebBrowser{\rpublic：\r...\rvoid clearCache(); //清除高速缓存\rvoid clearHistory();//清除历史记录\rvoid removeCookies();//清除cookies\r...\r}\r 许多用户想一个函数执行所有动作，因此webBrowser也提供这样一个函数：\n方法一：\rclass WebBrowser\r{\rpublic:\r...\rvoid clearEverything();//调用clearCache（），clearHistory（）和removeCookies（）\r}\r方法一的行为可以由non-member函数调用适用的member函数而提供出来（方法二）：\r方法二：\rvoid clearBrowser（WebBrowser\u0026amp; wb）\r{\rwb.clearCache(); //清除高速缓存\rwb.clearHistory();//清除历史记录\rwb.removeCookies();//清除cookies\r}\r 方法一与方法二，哪一个更好一些呢？\n从封装性考虑，为保护数据的封装性（private），应该选择方法二。\n封装的目的：愈多的东西被封装，我们改变那些东西的能力也就越大。愈多函数可访问它，数据的封装性就愈低。\n能够访问private成员变量的函数只有class的member函数+friend函数而已。\n因为成员函数（member）可以访问无限制的访问private的数据，而non-member、non-friend函数并不能增加“能访问class内之private成分”的数据。\n铭记：如果要你在一个member函数（它不只是可以访问class内的private数据，也可以取用private函数、enums、typedefs等等）和一个non-member，non-friend函数（它无法访问上述的任何东西）之间做抉择，而且两者提供相同机能，那么，导致较大封装性的是non-member non-friend函数，因此选择后者。 注意：non-member函数也可以是另一个class的member\n条款24：若所有参数皆需类型转换，请为此采用non-member函数 结论 如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member\n","id":17,"section":"categories","summary":"接口的设计与声明 接口设计的准则： 让接口容易被正确使用，不容易被误用。 什么是接口？ ​ 内部实现细节封装起来，外部用户用过预留的接口可以使用接口的","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记3","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/3/","year":"2021"},{"content":"条款05： C++默认编写并调用那些函数 默认创建\nclass Base\r{\rpublic：\rdefualt构造函数\rcopy构造函数\rcopy assignment操作符\r析构函数\r}\r 条款06：若不想使用编译器自动生成的函数，就该明确拒绝（即不可被调用） 作法：\n​\t将默认创建的函数声明为私有的（——private——），为防止member函数和friend函数的内部调用，将成员函数声明为private而且故意不实现它们\nclass HomeForSale\r{\rpublic:\rprivate:\rHomeForSale(const HomeForSale\u0026amp;);\t//只有声明，不实现它们\rHomeForSale\u0026amp; operator=(const HomeForSale\u0026amp;);\r}\r 更为常用的作法： 设计一个基类（base class） ，在这个基类内实现阻止copying等默认函数动作，然后继承它。\n条款07：为多态基类声明virtual析构函数 用法: 1.如果class不含virtual函数，通常表示它并不意图被用做一个base class。\n​\t即：class的设计目的如果不是作为base class使用，或者不是为了具备多态性，就不应该virtual析构函数。\n2.当class不企图被当做base class，令其析构函数为virtual往往是个馊主意\n3.多态性质的base classes应该声明一个virtual析构函数，如果class带有任何virtual函数，他就应该拥有一个virtual析构函数\n目的： 1.C++中基类采用virtual虚析构函数是为了防止内存泄漏。\n2.假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数\n可参考blog  https://blog.csdn.net/sinat_20265495/article/details/51775724?ops_request_misc=\u0026amp;request_id=\u0026amp;biz_id=102\u0026amp;utm_term=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%20virtual\u0026amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-.pc_search_result_before_js\u0026amp;spm=1018.2226.3001.4187 https://blog.csdn.net/yhc166188/article/details/81587442?ops_request_misc=%7B%22request%5Fid%22%3A%22162622287916780261951132%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D  条款08：被让异常逃离析构函数 ###　结论\n１．析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。\n２．如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。\n原因  为什么析构函数不应吐出异常？\nvector的使用\nclass widget{\rpublic:\r~widget(){}\t//假设吐出一个异常\r}\rvoid dosomething()\r{\rstd::vector\u0026lt;Widget\u0026gt; v;\r}\t//v在这里被自动销毁\r 假设v内含十个Widgets,而在析构第一个元素期间，有一个异常被抛出，其他九个widgets还是应该被销毁。\n这会导致多个异常同时存在，程序会结束执行或导致不明确行为。（结论1）\n 若析构函数需要吐出异常，怎么办?\n一个例子： 数据库的连接，创建一个用来管理DBConnection资源的class，并在其析构函数中调用close（）。但close（）函数可能关闭失败，从而输出异常。\nclass DBConn\r{\rpublic:\r~DBConn()//确保数据库连接总是会被关闭\r{\rdb.close();//可能会关闭失败，输出异常\r}\rprivate:\rDBConnection db;\r}\r 如果close（）失败，那么异常会离开~DBConn（）析构函数，成为麻烦。应该阻止异常从析构函数中传播出去。\n解决办法： 1.如果close抛出异常就结束程序。通常通过调用abort完成：\n即：\nDBConn::~DBConn()\r{\rtry{db.close();}\rcatch(...){\r制作运转记录，记录对close（）的调用失败（即日志库）;\rstd::abort();\r}\r}\r 2.吞下因调用close而发生的异常（即对发生的异常，catch中不做处理）：\nDBConn::~DBConn()\r{\rtry{db.close();}\rcatch(...){\r制作运转记录，记录对close（）的调用失败（即日志库）;\r}\r}\r 具体做法 重新设计DBConn接口,给客户一个关闭close函数的机会\nclass DBConn{\rpublic：\r...\rvoid close（）//供客户使用的新函数\r{\rdb.close();\rclosed=true;\r}\r~DBConn()\r{\rif(!closed)\r{\rtry{\rdb.close();\t//关闭连接（如果客户不主动关闭）\r}\rcatch(...){\t//如果关闭动作失败\r制作运转记录，记录对close的调用失败；//记录下来并结束程序 或 吞下异常\r} }\r}\rprivate：\rDBConnectin db;\rbool closed; }\r 条款09：绝不在构造和析构函数过程中调用virtual函数 ###　结论\n在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class\n原因 一个例子：\n模拟股市交易如买进、卖出的订单等，每当创建一个交易对象，在审计日志中也需要创建一笔适当的记录。\n基类\rclass Transaction{\t//所有交易的base class\rpublic:\rTransaction();\rvirtual void logTransaction() const = 0;//做出一份因类型不同而不同的日志记录\r};\rTransaction::Transaction()\r{\r.....\rlogTransaction();\t//问题点\r}\r子类\rclass BuyTansaction:public Transaction{\rpublic:\rvirtual void logTransaction() const; //log此记录\r....\r} class SellTansaction:public Transaction{\rpublic:\rvirtual void logTransaction() const; //log此记录\r....\r} BuyTrasaction b;\r 当BuyTrasaction b后，首先Transaction构造函数一定会被先调用，然后BuyTransaction构造函数被调用。\nTransaction::Transaction()中的logTransaction()函数执行的base class中的logTransaction。\n解决方法 在class Transaction内将logTransaction函数改为non-virtual，然后要求derived class构造函数传递必要信息给Transaction构造函数，而后那个构造函数便可安全地调用non-virtual logTransaction。\n即，通过构造函数的参数传递\n 虚函数是从base class向下调用。 dervice class将必要的构造信息向上传递至base class构造函数。  注意形参\rclass Transaction\r{\rpublic：\rexplicit Transaction(const std::string\u0026amp; logInfo);\rvoid logTransaction(const std::string\u0026amp; logInfo) const;//如今是一个non-virtual函数\r....\r};\rTransaction::Transacton(const std::string\u0026amp; logInfo)\r{\r...\rlogTransaction(logInfo)\r}\rclass BuyTransaction:public Transaction{\rpublic:\rBuyTransaction( parameters ): Transaction（createLogString（parameter））//将log信息传给base class构造函数\r{\r...\r}\r...\rprivate:\rstatic std::string createLogString( parameter );//注意这个函数返回string类型， 函数是static类型的，可以作为构造函数的参数使用\r}\r 函数使用static类型，使之不可能意外指向“初期未成熟之BuyTransaction对象内部尚未初始化的成员变量”。\n","id":18,"section":"categories","summary":"条款05： C++默认编写并调用那些函数 默认创建 class Base { public： defualt构造函数 copy构造函数 copy assignment操作符 析构函数","tags":["cpp","book"],"title":"《C++ Effective》-读书笔记1","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/categories/lang/c/cppeffective/1/","year":"2021"}],"tags":[{"title":"blog","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/blog/"},{"title":"book","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/book/"},{"title":"cpp","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/cpp/"},{"title":"Linux","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/linux/"},{"title":" math","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/math/"},{"title":"net","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/net/"},{"title":"project","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/project/"},{"title":"ros","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/ros/"},{"title":"slam","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/slam/"},{"title":"win10","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/win10/"},{"title":" wsl1","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/wsl1/"},{"title":"导航","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/%E5%AF%BC%E8%88%AA/"},{"title":"概率论","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"title":"矩阵","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/%E7%9F%A9%E9%98%B5/"},{"title":"线性代数","uri":"https://blog-0g8860131649bb29-1304987963.tcloudbaseapp.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]}